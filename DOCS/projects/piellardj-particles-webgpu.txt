Directory structure:
└── piellardj-particles-webgpu/
    ├── README.md
    ├── LICENSE
    ├── package.json
    ├── docs/
    │   ├── index.html
    │   ├── css/
    │   │   ├── attractor-overlay.css
    │   │   └── page.css
    │   ├── readme/
    │   │   ├── index.html
    │   │   └── css/
    │   │       └── page.css
    │   └── script/
    │       ├── main.js
    │       └── page.js
    └── src/
        ├── generate-page.ts
        ├── config/
        │   ├── tsconfig.json
        │   ├── webpack.config.js
        │   └── .eslintrc.json
        ├── resources/
        │   └── attractor-overlay.css
        ├── shaders/
        │   ├── composition.wgsl
        │   ├── draw-instanced-monocolor.wgsl
        │   ├── draw-instanced-multicolor-velocity.wgsl
        │   ├── draw-instanced-multicolor.wgsl
        │   ├── draw-monocolor.wgsl
        │   ├── draw-multicolor-velocity.wgsl
        │   ├── draw-multicolor.wgsl
        │   ├── initialize-colors.wgsl
        │   ├── update.wgsl
        │   └── utils/
        │       └── color.part.wgsl
        └── ts/
            ├── attractors.ts
            ├── engine.ts
            ├── helpers.ts
            ├── image.ts
            ├── main.ts
            ├── parameters.ts
            ├── render/
            │   ├── composition.ts
            │   ├── i-renderer.ts
            │   ├── renderer-high-quality.ts
            │   ├── renderer-instanced-monocolor-high-quality.ts
            │   ├── renderer-instanced-monocolor.ts
            │   ├── renderer-instanced-multicolor-velocity.ts
            │   ├── renderer-instanced-multicolor.ts
            │   ├── renderer-instanced.ts
            │   ├── renderer-monocolor-high-quality.ts
            │   ├── renderer-monocolor.ts
            │   ├── renderer-multicolor-velocity.ts
            │   ├── renderer-multicolor.ts
            │   └── renderer.ts
            └── webgpu-utils/
                ├── image-type.d.ts
                ├── webgpu-canvas.ts
                ├── webgpu-device.ts
                └── wgsl-type.d.ts

================================================
FILE: README.md
================================================
# particles-webgpu

This project a basic particles simulation running fully on GPU, using the new WebGPU API. Particles evolve independently, following simple gravitational rules. There can be several attraction points at once. You can control one with your mouse by pressing the left mouse button.


Chrome 94 brings experimental support for the new WebGPU API. To enable it, a flag is available in `chrome://flags/#enable-unsafe-webgpu`. If you can't find this flag, try using Chrome Canary instead.

This is actually a WebGPU port of my old [particles-gpu](https://github.com/piellardj/particles-gpu) project. The main differences are that this one uses compute shaders, and stores the particles in a GPUBuffer instead of a texture.

See it live [here](https://piellardj.github.io/particles-webgpu/?page%3Acanvas%3Afullscreen=true&page%3Acanvas%3Asidepane=true&page%3Arange%3Aparticles-count-range-id=3).

[![Donate](https://raw.githubusercontent.com/piellardj/piellardj.github.io/master/images/readme/donate-paypal.svg)](https://www.paypal.com/donate/?hosted_button_id=AF7H7GEJTL95E)

## Preview
![Illustration 1](src/readme/01.png)

![Illustration 2](src/readme/02.png)

## Notes
This is my first WebGPU project, so I probably made a few mistakes. Also, I am discovering behaviours that surprise me. Here is a documentation of most of them. I guess what follows is obvious to someone familiar modern APIs such as Vulkan (or even late OpenGL).

### Explicit errors
The first thing I noted is that the browser seems to perform tons of validity checks for each instruction, which makes debugging way easier than WebGL. Moreover, the messages clearly specify which validity check failed, why these checks were performed, etc.

### `var` and `let`
Keywords `var` and `let` don't mean the same thing than in Javascript. In WGSL, `var` declares an object that can vary, while `let` declares an immutable object
[Specification here](https://www.w3.org/TR/WGSL/#var-and-let).

### Alignment of `struct`
I encountered a unexpected behaviour in a shader with a `struct` I used to describe a uniform buffer.

#### Issue
Here is how I described it in the shader (wgsl):
```glsl
struct Uniforms {
    singleFloat: f32;
    vecFloat: vec2<f32>;
};
@group(0) @binding(0) var<uniform> uniforms: Uniforms;
```
and here is how I first created it and included it (javascript):
```javascript
const gpuBuffer = device.createBuffer({
    size: Float32Array.BYTES_PER_ELEMENT * (1 + 2), // one f32 and one vec2<f32>
    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
    mappedAtCreation: false,
});
device.createBindGroup({
    layout: pipeline.getBindGroupLayout(0),
    entries: [{
        binding: 0,
        resource: { buffer: gpuBuffer }
    }]
});
```
To my surprise, Chrome outputed the following error:
```
Binding size (12) is smaller than the minimum binding size (16).
 - While validating entries[0] as a Buffer
 - While validating [BindGroupDescriptor] against [BindGroupLayout]
 - While calling [Device].CreateBindGroup([BindGroupDescriptor]).
```

In an attempt of fixing it, I naively complied and padding the buffer to make its size 16 bytes. It "fixed" this specific issue but things still didn't behave as I expected.
```javascript
// creation
const gpuBuffer = device.createBuffer({
    size: Float32Array.BYTES_PER_ELEMENT * (1 + 2 + 1), // one f32 and one vec2<f32> and one padding float
    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
    mappedAtCreation: false,
});
// ... add it to a bindgroup ;.. //

// writing
const a = ..., b = ..., c = ...;
const floatBuffer = new Float32Array([a, b, c]);
const buffer = floatBuffer.buffer;
device.queue.writeBuffer(this.renderpassUniformsBuffer, 0, buffer);

// ... bind the bindgroup to a renderpass ... //
```
During the shader execution, I expected to have:
```glsl
(uniforms.singleFloat == a) && (uniforms.vecFloat == vec2<f32>(b, c))
```
but instead got:
```glsl
(uniforms.singleFloat == a) && (uniforms.vecFloat == vec2<f32>(c, 0.0))
```

#### Cause and fix
This issue came from alignment of types in WGSL. This behaviour is described in the [Structure Layout Rules](https://www.w3.org/TR/WGSL/#structure-layout-rules) and [Alignment and Size](https://www.w3.org/TR/WGSL/#alignof) sections of the WGSL spec.

Each type has their own alignment requirements. In this case, the relevant info is: `AlignOf(f32) == 4` and `AlignOf(vec2<f32>) == 8`. This means that when I write:
```glsl
struct Uniforms {
    singleFloat: f32;
    vecFloat: vec2<f32>;
};
```
because of the 8-bytes alignment of `vec2<f32>`, it is actually translated as:
```glsl
struct Uniforms {
    singleFloat: f32;
    unusablePaddingFloat: f32;
    vecFloat: vec2<f32>;
};
```
This explains why
- Chrome was requesting a minimum binding size of 16
- and when using the buffer `[a, b, c, 0]` as my uniform buffer, `uniforms.vecFloat` was filled with `(c,0)` instead of `(b,c)`.

Since `f32` are 4-bytes aligned and I don't care about the alignment/stride of the `struct` itself, the fix I used is surprisingly simple: switch my two properties:
```glsl
struct Uniforms {
    vecFloat: vec2<f32>;
    singleFloat: f32;
};
```
It is worth noting that one can explicit alignment and stride of each property with by decorating them with the WGSL attributes `@align(X)` and `@stride(Y)`.

### Usage of Float16
#### Float16 in WGSL
I was surprised to see that according to the [Floating Point Evaluation](https://www.w3.org/TR/WGSL/#floating-point-evaluation) section of the spec, WebGPU uses Float32 precision for shader computations (and 32-bits types in general). What a difference with WebGL where some devices only supported `lowp` !

According to the [Plain types](https://www.w3.org/TR/WGSL/#plain-types-section) section of the WGSL spec, the base types are `bool`, `u32`, `i32`, `f32` but there is no `f16`.

For my computations, storing the positions and velocities as Float16 would be enough. However since I store them in buffers, I have to use Float32, so each particle takes 16 bytes (one `vec2<f32>` for position, one `vec2<f32>` for velocity), which is a lot.
One way to use Float16 for storage would be to use a [`rgba16float`](https://www.w3.org/TR/webgpu/#plain-color-formats) texture and manipulating it texel by texel with [`textureLoad`](https://www.w3.org/TR/WGSL/#textureload) and [`textureStore`](https://www.w3.org/TR/WGSL/#texturestore).

#### Float16 in Javascript
One issue I would have if I used a `rgba16float` texture for storing the position/velocity in a texel would be to initialize this texture. One way to fill a texture is to use the `GPUDevice.GPUQueue.writeTexture` method, by passing it an `ArrayBuffer`. However, sadly in Javascript there is no TypedArray for Float16: there are amongst others `Uint8Array`, `Uint16Array`, `Uint32Array`, `BigUint64Array`, `Float32Array` and `Float64Array` however there is no `Float16Array`. I don't know why this type is lacking but I feel like it would be useful. To avoid this issue, I would have either
- to craft on CPU-side Float16 with bit manipulations
- or to initialize the texture on the GPU. Initial positions are random and having nice random in shaders is a bit tricky. WGSL support bit operations on ui32, so I suppose a simple PCG random number generator could be implemented in a compute shader (maybe by using built-ins such as `GlobalInvocationId` as part of the seed ?).

### Data packing
WebGPU offers nice data packing builtin functions ([see spec here](https://www.w3.org/TR/WGSL/#pack-builtin-functions)) such as `pack4x8unorm` and `unpack4x8unorm`, which allow compact packing of `vec4<f32>` into `u32` (useful for storing colors for instance).



================================================
FILE: LICENSE
================================================
MIT License

Copyright (c) 2021 Jérémie Piellard

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
FILE: package.json
================================================
{
  "name": "particles-webgpu",
  "homepage": "https://piellardj.github.io/particles-webgpu",
  "author": "Jérémie PIELLARD <jeremie.piellard@gmail.com> (https://github.com/piellardj)",
  "repository": "github:piellardj/particles-webgpu",
  "private": true,
  "scripts": {
    "pre-commit": "npm run rebuild && npm run lint",
    "http-server": "http-server ./docs -p 8080",
    "build-page": "ts-node-script src/generate-page.ts",
    "build": "npm run build-page && npm run webpack",
    "clean": "shx rm -rf docs/* **/*generated.*",
    "lint": "eslint src/ts -c src/config/.eslintrc.json --ext .ts",
    "rebuild": "npm run clean && npm run build",
    "webpack": "webpack --config src/config/webpack.config.js"
  },
  "engines": {
    "node": ">=18.16.0"
  },
  "devDependencies": {
    "@typescript-eslint/eslint-plugin": "^5.59.9",
    "@typescript-eslint/parser": "^5.59.9",
    "@webgpu/types": "^0.1.32",
    "eslint": "^8.42.0",
    "http-server": "^14.1.1",
    "shx": "^0.3.4",
    "ts-loader": "^9.4.3",
    "ts-node": "^10.9.1",
    "typescript": "^5.1.3",
    "webpack": "^5.86.0",
    "webpack-cli": "^5.1.4",
    "webpage-templates": "github:piellardj/webpage-templates"
  }
}



================================================
FILE: docs/index.html
================================================
<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="description" content="WebGPU implementation of particles in a gravity field" />
    <title>Particles</title>

    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="icon" type="image/png" href="favicon-16x16.png" sizes="16x16">
    <link rel="icon" type="image/png" href="favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="favicon-96x96.png" sizes="96x96">
    <link rel="stylesheet" type="text/css" href="css/page.css?v=2023-06-11T15%3A37%3A39.276Z">
    <link rel="stylesheet" type="text/css" href="css/attractor-overlay.css?v=2023-06-11T15%3A37%3A39.276Z">
  </head>

  <body>
    <header>
      <a class="logo logo-animate-fill" href="https://piellardj.github.io" id="back-to-home-button" title="Home" aria-label="Home">
        <svg class="logo-icon" xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 64 64">
          <g stroke-width="2">
            <path fill="none" stroke-linejoin="round" d="M17.5,32h4.5v11h7v-7l1,-1h4l1,1v7h7v-11h4.5L32,16.5z" />
        </svg>
      </a>
    </header>
    <main>
      <div class="intro">
        <h1>Particles</h1>

        <div class="description">
          <p>This is a basic particles simulation running fully on GPU, using the new WebGPU API.</p>
          <p>Particles evolve independently, following simple gravitational rules. There can be several attraction points at once. You can control one with your mouse by pressing the left mouse button.</p>

          <br>

          <div class="project-links">
            <a href="https://github.com/piellardj/particles-webgpu">More on GitHub</a> <a href="https://piellardj.github.io/particles-webgpu/readme">Explanations</a>
          </div>
        </div>
      </div>
      <div id="error-messages">
        <noscript>
          You need to enable Javascript to run this experiment.
        </noscript>
      </div>

      <input type="checkbox" id="fullscreen-checkbox-id" class="hidden">
      <div class="demo">
        <input type="checkbox" id="side-pane-checkbox-id" class="hidden">
        <div id="canvas-container">
          <canvas id="canvas"></canvas>
          <div class="loader">
            <span></span>
            <div class="loader-animation"></div>
          </div>
          <div id="indicators">
            <div id="particles-count-indicator-id">
              Particles count: <span></span>
            </div>
          </div>
          <div id="canvas-buttons-column">
            <label class="canvas-button" id="fullscreen-toggle-id" for="fullscreen-checkbox-id"></label>
            <label class="canvas-button" id="side-pane-toggle-id" for="side-pane-checkbox-id"></label>
          </div>
        </div>
        <div class="controls-block">
          <label class="canvas-button" id="side-pane-close-toggle-id" for="side-pane-checkbox-id">
            <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32">
              <line x1="22" y1="22" x2="10" y2="10" stroke-linecap="round" stroke-width="2" />
              <line x1="22" y1="10" x2="10" y2="22" stroke-linecap="round" stroke-width="2" />
            </svg>
          </label>
          <section class="controls-section">
            <h2>Simulation</h2>

            <div class="controls-list">
              <div class="control" id="control-particles-count-range-id">
                <label>Particle count:</label>
                <div class="range-container">
                  <input type="range" min="1" max="20" value="1" step="1" class="slider" id="particles-count-range-id">
                  <div class="range-skin-container">
                    <div class="range-stub">
                      <span class="range-bar range-bar-left range-stub-left"></span>
                    </div>
                    <div class="range-progress">
                      <div class="range-progress-left">
                        <span class="range-bar range-bar-left"></span>
                        <span class="range-handle"></span>
                        <output for="particles-count-range-id" class="range-tooltip"></output>
                      </div>
                      <div class="range-progress-right">
                        <span class="range-bar range-bar-right"></span>
                      </div>
                    </div>
                    <div class="range-stub">
                      <span class="range-bar range-bar-right range-stub-right"></span>
                    </div>
                  </div>
                </div>
              </div>
              <div class="control" id="control-speed-range-id">
                <label>Speed:</label>
                <div class="range-container">
                  <input type="range" min="0" max="1" value="0.5" step="0.05" class="slider" id="speed-range-id">
                  <div class="range-skin-container">
                    <div class="range-stub">
                      <span class="range-bar range-bar-left range-stub-left"></span>
                    </div>
                    <div class="range-progress">
                      <div class="range-progress-left">
                        <span class="range-bar range-bar-left"></span>
                        <span class="range-handle"></span>
                        <output for="speed-range-id" class="range-tooltip"></output>
                      </div>
                      <div class="range-progress-right">
                        <span class="range-bar range-bar-right"></span>
                      </div>
                    </div>
                    <div class="range-stub">
                      <span class="range-bar range-bar-right range-stub-right"></span>
                    </div>
                  </div>
                </div>
              </div>
              <div class="control" id="control-friction-range-id">
                <label>Friction:</label>
                <div class="range-container">
                  <input type="range" min="0.998" max="1" value="0.9995" step="0.0001" class="slider" id="friction-range-id">
                  <div class="range-skin-container">
                    <div class="range-stub">
                      <span class="range-bar range-bar-left range-stub-left"></span>
                    </div>
                    <div class="range-progress">
                      <div class="range-progress-left">
                        <span class="range-bar range-bar-left"></span>
                        <span class="range-handle"></span>
                        <output for="friction-range-id" class="range-tooltip"></output>
                      </div>
                      <div class="range-progress-right">
                        <span class="range-bar range-bar-right"></span>
                      </div>
                    </div>
                    <div class="range-stub">
                      <span class="range-bar range-bar-right range-stub-right"></span>
                    </div>
                  </div>
                </div>
              </div>
              <div class="control" id="control-bounce-checkbox-id">
                <label>Bounce:</label>
                <div class="checkbox">
                  <input type="checkbox" id="bounce-checkbox-id" checked>
                  <label for="bounce-checkbox-id" class="checkmark"></label>
                </div>
              </div>
              <div class="control" id="control-gravity-range-id">
                <label>Gravity:</label>
                <div class="range-container">
                  <input type="range" min="0" max="1" value="0.1" step="0.001" class="slider" id="gravity-range-id">
                  <div class="range-skin-container">
                    <div class="range-stub">
                      <span class="range-bar range-bar-left range-stub-left"></span>
                    </div>
                    <div class="range-progress">
                      <div class="range-progress-left">
                        <span class="range-bar range-bar-left"></span>
                        <span class="range-handle"></span>
                        <output for="gravity-range-id" class="range-tooltip"></output>
                      </div>
                      <div class="range-progress-right">
                        <span class="range-bar range-bar-right"></span>
                      </div>
                    </div>
                    <div class="range-stub">
                      <span class="range-bar range-bar-right range-stub-right"></span>
                    </div>
                  </div>
                </div>
              </div>
              <div class="control" id="control-reset-button-id">
                <button class="button  flat" id="reset-button-id">Reset</button>
              </div>
            </div>
          </section>
          <hr />
          <section class="controls-section">
            <h2>Attractors</h2>

            <div class="controls-list">
              <div class="control" id="control-attraction-range-id">
                <label>Mouse force:</label>
                <div class="range-container">
                  <input type="range" min="-1" max="1" value="0.7" step="0.05" class="slider" id="attraction-range-id">
                  <div class="range-skin-container">
                    <div class="range-stub">
                      <span class="range-bar range-bar-left range-stub-left"></span>
                    </div>
                    <div class="range-progress">
                      <div class="range-progress-left">
                        <span class="range-bar range-bar-left"></span>
                        <span class="range-handle"></span>
                        <output for="attraction-range-id" class="range-tooltip"></output>
                      </div>
                      <div class="range-progress-right">
                        <span class="range-bar range-bar-right"></span>
                      </div>
                    </div>
                    <div class="range-stub">
                      <span class="range-bar range-bar-right range-stub-right"></span>
                    </div>
                  </div>
                </div>
              </div>
              <div class="control" id="control-attractors-preset-select-id">
                <label>Preset:</label>
                <div class="select-container compact" id="attractors-preset-select-id">
                  <div class="select-current-value" data-value="orbit">Orbit</div>
                  <div class="select-values-list" data-placeholder="Custom">
                    <div class="select-value" data-value="none">None</div>
                    <div class="select-value" data-value="orbit">Orbit</div>
                    <div class="select-value" data-value="sines">Sines</div>
                    <div class="select-value" data-value="central-attractive">Central (attractive)</div>
                    <div class="select-value" data-value="central-repulsive">Central (replusilve)</div>
                  </div>
                </div>
              </div>
              <div class="control" id="control-display-attractors-checkbox-id">
                <label>Display:</label>
                <div class="checkbox">
                  <input type="checkbox" id="display-attractors-checkbox-id" checked>
                  <label for="display-attractors-checkbox-id" class="checkmark"></label>
                </div>
              </div>
            </div>
          </section>
          <hr />
          <section class="controls-section">
            <h2>Colors</h2>

            <div class="controls-list">
              <div class="control" id="control-colors-mode-tabs-id">
                <label>Mode:</label>
                <div class="tabs compact" id="colors-mode-tabs-id-id">
                  <input type="radio" name="colors-mode-tabs-id" value="unicolor" id="colors-mode-tabs-id-unicolor-id" checked />
                  <label for="colors-mode-tabs-id-unicolor-id">Unicolor</label>
                  <input type="radio" name="colors-mode-tabs-id" value="multicolor" id="colors-mode-tabs-id-multicolor-id" />
                  <label for="colors-mode-tabs-id-multicolor-id">Multicolor</label>
                </div>
              </div>
              <div class="control" id="control-auto-color-checkbox-id">
                <label>Auto:</label>
                <div class="checkbox">
                  <input type="checkbox" id="auto-color-checkbox-id" checked>
                  <label for="auto-color-checkbox-id" class="checkmark"></label>
                </div>
              </div>
              <div class="control" id="control-high-color-quality-checkbox-id">
                <label>High quality:</label>
                <div class="checkbox">
                  <input type="checkbox" id="high-color-quality-checkbox-id">
                  <label for="high-color-quality-checkbox-id" class="checkmark"></label>
                </div>
              </div>
              <div class="control" id="control-particle-color-id">
                <label>Particle color:</label>

                <div class="color-picker-container">
                  <div class="color-picker  compact" id="particle-color-id" data-current-color="#BC4212">
                    <div class="color-preview">&nbsp;</div>
                    <span class="color-value">#BC4212</span>
                  </div>
                </div>
              </div>
              <div class="control" id="control-color-source-tabs-id">
                <label>Source:</label>
                <div class="tabs compact" id="color-source-tabs-id-id">
                  <input type="radio" name="color-source-tabs-id" value="image" id="color-source-tabs-id-image-id" checked />
                  <label for="color-source-tabs-id-image-id">From image</label>
                  <input type="radio" name="color-source-tabs-id" value="velocity" id="color-source-tabs-id-velocity-id" />
                  <label for="color-source-tabs-id-velocity-id">From velocity</label>
                </div>
              </div>
              <div class="control" id="control-image-preset-select-id">
                <label>Image:</label>
                <div class="select-container compact" id="image-preset-select-id">
                  <div class="select-current-value" data-value="colors">Colors</div>
                  <div class="select-values-list" data-placeholder="Custom">
                    <div class="select-value" data-value="colors">Colors</div>
                    <div class="select-value" data-value="ladybug">Ladybug</div>
                  </div>
                </div>
              </div>
              <div class="control" id="control-input-image-upload-button">
                <label>Custom:</label>
                <div class="file-control upload compact">
                  <input type="file" name="file" id="input-image-upload-button" class="file-input" accept=".png,.jpg,.bmp,.webp" />
                  <label class="file-control-button" for="input-image-upload-button">
                    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32">
                      <path d="M12 22L12 13 7 13 16 2 25 13 20 13 20 22ZM6 25L26 25 26 29 6 29Z" />
                    </svg>
                    <span data-placeholder="Upload an image">Upload an image</span>
                  </label>
                </div>
              </div>
            </div>
          </section>
          <hr />
          <section class="controls-section">
            <h2>Rendering</h2>

            <div class="controls-list">
              <div class="control" id="control-sprite-size-range-id">
                <label>Particle size:</label>
                <div class="range-container">
                  <input type="range" min="1" max="17" value="1" step="2" class="slider" id="sprite-size-range-id">
                  <div class="range-skin-container">
                    <div class="range-stub">
                      <span class="range-bar range-bar-left range-stub-left"></span>
                    </div>
                    <div class="range-progress">
                      <div class="range-progress-left">
                        <span class="range-bar range-bar-left"></span>
                        <span class="range-handle"></span>
                        <output for="sprite-size-range-id" class="range-tooltip"></output>
                      </div>
                      <div class="range-progress-right">
                        <span class="range-bar range-bar-right"></span>
                      </div>
                    </div>
                    <div class="range-stub">
                      <span class="range-bar range-bar-right range-stub-right"></span>
                    </div>
                  </div>
                </div>
              </div>
              <div class="control" id="control-blending-checkbox-id">
                <label>Blending:</label>
                <div class="checkbox">
                  <input type="checkbox" id="blending-checkbox-id" checked>
                  <label for="blending-checkbox-id" class="checkmark"></label>
                </div>
              </div>
              <div class="control" id="control-opacity-range-id">
                <label>Particle opacity:</label>
                <div class="range-container">
                  <input type="range" min="0.01" max="1" value="0.1" step="0.005" class="slider" id="opacity-range-id">
                  <div class="range-skin-container">
                    <div class="range-stub">
                      <span class="range-bar range-bar-left range-stub-left"></span>
                    </div>
                    <div class="range-progress">
                      <div class="range-progress-left">
                        <span class="range-bar range-bar-left"></span>
                        <span class="range-handle"></span>
                        <output for="opacity-range-id" class="range-tooltip"></output>
                      </div>
                      <div class="range-progress-right">
                        <span class="range-bar range-bar-right"></span>
                      </div>
                    </div>
                    <div class="range-stub">
                      <span class="range-bar range-bar-right range-stub-right"></span>
                    </div>
                  </div>
                </div>
              </div>
              <div class="control" id="control-show-indicators-checkbox-id">
                <label>Show indicators:</label>
                <div class="checkbox">
                  <input type="checkbox" id="show-indicators-checkbox-id" checked>
                  <label for="show-indicators-checkbox-id" class="checkmark"></label>
                </div>
              </div>
            </div>
          </section>
        </div>
      </div>
    </main>

    <footer>
      <div class="badge-shelf">
        <a class="badge" href="mailto:jeremie.piellard@gmail.com" title="Email">
          <svg xmlns="http://www.w3.org/2000/svg" width="32px" height="32px" viewBox="0 0 512 512">
            <path d="M512 85V448H0V85l256 224L512 85zM488 64H24L256 267 488 64z" />
          </svg>
        </a>

        <a class="badge" href="https://github.com/piellardj" title="GitHub">
          <svg xmlns="http://www.w3.org/2000/svg" width="32px" height="32px" viewBox="0 0 1024 1024">
            <path d="M512 0C229 0 0 229 0 512c0 226 147 418 350 486 26 5 35-11 35-25 0-12 0-53-1-95C242 909 212 818 212 818c-23-59-57-75-57-75-47-32 4-31 4-31 51 4 78 53 78 53 46 78 120 56 149 43 5-33 18-56 33-68C305 725 185 682 185 485c0-56 20-102 53-137-5-13-23-65 5-136 0 0 43-14 141 53 41-11 85-17 128-17 44 0 87 6 128 17 98-66 141-52 141-52 28 71 10 123 5 136 33 36 53 81 53 137 0 197-120 240-234 253 18 16 35 47 35 95 0 68-1 124-1 141 0 14 9 30 35 25C877 930 1024 738 1024 512 1024 229 795 0 512 0z" />
          </svg>
        </a>

        <a class="badge" href="https://www.linkedin.com/in/jeremie-piellard/" title="LinkedIn">
          <svg xmlns="http://www.w3.org/2000/svg" width="32px" height="32px" viewBox="0 0 512 512">
            <path d="M30 177l93-1v304l-93 1v-304z" />
            <path d="M200 177l89-1v39l0 11c26-26 53-45 97-45 51 0 100 21 100 91v208l-90 1v-159c0-35-9-58-51-58-37 0-52 7-52 55v160l-92 1v-304z" />
            <path d="M128 81c0 28-23 51-51 51s-51-23-51-51c0-28 23-51 51-51 28 0 51 23 51 51z" />
          </svg>
        </a>
      </div>
    </footer>
    <script type="text/javascript">
      var Page = Page || {};
      Object.defineProperty(Page, "version", {
        value: "2023-06-11T15%3A37%3A39.276Z",
        writable: false,
      });
    </script>
    <script src="script/page.min.js?v=2023-06-11T15%3A37%3A39.276Z"></script>
    <script src="script/main.js?v=2023-06-11T15%3A37%3A39.276Z"></script>
  </body>

</html>


================================================
FILE: docs/css/attractor-overlay.css
================================================
.attractor-overlay {
    position: absolute;
    content: '';
    transform: translate(-50%,-50%);
    width: 16px;
    height: 16px;
    border: 3px solid red;
    border-radius: 50%;
    background: none;
    pointer-events: none;
}



================================================
FILE: docs/css/page.css
================================================
body{text-align:center}#error-messages{margin:32px 8px;color:red;font-weight:bold}.demo{display:flex;flex-flow:row wrap;align-items:flex-start;justify-content:center;user-select:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none}
.logo{display:block;position:relative;width:64px;height:64px;margin:8px auto 16px;border-radius:50%;user-select:none;box-sizing:border-box}.logo,.logo:hover,.logo:focus,.logo:active{border-width:1px;border-style:solid;border-color:#009688;border-color:var(--var-color-control-accent, #009688)}.logo::before,.logo svg.logo-icon,.logo::after{position:absolute;top:-1px;left:-1px;width:64px;height:64px;border-radius:50%;pointer-events:none}.logo svg.logo-icon{stroke:#009688;stroke:var(--var-color-control-accent, #009688);fill:#009688;fill:var(--var-color-control-accent, #009688)}.logo::before{content:"";transform:scale(0);-webkit-transform:scale(0);-ms-transform:scale(0);transition:.1s ease;-webkit-transition:.1s ease}.logo.logo-animate-fill .logo::before{content:"";transform:scale(0);-webkit-transform:scale(0);-ms-transform:scale(0);transition:.1s ease;-webkit-transition:.1s ease}.logo:hover::before{transform:scale(1);-webkit-transform:scale(1);-ms-transform:scale(1)}.logo.logo-animate-fill{background:#eeeeee;background:var(--var-color-block-background, #eeeeee)}.logo.logo-animate-fill::before{background:#009688;background:var(--var-color-control-accent, #009688)}.logo.logo-animate-fill:hover svg.logo-icon{fill:#fff;stroke:#fff}.logo.logo-animate-empty{background:#009688;background:var(--var-color-control-accent, #009688)}.logo.logo-animate-empty::before{top:0;left:0;width:62px;height:62px;background:#eeeeee;background:var(--var-color-block-background, #eeeeee)}
.intro{margin:auto;padding:16px;border-radius:8px;border:1px solid #c9c9c9;border:var(--var-color-block-border, 1px solid #c9c9c9);background:#eeeeee;background:var(--var-color-block-background, #eeeeee)}.intro h1{margin-top:0;text-align:center}@media only screen and (min-width: 560px){.intro{max-width:512px;border-width:1px}}.description{justify-content:center;line-height:125%;text-align:justify;text-indent:1em}.project-links{display:flex;flex-flow:row;justify-content:space-between;text-indent:0}
a{color:#009688;color:var(--var-color-control-accent, #009688);font-weight:bold;text-decoration:none;box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;border-width:0 0 2px;border-style:solid;border-color:rgba(0,0,0,0)}a:focus,a:hover{border-color:#009688;border-color:var(--var-color-control-accent, #009688)}
.canvas-button{width:32px;height:32px;cursor:pointer}#canvas-container{position:relative;margin-bottom:16px;background:#000;overflow:hidden}@media only screen and (min-width: 540px){#canvas-container{margin:16px}}#canvas-container>canvas{width:100%;height:100%;z-index:10}#canvas-container>.loader{display:none}#indicators{display:flex;position:absolute;top:1px;left:1px;flex-direction:column;align-items:flex-start;color:#fff;font-family:"Lucida Console",Monaco,monospace;text-align:left;z-index:20}#indicators>div{flex:0 0 1em;margin:1px;padding:1px 4px;background:#000}#canvas-buttons-column{position:absolute;top:0;right:0;width:32px;z-index:30}#fullscreen-toggle-id{display:block;background-image:url("../images/resize.svg");background-position:0 0;background-size:200%}#fullscreen-toggle-id:hover{background-position-x:100%}#side-pane-toggle-id{display:none;background-image:url("../images/gear.svg");transition:transform .1s ease-in-out;-webkit-transition:transform .1s ease-in-out}#side-pane-toggle-id:hover{transform:rotate(-30deg);-webkit-transform:rotate(-30deg);-ms-transform:rotate(-30deg)}#side-pane-checkbox-id:checked+#canvas-container #side-pane-toggle-id:hover{transform:rotate(30deg);-webkit-transform:rotate(30deg);-ms-transform:rotate(30deg)}.hidden{display:none}#fullscreen-checkbox-id:checked+.demo{position:fixed;overflow:hidden}#fullscreen-checkbox-id:checked+.demo #canvas-container{position:fixed;top:0;left:0;width:100vw;height:100vh;margin:0;overflow:hidden;z-index:5}#fullscreen-checkbox-id:checked+.demo #canvas-container #canvas-buttons-column{transition:transform .2s ease-in-out;-webkit-transition:transform .2s ease-in-out}#fullscreen-checkbox-id:checked+.demo #canvas-container #fullscreen-toggle-id{background-position-y:100%}@media only screen and (min-width: 500px){#fullscreen-checkbox-id:checked+.demo #canvas-container #side-pane-toggle-id{display:block}}#fullscreen-checkbox-id:checked+.demo #side-pane-checkbox-id:checked+#canvas-container #canvas-buttons-column{transform:translateX(-400px)}
.loader{position:absolute;top:0;right:0;bottom:0;left:0;width:120px;height:120px;margin:auto}.loader>span{color:#fff;font-size:32px;line-height:120px;text-shadow:1px 1px #000,-1px 1px #000,1px -1px #000,-1px -1px #000,1px 0 #000,-1px 0 #000,0 1px #000,0 -1px #000}.loader-animation{position:absolute;top:0;left:0;width:120px;height:120px;animation:spin 1.1s linear infinite}.loader-animation:before{position:absolute;top:-1px;left:-1px;width:122px;height:122px;border:6px solid rgba(0,0,0,0);border-top:6px solid #000;border-radius:50%;content:"";z-index:50;box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box}.loader-animation:after{position:absolute;top:0;left:0;width:120px;height:120px;border:4px solid rgba(0,0,0,0);border-top:4px solid #fff;border-radius:50%;content:"";z-index:51;box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box}@keyframes spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}
.canvas-button{width:32px;height:32px;cursor:pointer}.controls-block{flex:1 0 0;max-width:36em;margin:16px 0;padding:12px 0;border-radius:8px;border:1px solid #c9c9c9;border:var(--var-color-block-border, 1px solid #c9c9c9);background:#eeeeee;background:var(--var-color-block-background, #eeeeee);z-index:0}@media only screen and (min-width: 540px){.controls-block{margin:16px}}.controls-block>hr{margin:12px 0;clear:both;border:none;border-top:1px solid #c9c9c9;border-top:var(--var-color-block-border, 1px solid #c9c9c9)}.controls-section{display:flex;flex-flow:row wrap;align-items:baseline;margin:0 16px}.controls-section>h2{width:7em;margin:0;font-size:medium;font-weight:bold;line-height:2em;text-align:left}.controls-section>.controls-list{display:flex;flex-direction:column;flex-grow:1}.controls-list>.control{display:flex;flex-flow:row wrap;align-items:center;min-width:300px;padding:3px 0}.control>label{min-width:8em;font-size:95%;line-height:95%;text-align:left}#fullscreen-checkbox-id:checked+.demo #side-pane-checkbox-id~.controls-block{position:fixed;top:0;left:100%;width:400px;max-height:calc(100% - 48px);margin:0;border-width:0 0 1px 1px;border-radius:0 0 0 8px;z-index:50;overflow-x:hidden;overflow-y:auto;transition:transform .2s ease-in-out;-webkit-transition:transform .2s ease-in-out}#fullscreen-checkbox-id:checked+.demo #side-pane-checkbox-id~.controls-block::-webkit-scrollbar{width:16px}#fullscreen-checkbox-id:checked+.demo #side-pane-checkbox-id~.controls-block::-webkit-scrollbar-track{border-radius:8px;background-color:#eeeeee;background-color:var(--var-color-block-background, #eeeeee)}#fullscreen-checkbox-id:checked+.demo #side-pane-checkbox-id~.controls-block::-webkit-scrollbar-thumb{border-width:3px 5px;border-style:solid;border-radius:8px;border-color:#eeeeee;border-color:var(--var-color-block-background, #eeeeee);background-color:#a5a5a5;background-color:var(--var-color-scrollbar, #a5a5a5)}#fullscreen-checkbox-id:checked+.demo #side-pane-checkbox-id~.controls-block::-webkit-scrollbar-thumb:focus,#fullscreen-checkbox-id:checked+.demo #side-pane-checkbox-id~.controls-block::-webkit-scrollbar-thumb:hover{background-color:#b2b2b2;background-color:var(--var-color-scrollbar-hover, #b2b2b2)}#fullscreen-checkbox-id:checked+.demo #side-pane-checkbox-id~.controls-block::-webkit-scrollbar-thumb:active{background-color:#959595;background-color:var(--var-color-scrollbar-active, #959595)}#fullscreen-checkbox-id:checked+.demo #side-pane-checkbox-id~.controls-block:hover::-webkit-scrollbar-thumb{border-width:3px}#fullscreen-checkbox-id:checked+.demo #side-pane-checkbox-id:checked~.controls-block{transform:translateX(-100%);-webkit-transform:translateX(-100%);-ms-transform:translateX(-100%)}#fullscreen-checkbox-id:checked+.demo #side-pane-checkbox-id:checked~.controls-block .tooltip{transform:translateX(-100vw) translateX(400px);-webkit-transform:translateX(-100vw) translateX(400px);-ms-transform:translateX(-100vw) translateX(400px)}#fullscreen-checkbox-id:checked+.demo #side-pane-checkbox-id:checked~.controls-block>#side-pane-close-toggle-id{display:block}#side-pane-close-toggle-id{display:none;position:absolute;top:0;right:0}#side-pane-close-toggle-id svg{stroke:#5e5e5e;stroke:var(--var-color-block-actionitem, #5e5e5e)}#side-pane-close-toggle-id svg:focus,#side-pane-close-toggle-id svg:hover{stroke:#7e7e7e;stroke:var(--var-color-block-actionitem-hover, #7e7e7e)}#side-pane-close-toggle-id svg:active{stroke:#535353;stroke:var(--var-color-block-actionitem-active, #535353)}
.range-container{display:inline-block;position:relative;flex:1 1 0%;width:100%;min-width:15px;height:26px}.range-container input[type=range]{width:100%;min-width:128px;height:100%;margin:0;padding:0;opacity:0}.range-container input[type=range]:not(:disabled){cursor:pointer}.range-container .range-skin-container{display:flex;position:absolute;top:0;left:0;flex-flow:nowrap;width:100%;height:100%;pointer-events:none;user-select:none}.range-container .range-stub{position:relative;flex-grow:0;flex-shrink:0;width:7px}.range-container .range-progress{display:flex;flex:1;flex-flow:row nowrap}.range-container .range-progress-left{position:relative;flex-grow:0;flex-shrink:0;width:85%}.range-container .range-progress-right{position:relative;flex-grow:1}.range-container .range-bar{position:absolute;left:0;width:100%;z-index:0}.range-container .range-bar.range-bar-left{top:12px;height:3px}.range-container .range-bar.range-bar-right{top:12px;height:3px;background:#c9c9c9;background:var(--var-color-control-neutral, #c9c9c9)}.range-container .range-bar.range-stub-left{border-radius:3px 0 0 3px}.range-container .range-bar.range-stub-right{border-radius:0 3px 3px 0}.range-container .range-handle{position:absolute;top:5.5px;right:-7.5px;width:15px;height:15px;border-radius:50%;z-index:1}.range-container .range-bar-left,.range-container .range-handle{background:#009688;background:var(--var-color-control-accent, #009688)}.range-container input[type=range]:not(:disabled):hover+.range-skin-container .range-handle,.range-container input[type=range]:not(:disabled):focus+.range-skin-container .range-handle{background:#26a69a;background:var(--var-color-control-accent-hover, #26a69a)}.range-container input[type=range]:not(:disabled):active+.range-skin-container .range-handle{background:#00897b;background:var(--var-color-control-accent-active, #00897b)}.range-container input[type=range]:disabled+.range-skin-container .range-bar-left,.range-container input[type=range]:disabled+.range-skin-container .range-handle{background:#a5a5a5}.range-container .range-tooltip{position:absolute;top:-28px;right:0;min-width:24px;padding:4px;transform:translateX(50%);transition:opacity .1s ease-in-out;border-radius:4px;background:#535353;color:#eee;font-size:87.5%;text-align:center;opacity:0;z-index:2}.range-container input[type=range]:hover+.range-skin-container .range-tooltip,.range-container input[type=range]:active+.range-skin-container .range-tooltip,.range-container input[type=range]:focus+.range-skin-container .range-tooltip{opacity:1}.range-container .range-tooltip::after{position:absolute;top:100%;left:50%;width:0px;height:12px;margin-left:-6px;border-width:6px;border-style:solid;border-color:#535353 rgba(0,0,0,0) rgba(0,0,0,0);content:""}
.checkbox{display:block;position:relative;text-align:left;user-select:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none}.checkbox>input[type=checkbox]{width:1px;height:1px;opacity:0}.checkbox>input[type=checkbox]+label.checkmark,.checkbox>input[type=checkbox]+label.checkmark-line{margin-left:24px;line-height:26px;cursor:pointer}.checkbox>input[type=checkbox]:disabled+label.checkmark,.checkbox>input[type=checkbox]:disabled+label.checkmark-line{cursor:default}.checkbox>input[type=checkbox]+label.checkmark::before{position:absolute;top:calc(.5*(100% - 20px));left:0;width:20px;height:20px;border-width:2px;border-style:solid;border-radius:2px;background:none;content:"";box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box}.checkbox>input[type=checkbox]+label.checkmark::after{position:absolute;top:calc(.5*(100% - 20px) + .5*(20px - 14px));right:0;bottom:0;left:6.5px;width:7px;height:14px;border:solid #fff;border-width:0 3px 3px 0;background:none;content:"";box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;transform:translate(0, -1px) scale(0) rotate(45deg);-webkit-transform:translate(0, -1px) scale(0) rotate(45deg);-ms-transform:translate(0, -1px) scale(0) rotate(45deg)}.checkbox>input[type=checkbox]:checked+label.checkmark::after{transform:translate(0, -1px) scale(1) rotate(45deg);-webkit-transform:translate(0, -1px) scale(1) rotate(45deg);-ms-transform:translate(0, -1px) scale(1) rotate(45deg)}.checkbox>input[type=checkbox]+label.checkmark::before{border-color:#009688;border-color:var(--var-color-control-accent, #009688)}.checkbox>input[type=checkbox]:checked+label.checkmark::before{background:#009688;background:var(--var-color-control-accent, #009688)}.checkbox>input[type=checkbox]:hover+label.checkmark::before,.checkbox>input[type=checkbox]:focus+label.checkmark::before{border-color:#26a69a;border-color:var(--var-color-control-accent-hover, #26a69a)}.checkbox>input[type=checkbox]:hover:checked+label.checkmark::before,.checkbox>input[type=checkbox]:focus:checked+label.checkmark::before{background:#26a69a;background:var(--var-color-control-accent-hover, #26a69a)}.checkbox>input[type=checkbox]:active+label.checkmark::before{border-color:#00897b;border-color:var(--var-color-control-accent-active, #00897b)}.checkbox>input[type=checkbox]:active:checked+label.checkmark::before{background:#00897b;background:var(--var-color-control-accent-active, #00897b)}.checkbox>input[type=checkbox]:disabled+label.checkmark::before{border-color:#a5a5a5}.checkbox>input[type=checkbox]:disabled:checked+label.checkmark::before{background:#a5a5a5}
.button{position:relative;padding:8px 14px;border:none;border-radius:4px;font-size:87.5%;font-weight:bold;cursor:pointer}.button.compact{padding:6px 14px;font-size:75%}.button.flat{padding:6px 12px;border-width:2px;border-style:solid;box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box}.button.flat.compact{padding:4px 12px}.button{background:#009688;background:var(--var-color-control-accent, #009688);color:#fff}.button:focus,.button:hover:not(:disabled){outline:0px;background:#26a69a;background:var(--var-color-control-accent-hover, #26a69a)}.button:active:not(:disabled){outline:0px;background:#00897b;background:var(--var-color-control-accent-active, #00897b)}.button:disabled{background:#a5a5a5;cursor:default}.button.flat{border-color:#009688;border-color:var(--var-color-control-accent, #009688);background:none;color:#009688;color:var(--var-color-control-accent, #009688)}.button.flat:focus,.button.flat:hover:not(:disabled){border-color:#26a69a;border-color:var(--var-color-control-accent-hover, #26a69a);background:none;color:#26a69a;color:var(--var-color-control-accent-hover, #26a69a)}.button.flat:active:not(:disabled){border-color:#00897b;border-color:var(--var-color-control-accent-active, #00897b);background:rgba(0,150,136,.1);color:#00897b;color:var(--var-color-control-accent-active, #00897b)}.button.flat:disabled{border-color:#a5a5a5;background:none;color:#a5a5a5}
.select-container{display:inline-block;position:relative;text-align:left;user-select:none}.select-container .select-value,.select-container .select-current-value{padding:0 12px;text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.select-container .select-current-value{padding-right:24px;border-width:2px;border-style:solid;border-color:#c9c9c9;border-color:var(--var-color-control-neutral, #c9c9c9);border-radius:4px;font-size:87.5%;font-weight:bold;line-height:28px}.select-container .select-current-value::after{position:absolute;top:13px;right:10px;width:0;height:0;border-width:7px;border-style:solid;border-color:rgba(0,0,0,0);content:"";border-top-color:#009688;border-top-color:var(--var-color-control-accent, #009688)}.select-container.expanded .select-current-value{border-radius:4px 4px 0 0;border-color:#26a69a;border-color:var(--var-color-control-accent-hover, #26a69a);border-bottom-color:#c9c9c9;border-bottom-color:var(--var-color-control-neutral, #c9c9c9)}.select-container.expanded .select-current-value::after{top:5px;border-color:rgba(0,0,0,0);border-bottom-color:#26a69a;border-bottom-color:var(--var-color-control-accent-hover, #26a69a)}.select-container.compact .select-current-value{font-size:75%;line-height:22px}.select-container.compact .select-current-value::after{top:10px}.select-container.compact.expanded .select-current-value::after{top:2px}.select-container:not(.expanded) .select-current-value{cursor:pointer}.select-container:not(.expanded):hover .select-current-value{border-color:#26a69a;border-color:var(--var-color-control-accent-hover, #26a69a)}.select-container:not(.expanded):hover .select-current-value::after{border-top-color:#26a69a;border-top-color:var(--var-color-control-accent-hover, #26a69a)}.select-container:not(.expanded):active .select-current-value{border-color:#00897b;border-color:var(--var-color-control-accent-active, #00897b)}.select-container:not(.expanded):active .select-current-value::after{border-top-color:#00897b;border-top-color:var(--var-color-control-accent-active, #00897b)}.select-container .select-values-list{display:none;position:absolute;top:100%;left:0;width:100%;border-width:0 2px 2px;border-style:solid;border-color:#26a69a;border-color:var(--var-color-control-accent-hover, #26a69a);border-radius:0 0 4px 4px;font-size:87.5%;line-height:32px;box-shadow:0 10px 16px rgba(0,0,0,.2);z-index:3;box-sizing:border-box;background:#fff;background:var(--var-color-theme, white)}.select-container .select-values-list::before{position:absolute;top:-4px;left:-2px;width:100%;height:6px;border-width:0 2px;border-style:solid;content:"";border-color:#26a69a;border-color:var(--var-color-control-accent-hover, #26a69a)}.select-container.expanded .select-values-list{display:block}.select-container.expanded .select-values-list .select-value{cursor:pointer}.select-container.expanded .select-values-list .select-value:hover{background:rgba(0,150,136,.1)}
.tabs{display:flex;position:relative;flex-flow:row wrap;flex-grow:1;width:auto;border-radius:4px;background:none;overflow:hidden}.tabs::after{position:absolute;top:0;left:0;width:100%;height:100%;border-width:2px;border-style:solid;border-color:#c9c9c9;border-color:var(--var-color-control-neutral, #c9c9c9);border-radius:4px;content:"";z-index:1;box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box}.tabs.compact>input+label{padding:6px 14px;font-size:75%}.tabs>input{position:absolute;top:0;left:0;width:1px;height:1px;opacity:0}.tabs>input+label{flex:1;padding:8px 14px;font-size:87.5%;font-weight:bold;text-align:center;white-space:nowrap;cursor:pointer;z-index:2}.tabs>input:disabled+label,.tabs>input[type=radio]:checked+label{cursor:default}.tabs>input+label{background:none;color:#009688;color:var(--var-color-control-accent, #009688)}.tabs>input:checked+label{background:#009688;background:var(--var-color-control-accent, #009688);color:#fff}.tabs>input:disabled+label{background:none;color:#a5a5a5}.tabs>input:disabled:checked+label{background:#a5a5a5;color:#fff}.tabs>input[type=checkbox]:not(:disabled):hover+label,.tabs>input[type=checkbox]:not(:disabled):focus+label{background:rgba(0,150,136,.05)}.tabs>input[type=checkbox]:not(:disabled):hover:checked+label,.tabs>input[type=checkbox]:not(:disabled):focus:checked+label{background:#26a69a;background:var(--var-color-control-accent-hover, #26a69a)}.tabs>input[type=checkbox]:not(:disabled):active+label{background:rgba(0,150,136,.1)}.tabs>input[type=checkbox]:not(:disabled):active:checked+label{background:#00897b;background:var(--var-color-control-accent-active, #00897b)}.tabs>input[type=radio]:not(:disabled):not(:checked):hover+label,.tabs>input[type=radio]:not(:disabled):not(:checked):focus+label{background:rgba(0,150,136,.05)}.tabs>input[type=radio]:not(:disabled):not(:checked):active+label{background:rgba(0,150,136,.1)}
.color-picker-container{position:relative}.color-picker{display:flex;flex-flow:row;align-items:center;cursor:pointer}.color-preview{width:32px;height:32px;margin-right:12px;border-width:2px;border-style:solid;border-color:#c9c9c9;border-color:var(--var-color-control-neutral, #c9c9c9);border-radius:50%;line-height:32px;box-sizing:border-box}.color-picker.compact .color-preview{width:26px;height:26px;line-height:26px}.color-picker:hover .color-preview,.color-picker:focus .color-preview{border-color:#26a69a;border-color:var(--var-color-control-accent-hover, #26a69a)}.color-picker:active .color-preview{border-color:#00897b;border-color:var(--var-color-control-accent-active, #00897b)}.color-value{text-transform:uppercase}.color-picker-popup{display:flex;position:absolute;top:0;left:0;flex-flow:column nowrap;min-width:275px;min-height:300px;text-align:left;white-space:nowrap;z-index:100}.color-picker-popup .picker .cursor{position:absolute;transform:translate(-50%, -50%);border:2px solid #fff;cursor:pointer}.color-picker-popup .value-saturation-picker{flex:1;min-height:180px}.color-picker-popup .value-saturation-picker .color-filter{position:absolute;top:0;left:0;width:100%;height:100%}.color-picker-popup .value-saturation-picker .cursor{top:0;left:0;width:16px;height:16px;border-radius:50%}.color-picker-popup .hue-picker{height:28px}.color-picker-popup .hue-picker .hue-bar{position:absolute;top:calc(50% - 5px);left:0;width:100%;height:10px;border-radius:5px;background:linear-gradient(to right, hsl(0, 100%, 50%), hsl(60, 100%, 50%), hsl(120, 100%, 50%), hsl(180, 100%, 50%), hsl(240, 100%, 50%), hsl(300, 100%, 50%), hsl(0, 100%, 50%))}.color-picker-popup .hue-picker .cursor{top:50%;left:0;width:10px;height:28px;border-radius:6px}.color-picker-popup .preview-block{display:flex;flex-flow:row nowrap}.color-picker-popup .preview-block .preview-color{flex:0 0 50px;width:50px;min-height:50px;background:green}.color-picker-popup .preview-block tr{height:28px}.color-picker-popup .preview-block input[type=text]{margin:0 0 0 4px;padding:3px 2px;border-width:1px;border-style:solid;border-radius:4px;background:none;color:inherit;font-size:inherit;border-color:#c9c9c9;border-color:var(--var-color-control-neutral, #c9c9c9)}.color-picker-popup .preview-block input[type=text]:invalid{border-color:red;outline:red solid}.color-picker-popup .outlined{border-width:1px;border-style:solid;border-color:#c9c9c9;border-color:var(--var-color-control-neutral, #c9c9c9);border-radius:4px}.popup{padding:7px;background:#fff;background:var(--var-color-theme, white);border:1px solid #c9c9c9;border:var(--var-color-block-border, 1px solid #c9c9c9);border-radius:8px;box-shadow:0 0 10px rgba(50,50,50,.6)}.popup .block{position:relative;margin:7px}
.file-control{position:relative}.file-control>input.file-input{position:absolute;top:0;left:0;width:1px;height:1px;opacity:0}.file-control>.file-control-button{display:inline-block;position:relative;padding:6px 12px 6px 2em;border-width:2px;border-style:solid;border-radius:4px;font-size:87.5%;font-weight:bold;cursor:pointer;box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box}.file-control>.file-control-button>svg{position:absolute;top:0;left:.2em;width:1.5em;height:100%}.file-control.compact>.file-control-button{padding:4px 12px 4px 2em;font-size:75%}.file-control>input.file-input+.file-control-button{border-color:#009688;border-color:var(--var-color-control-accent, #009688);color:#009688;color:var(--var-color-control-accent, #009688)}.file-control>input.file-input+.file-control-button>svg{fill:#009688;fill:var(--var-color-control-accent, #009688)}.file-control>input.file-input:focus+.file-control-button,.file-control>input.file-input:hover:not(:disabled)+.file-control-button{border-color:#26a69a;border-color:var(--var-color-control-accent-hover, #26a69a);color:#26a69a;color:var(--var-color-control-accent-hover, #26a69a)}.file-control>input.file-input:focus+.file-control-button>svg,.file-control>input.file-input:hover:not(:disabled)+.file-control-button>svg{fill:#26a69a;fill:var(--var-color-control-accent-hover, #26a69a)}.file-control>input.file-input:active:not(:disabled)+.file-control-button{border-color:#00897b;border-color:var(--var-color-control-accent-active, #00897b);color:#00897b;color:var(--var-color-control-accent-active, #00897b);background:rgba(0,150,136,.1)}.file-control>input.file-input:active:not(:disabled)+.file-control-button>svg{fill:#00897b;fill:var(--var-color-control-accent-active, #00897b)}.file-control>input.file-input:disabled+.file-control-button{border-color:#a5a5a5;color:#a5a5a5}.file-control>input.file-input:disabled+.file-control-button>svg{fill:#a5a5a5}
:root{--var-color-theme:white;--var-color-page-background:#ededed;--var-page-background-image:url("../images/noise-light.png");--var-color-block-background:#eeeeee;--var-color-block-border:1px solid #c9c9c9;--var-color-title:#535353;--var-color-text:#676767;--var-color-block-actionitem:#5e5e5e;--var-color-block-actionitem-hover:#7e7e7e;--var-color-block-actionitem-active:#535353;--var-color-scrollbar:#a5a5a5;--var-color-scrollbar-hover:#b2b2b2;--var-color-scrollbar-active:#959595;--var-color-control-neutral:#c9c9c9;--var-color-control-accent:#009688;--var-color-control-accent-hover:#26a69a;--var-color-control-accent-active:#00897b}@media(prefers-color-scheme: dark){:root{--var-color-theme:black;--var-color-page-background:#232323;--var-page-background-image:url("../images/noise-dark.png");--var-color-block-background:#202020;--var-color-block-border:1px solid #535353;--var-color-title:#eeeeee;--var-color-text:#dbdbdb;--var-color-block-actionitem:#dbdbdb;--var-color-block-actionitem-hover:#eeeeee;--var-color-block-actionitem-active:#c9c9c9;--var-color-scrollbar:#7e7e7e;--var-color-scrollbar-hover:#959595;--var-color-scrollbar-active:#676767;--var-color-control-neutral:#5e5e5e;--var-color-control-accent:#26a69a;--var-color-control-accent-hover:#4db6ac;--var-color-control-accent-active:#009688}}:root{color-scheme:light dark}html{display:flex;min-height:100%;font-family:Arial,Helvetica,sans-serif}body{display:flex;flex:1;flex-direction:column;min-height:100vh;margin:0px;background-attachment:fixed;background:#ededed;background:var(--var-color-page-background, #ededed);background-image:url("../images/noise-light.png");background-image:var(--var-page-background-image, url("../images/noise-light.png"));color:#676767;color:var(--var-color-text, #676767)}main{display:block;flex-grow:1;padding-bottom:32px}h1,h2,h3{color:#535353;color:var(--var-color-title, #535353)}
.badge{width:32px;height:32px;margin:8px 12px;border:none}.badge>svg{width:32px;height:32px}.badge,.badge:hover,.badge:focus,.badge:active{border:none}.badge svg{fill:#5e5e5e;fill:var(--var-color-block-actionitem, #5e5e5e)}.badge svg:focus,.badge svg:hover{fill:#7e7e7e;fill:var(--var-color-block-actionitem-hover, #7e7e7e)}.badge svg:active{fill:#535353;fill:var(--var-color-block-actionitem-active, #535353)}.badge-shelf{display:flex;flex-flow:row;justify-content:center}footer{align-items:center;padding:8px;text-align:center;border-top:1px solid #c9c9c9;border-top:var(--var-color-block-border, 1px solid #c9c9c9);background:#eeeeee;background:var(--var-color-block-background, #eeeeee)}



================================================
FILE: docs/readme/index.html
================================================
<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="description" content="Readme page of my project 'Particles'. WebGPU implementation of particles in a gravity field" />
    <title>Particles - Explanations</title>

    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="icon" type="image/png" href="favicon-16x16.png" sizes="16x16">
    <link rel="icon" type="image/png" href="favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="favicon-96x96.png" sizes="96x96">
    <link rel="stylesheet" type="text/css" href="css/page.css?v=2023-06-11T16%3A10%3A52.218Z">
  </head>

  <body>
    <header>
      <a class="logo logo-animate-fill" href="https://piellardj.github.io/particles-webgpu/" id="seep-live-button" title="Live project" aria-label="Live project">
        <svg class="logo-icon" xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 64 64">
          <g stroke-width="2">
            <path fill="none" stroke-linejoin="round" d="M24,20v24L46,32z" />
        </svg>
      </a>
    </header>
    <main>
      <div class="contents">
        <h1 id="particleswebgpu">particles-webgpu</h1>
        <p>This project a basic particles simulation running fully on GPU, using the new WebGPU API. Particles evolve independently, following simple gravitational rules. There can be several attraction points at once. You can control one with your mouse by pressing the left mouse button.</p>
        <p>Chrome 94 brings experimental support for the new WebGPU API. To enable it, a flag is available in <code>chrome://flags/#enable-unsafe-webgpu</code>. If you can't find this flag, try using Chrome Canary instead.</p>
        <p>This is actually a WebGPU port of my old <a href="https://github.com/piellardj/particles-gpu">particles-gpu</a> project. The main differences are that this one uses compute shaders, and stores the particles in a GPUBuffer instead of a texture.</p>
        <p>See it live <a href="https://piellardj.github.io/particles-webgpu/?page%3Acanvas%3Afullscreen=true&page%3Acanvas%3Asidepane=true&page%3Arange%3Aparticles-count-range-id=3">here</a>.</p>
        <p><a href="https://www.paypal.com/donate/?hosted_button_id=AF7H7GEJTL95E"><img src="https://raw.githubusercontent.com/piellardj/piellardj.github.io/master/images/readme/donate-paypal.svg" alt="Donate" /></a></p>
        <h2 id="preview">Preview</h2>
        <p><img src="https://github.com/piellardj/particles-webgpu/raw/main/src/readme/01.png" alt="Illustration 1" /></p>
        <p><img src="https://github.com/piellardj/particles-webgpu/raw/main/src/readme/02.png" alt="Illustration 2" /></p>
        <h2 id="notes">Notes</h2>
        <p>This is my first WebGPU project, so I probably made a few mistakes. Also, I am discovering behaviours that surprise me. Here is a documentation of most of them. I guess what follows is obvious to someone familiar modern APIs such as Vulkan (or even late OpenGL).</p>
        <h3 id="expliciterrors">Explicit errors</h3>
        <p>The first thing I noted is that the browser seems to perform tons of validity checks for each instruction, which makes debugging way easier than WebGL. Moreover, the messages clearly specify which validity check failed, why these checks were performed, etc.</p>
        <h3 id="varandlet"><code>var</code> and <code>let</code></h3>
        <p>Keywords <code>var</code> and <code>let</code> don't mean the same thing than in Javascript. In WGSL, <code>var</code> declares an object that can vary, while <code>let</code> declares an immutable object
          <a href="https://www.w3.org/TR/WGSL/#var-and-let">Specification here</a>.
        </p>
        <h3 id="alignmentofstruct">Alignment of <code>struct</code></h3>
        <p>I encountered a unexpected behaviour in a shader with a <code>struct</code> I used to describe a uniform buffer.</p>
        <h4 id="issue">Issue</h4>
        <p>Here is how I described it in the shader (wgsl):</p>
        <pre><code class="glsl language-glsl">struct Uniforms {
    singleFloat: f32;
    vecFloat: vec2&lt;f32&gt;;
};
@group(0) @binding(0) var&lt;uniform&gt; uniforms: Uniforms;
</code></pre>
        <p>and here is how I first created it and included it (javascript):</p>
        <pre><code class="javascript language-javascript">const gpuBuffer = device.createBuffer({
    size: Float32Array.BYTES_PER_ELEMENT * (1 + 2), // one f32 and one vec2&lt;f32&gt;
    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
    mappedAtCreation: false,
});
device.createBindGroup({
    layout: pipeline.getBindGroupLayout(0),
    entries: [{
        binding: 0,
        resource: { buffer: gpuBuffer }
    }]
});
</code></pre>
        <p>To my surprise, Chrome outputed the following error:</p>
        <pre><code>Binding size (12) is smaller than the minimum binding size (16).
 - While validating entries[0] as a Buffer
 - While validating [BindGroupDescriptor] against [BindGroupLayout]
 - While calling [Device].CreateBindGroup([BindGroupDescriptor]).
</code></pre>
        <p>In an attempt of fixing it, I naively complied and padding the buffer to make its size 16 bytes. It "fixed" this specific issue but things still didn't behave as I expected.</p>
        <pre><code class="javascript language-javascript">// creation
const gpuBuffer = device.createBuffer({
    size: Float32Array.BYTES_PER_ELEMENT * (1 + 2 + 1), // one f32 and one vec2&lt;f32&gt; and one padding float
    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
    mappedAtCreation: false,
});
// ... add it to a bindgroup ;.. //

// writing
const a = ..., b = ..., c = ...;
const floatBuffer = new Float32Array([a, b, c]);
const buffer = floatBuffer.buffer;
device.queue.writeBuffer(this.renderpassUniformsBuffer, 0, buffer);

// ... bind the bindgroup to a renderpass ... //
</code></pre>
        <p>During the shader execution, I expected to have:</p>
        <pre><code class="glsl language-glsl">(uniforms.singleFloat == a) &amp;&amp; (uniforms.vecFloat == vec2&lt;f32&gt;(b, c))
</code></pre>
        <p>but instead got:</p>
        <pre><code class="glsl language-glsl">(uniforms.singleFloat == a) &amp;&amp; (uniforms.vecFloat == vec2&lt;f32&gt;(c, 0.0))
</code></pre>
        <h4 id="causeandfix">Cause and fix</h4>
        <p>This issue came from alignment of types in WGSL. This behaviour is described in the <a href="https://www.w3.org/TR/WGSL/#structure-layout-rules">Structure Layout Rules</a> and <a href="https://www.w3.org/TR/WGSL/#alignof">Alignment and Size</a> sections of the WGSL spec.</p>
        <p>Each type has their own alignment requirements. In this case, the relevant info is: <code>AlignOf(f32) == 4</code> and <code>AlignOf(vec2&lt;f32&gt;) == 8</code>. This means that when I write:</p>
        <pre><code class="glsl language-glsl">struct Uniforms {
    singleFloat: f32;
    vecFloat: vec2&lt;f32&gt;;
};
</code></pre>
        <p>because of the 8-bytes alignment of <code>vec2&lt;f32&gt;</code>, it is actually translated as:</p>
        <pre><code class="glsl language-glsl">struct Uniforms {
    singleFloat: f32;
    unusablePaddingFloat: f32;
    vecFloat: vec2&lt;f32&gt;;
};
</code></pre>
        <p>This explains why</p>
        <ul>
          <li>Chrome was requesting a minimum binding size of 16</li>
          <li>and when using the buffer <code>[a, b, c, 0]</code> as my uniform buffer, <code>uniforms.vecFloat</code> was filled with <code>(c,0)</code> instead of <code>(b,c)</code>.</li>
        </ul>
        <p>Since <code>f32</code> are 4-bytes aligned and I don't care about the alignment/stride of the <code>struct</code> itself, the fix I used is surprisingly simple: switch my two properties:</p>
        <pre><code class="glsl language-glsl">struct Uniforms {
    vecFloat: vec2&lt;f32&gt;;
    singleFloat: f32;
};
</code></pre>
        <p>It is worth noting that one can explicit alignment and stride of each property with by decorating them with the WGSL attributes <code>@align(X)</code> and <code>@stride(Y)</code>.</p>
        <h3 id="usageoffloat16">Usage of Float16</h3>
        <h4 id="float16inwgsl">Float16 in WGSL</h4>
        <p>I was surprised to see that according to the <a href="https://www.w3.org/TR/WGSL/#floating-point-evaluation">Floating Point Evaluation</a> section of the spec, WebGPU uses Float32 precision for shader computations (and 32-bits types in general). What a difference with WebGL where some devices only supported <code>lowp</code> !</p>
        <p>According to the <a href="https://www.w3.org/TR/WGSL/#plain-types-section">Plain types</a> section of the WGSL spec, the base types are <code>bool</code>, <code>u32</code>, <code>i32</code>, <code>f32</code> but there is no <code>f16</code>.</p>
        <p>For my computations, storing the positions and velocities as Float16 would be enough. However since I store them in buffers, I have to use Float32, so each particle takes 16 bytes (one <code>vec2&lt;f32&gt;</code> for position, one <code>vec2&lt;f32&gt;</code> for velocity), which is a lot.
          One way to use Float16 for storage would be to use a <a href="https://www.w3.org/TR/webgpu/#plain-color-formats"><code>rgba16float</code></a> texture and manipulating it texel by texel with <a href="https://www.w3.org/TR/WGSL/#textureload"><code>textureLoad</code></a> and <a href="https://www.w3.org/TR/WGSL/#texturestore"><code>textureStore</code></a>.</p>
        <h4 id="float16injavascript">Float16 in Javascript</h4>
        <p>One issue I would have if I used a <code>rgba16float</code> texture for storing the position/velocity in a texel would be to initialize this texture. One way to fill a texture is to use the <code>GPUDevice.GPUQueue.writeTexture</code> method, by passing it an <code>ArrayBuffer</code>. However, sadly in Javascript there is no TypedArray for Float16: there are amongst others <code>Uint8Array</code>, <code>Uint16Array</code>, <code>Uint32Array</code>, <code>BigUint64Array</code>, <code>Float32Array</code> and <code>Float64Array</code> however there is no <code>Float16Array</code>. I don't know why this type is lacking but I feel like it would be useful. To avoid this issue, I would have either</p>
        <ul>
          <li>to craft on CPU-side Float16 with bit manipulations</li>
          <li>or to initialize the texture on the GPU. Initial positions are random and having nice random in shaders is a bit tricky. WGSL support bit operations on ui32, so I suppose a simple PCG random number generator could be implemented in a compute shader (maybe by using built-ins such as <code>GlobalInvocationId</code> as part of the seed ?).</li>
        </ul>
        <h3 id="datapacking">Data packing</h3>
        <p>WebGPU offers nice data packing builtin functions (<a href="https://www.w3.org/TR/WGSL/#pack-builtin-functions">see spec here</a>) such as <code>pack4x8unorm</code> and <code>unpack4x8unorm</code>, which allow compact packing of <code>vec4&lt;f32&gt;</code> into <code>u32</code> (useful for storing colors for instance).</p>
      </div>
    </main>

    <footer>
      <div class="badge-shelf">
        <a class="badge" href="mailto:jeremie.piellard@gmail.com" title="Email">
          <svg xmlns="http://www.w3.org/2000/svg" width="32px" height="32px" viewBox="0 0 512 512">
            <path d="M512 85V448H0V85l256 224L512 85zM488 64H24L256 267 488 64z" />
          </svg>
        </a>

        <a class="badge" href="https://github.com/piellardj" title="GitHub">
          <svg xmlns="http://www.w3.org/2000/svg" width="32px" height="32px" viewBox="0 0 1024 1024">
            <path d="M512 0C229 0 0 229 0 512c0 226 147 418 350 486 26 5 35-11 35-25 0-12 0-53-1-95C242 909 212 818 212 818c-23-59-57-75-57-75-47-32 4-31 4-31 51 4 78 53 78 53 46 78 120 56 149 43 5-33 18-56 33-68C305 725 185 682 185 485c0-56 20-102 53-137-5-13-23-65 5-136 0 0 43-14 141 53 41-11 85-17 128-17 44 0 87 6 128 17 98-66 141-52 141-52 28 71 10 123 5 136 33 36 53 81 53 137 0 197-120 240-234 253 18 16 35 47 35 95 0 68-1 124-1 141 0 14 9 30 35 25C877 930 1024 738 1024 512 1024 229 795 0 512 0z" />
          </svg>
        </a>

        <a class="badge" href="https://www.linkedin.com/in/jeremie-piellard/" title="LinkedIn">
          <svg xmlns="http://www.w3.org/2000/svg" width="32px" height="32px" viewBox="0 0 512 512">
            <path d="M30 177l93-1v304l-93 1v-304z" />
            <path d="M200 177l89-1v39l0 11c26-26 53-45 97-45 51 0 100 21 100 91v208l-90 1v-159c0-35-9-58-51-58-37 0-52 7-52 55v160l-92 1v-304z" />
            <path d="M128 81c0 28-23 51-51 51s-51-23-51-51c0-28 23-51 51-51 28 0 51 23 51 51z" />
          </svg>
        </a>
      </div>
    </footer>
  </body>

</html>


================================================
FILE: docs/readme/css/page.css
================================================
a{color:#009688;color:var(--var-color-control-accent, #009688);font-weight:bold;text-decoration:none;box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;border-width:0 0 2px;border-style:solid;border-color:rgba(0,0,0,0)}a:focus,a:hover{border-color:#009688;border-color:var(--var-color-control-accent, #009688)}:root{--color-code: #e0e0e0}@media(prefers-color-scheme: dark){:root{--color-code: #343434}}body{max-width:100%}.contents{line-height:1.5em;max-width:900px;margin:auto;padding:16px 32px;border-radius:8px;border:1px solid #c9c9c9;border:var(--var-color-block-border, 1px solid #c9c9c9);background:#eeeeee;background:var(--var-color-block-background, #eeeeee)}h1{text-align:center;margin-bottom:1em}pre{overflow-x:auto;background:var(--color-code);padding:4px 16px;border-radius:8px;line-height:1.45}pre::-webkit-scrollbar{width:16px}pre::-webkit-scrollbar-track{background-color:rgba(0,0,0,0)}pre::-webkit-scrollbar-thumb{border-width:6px;border-style:solid;border-radius:8px;border-color:var(--color-code);background-color:#a5a5a5;background-color:var(--var-color-scrollbar, #a5a5a5)}pre::-webkit-scrollbar-thumb:focus,pre::-webkit-scrollbar-thumb:hover{background-color:#b2b2b2;background-color:var(--var-color-scrollbar-hover, #b2b2b2)}pre::-webkit-scrollbar-thumb:active{background-color:#959595;background-color:var(--var-color-scrollbar-active, #959595)}pre:hover::-webkit-scrollbar-thumb{border-width:5px}pre code{padding:0}code{background:var(--color-code);padding:2px 4px;border-radius:3px;font-family:ui-monospace,SFMono-Regular,SF Mono,Menlo,Consolas,Liberation Mono,monospace;line-height:1.5em}video,img{max-width:100%;border-radius:8px}
.logo{display:block;position:relative;width:64px;height:64px;margin:8px auto 16px;border-radius:50%;user-select:none;box-sizing:border-box}.logo,.logo:hover,.logo:focus,.logo:active{border-width:1px;border-style:solid;border-color:#009688;border-color:var(--var-color-control-accent, #009688)}.logo::before,.logo svg.logo-icon,.logo::after{position:absolute;top:-1px;left:-1px;width:64px;height:64px;border-radius:50%;pointer-events:none}.logo svg.logo-icon{stroke:#009688;stroke:var(--var-color-control-accent, #009688);fill:#009688;fill:var(--var-color-control-accent, #009688)}.logo::before{content:"";transform:scale(0);-webkit-transform:scale(0);-ms-transform:scale(0);transition:.1s ease;-webkit-transition:.1s ease}.logo.logo-animate-fill .logo::before{content:"";transform:scale(0);-webkit-transform:scale(0);-ms-transform:scale(0);transition:.1s ease;-webkit-transition:.1s ease}.logo:hover::before{transform:scale(1);-webkit-transform:scale(1);-ms-transform:scale(1)}.logo.logo-animate-fill{background:#eeeeee;background:var(--var-color-block-background, #eeeeee)}.logo.logo-animate-fill::before{background:#009688;background:var(--var-color-control-accent, #009688)}.logo.logo-animate-fill:hover svg.logo-icon{fill:#fff;stroke:#fff}.logo.logo-animate-empty{background:#009688;background:var(--var-color-control-accent, #009688)}.logo.logo-animate-empty::before{top:0;left:0;width:62px;height:62px;background:#eeeeee;background:var(--var-color-block-background, #eeeeee)}
:root{--var-color-theme:white;--var-color-page-background:#ededed;--var-page-background-image:url("../images/noise-light.png");--var-color-block-background:#eeeeee;--var-color-block-border:1px solid #c9c9c9;--var-color-title:#535353;--var-color-text:#676767;--var-color-block-actionitem:#5e5e5e;--var-color-block-actionitem-hover:#7e7e7e;--var-color-block-actionitem-active:#535353;--var-color-scrollbar:#a5a5a5;--var-color-scrollbar-hover:#b2b2b2;--var-color-scrollbar-active:#959595;--var-color-control-neutral:#c9c9c9;--var-color-control-accent:#009688;--var-color-control-accent-hover:#26a69a;--var-color-control-accent-active:#00897b}@media(prefers-color-scheme: dark){:root{--var-color-theme:black;--var-color-page-background:#232323;--var-page-background-image:url("../images/noise-dark.png");--var-color-block-background:#202020;--var-color-block-border:1px solid #535353;--var-color-title:#eeeeee;--var-color-text:#dbdbdb;--var-color-block-actionitem:#dbdbdb;--var-color-block-actionitem-hover:#eeeeee;--var-color-block-actionitem-active:#c9c9c9;--var-color-scrollbar:#7e7e7e;--var-color-scrollbar-hover:#959595;--var-color-scrollbar-active:#676767;--var-color-control-neutral:#5e5e5e;--var-color-control-accent:#26a69a;--var-color-control-accent-hover:#4db6ac;--var-color-control-accent-active:#009688}}:root{color-scheme:light dark}html{display:flex;min-height:100%;font-family:Arial,Helvetica,sans-serif}body{display:flex;flex:1;flex-direction:column;min-height:100vh;margin:0px;background-attachment:fixed;background:#ededed;background:var(--var-color-page-background, #ededed);background-image:url("../images/noise-light.png");background-image:var(--var-page-background-image, url("../images/noise-light.png"));color:#676767;color:var(--var-color-text, #676767)}main{display:block;flex-grow:1;padding-bottom:32px}h1,h2,h3{color:#535353;color:var(--var-color-title, #535353)}
.badge{width:32px;height:32px;margin:8px 12px;border:none}.badge>svg{width:32px;height:32px}.badge,.badge:hover,.badge:focus,.badge:active{border:none}.badge svg{fill:#5e5e5e;fill:var(--var-color-block-actionitem, #5e5e5e)}.badge svg:focus,.badge svg:hover{fill:#7e7e7e;fill:var(--var-color-block-actionitem-hover, #7e7e7e)}.badge svg:active{fill:#535353;fill:var(--var-color-block-actionitem-active, #535353)}.badge-shelf{display:flex;flex-flow:row;justify-content:center}footer{align-items:center;padding:8px;text-align:center;border-top:1px solid #c9c9c9;border-top:var(--var-color-block-border, 1px solid #c9c9c9);background:#eeeeee;background:var(--var-color-block-background, #eeeeee)}



================================================
FILE: docs/script/main.js
================================================
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/ts/attractors.ts":
/*!******************************!*\
  !*** ./src/ts/attractors.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.update = exports.setContainer = exports.setOverlays = exports.getPreset = void 0;
const parameters_1 = __webpack_require__(/*! ./parameters */ "./src/ts/parameters.ts");
let time = 0;
let container;
const className = "attractor-overlay";
function setContainer(element) {
    container = element;
}
exports.setContainer = setContainer;
function setOverlays(attractors) {
    if (!container) {
        throw new Error("A container is needed for overlays.");
    }
    if (!parameters_1.Parameters.displayAttractors) {
        const elements = Array.from(container.querySelectorAll(`.${className}`));
        for (const element of elements) {
            const parentElement = element.parentElement;
            if (parentElement) {
                parentElement.removeChild(element);
            }
        }
        return;
    }
    const elements = Array.from(container.querySelectorAll(`.${className}`));
    while (elements.length > attractors.length) {
        const lastElement = elements.pop();
        const parentElement = lastElement.parentElement;
        if (parentElement) {
            parentElement.removeChild(lastElement);
        }
    }
    while (elements.length < attractors.length) {
        const newElement = document.createElement("span");
        newElement.className = className;
        container.appendChild(newElement);
        elements.push(newElement);
    }
    for (let i = 0; i < elements.length; i++) {
        const element = elements[i];
        const attractor = attractors[i];
        const x = 100 * (0.5 + 0.5 * attractor.position[0]);
        const y = 100 * (0.5 + 0.5 * attractor.position[1]);
        element.style.left = `${x.toFixed(2)}%`;
        element.style.top = `${y.toFixed(2)}%`;
    }
}
exports.setOverlays = setOverlays;
function getPreset() {
    const attractorsList = [];
    /* eslint indent: "off" */
    const preset = parameters_1.Parameters.attractorsPreset;
    switch (preset) {
        case parameters_1.AttractorsPreset.ORBIT:
            {
                attractorsList.push({
                    force: 7,
                    position: [0, 0],
                });
                attractorsList.push({
                    force: 5,
                    position: [0.4 * Math.cos(time), 0.4 * Math.sin(time)],
                });
                attractorsList.push({
                    force: 6,
                    position: [0.8 * Math.cos(-0.9 * time), 0.8 * Math.sin(-0.9 * time)],
                });
                break;
            }
        case parameters_1.AttractorsPreset.SINES:
            {
                attractorsList.push({
                    force: 7,
                    position: [0.7 * Math.cos(time), 0.7 * Math.sin(2 * time)],
                });
                attractorsList.push({
                    force: 7,
                    position: [0.7 * Math.cos(1.8 * (time + 0.5)), 0.7 * Math.sin(0.9 * (time + 0.5))],
                });
                break;
            }
        case parameters_1.AttractorsPreset.CENTRAL_ATTRACTIVE:
            {
                attractorsList.push({
                    force: 5,
                    position: [0, 0],
                });
                break;
            }
        case parameters_1.AttractorsPreset.CENTRAL_REPULSIVE:
            {
                attractorsList.push({
                    force: -5,
                    position: [0, 0],
                });
                break;
            }
        default:
            break;
    }
    const containerBox = container.getBoundingClientRect();
    const aspectRatio = containerBox.width / containerBox.height;
    for (const attractor of attractorsList) {
        attractor.position[0] /= aspectRatio;
    }
    return attractorsList;
}
exports.getPreset = getPreset;
function update(dt) {
    time += dt;
}
exports.update = update;


/***/ }),

/***/ "./src/ts/engine.ts":
/*!**************************!*\
  !*** ./src/ts/engine.ts ***!
  \**************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/// <reference types="./page-interface-generated" />
/// <reference types="./webgpu-utils/wgsl-type" />
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Engine = void 0;
const initialize_colors_wgsl_1 = __importDefault(__webpack_require__(/*! ../shaders/initialize-colors.wgsl */ "./src/shaders/initialize-colors.wgsl"));
const update_wgsl_1 = __importDefault(__webpack_require__(/*! ../shaders/update.wgsl */ "./src/shaders/update.wgsl"));
const color_part_wgsl_1 = __importDefault(__webpack_require__(/*! ../shaders/utils/color.part.wgsl */ "./src/shaders/utils/color.part.wgsl"));
const Attractors = __importStar(__webpack_require__(/*! ./attractors */ "./src/ts/attractors.ts"));
const helpers_1 = __webpack_require__(/*! ./helpers */ "./src/ts/helpers.ts");
const parameters_1 = __webpack_require__(/*! ./parameters */ "./src/ts/parameters.ts");
const renderer_instanced_monocolor_1 = __webpack_require__(/*! ./render/renderer-instanced-monocolor */ "./src/ts/render/renderer-instanced-monocolor.ts");
const renderer_instanced_monocolor_high_quality_1 = __webpack_require__(/*! ./render/renderer-instanced-monocolor-high-quality */ "./src/ts/render/renderer-instanced-monocolor-high-quality.ts");
const renderer_instanced_multicolor_1 = __webpack_require__(/*! ./render/renderer-instanced-multicolor */ "./src/ts/render/renderer-instanced-multicolor.ts");
const renderer_instanced_multicolor_velocity_1 = __webpack_require__(/*! ./render/renderer-instanced-multicolor-velocity */ "./src/ts/render/renderer-instanced-multicolor-velocity.ts");
const renderer_monocolor_1 = __webpack_require__(/*! ./render/renderer-monocolor */ "./src/ts/render/renderer-monocolor.ts");
const renderer_monocolor_high_quality_1 = __webpack_require__(/*! ./render/renderer-monocolor-high-quality */ "./src/ts/render/renderer-monocolor-high-quality.ts");
const renderer_multicolor_1 = __webpack_require__(/*! ./render/renderer-multicolor */ "./src/ts/render/renderer-multicolor.ts");
const renderer_multicolor_velocity_1 = __webpack_require__(/*! ./render/renderer-multicolor-velocity */ "./src/ts/render/renderer-multicolor-velocity.ts");
const WebGPU = __importStar(__webpack_require__(/*! ./webgpu-utils/webgpu-device */ "./src/ts/webgpu-utils/webgpu-device.ts"));
const MAX_ATTRACTORS = 4;
class Engine {
    constructor(targetTextureFormat) {
        this.particleBatches = [];
        this.rendererMonocolor = new renderer_monocolor_1.RendererMonocolor(targetTextureFormat);
        this.rendererMonocolorHighQuality = new renderer_monocolor_high_quality_1.RendererMonocolorHighQuality(targetTextureFormat);
        this.rendererMulticolor = new renderer_multicolor_1.RendererMulticolor(targetTextureFormat);
        this.rendererMulticolorVelocity = new renderer_multicolor_velocity_1.RendererMulticolorVelocity(targetTextureFormat);
        this.rendererInstancedMonocolor = new renderer_instanced_monocolor_1.RendererInstancedMonocolor(targetTextureFormat);
        this.rendererInstancedMonocolorHighQuality = new renderer_instanced_monocolor_high_quality_1.RendererInstancedMonocolorHighQuality(targetTextureFormat);
        this.rendererInstancedMulticolor = new renderer_instanced_multicolor_1.RendererInstancedMulticolor(targetTextureFormat);
        this.rendererInstancedMulticolorVelocity = new renderer_instanced_multicolor_velocity_1.RendererInstancedMulticolorVelocity(targetTextureFormat);
        this.computePipeline = WebGPU.device.createComputePipeline({
            compute: {
                module: WebGPU.device.createShaderModule({ code: update_wgsl_1.default }),
                entryPoint: "main"
            },
            layout: "auto"
        });
        this.computeUniformsBuffer = WebGPU.device.createBuffer({
            size: 96,
            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM,
        });
        this.initializeColorsComputePipeline = WebGPU.device.createComputePipeline({
            compute: {
                module: WebGPU.device.createShaderModule({ code: color_part_wgsl_1.default + initialize_colors_wgsl_1.default }),
                entryPoint: "main",
            },
            layout: "auto"
        });
    }
    get particlesCount() {
        let count = 0;
        for (const particlesBatch of this.particleBatches) {
            count += particlesBatch.particlesCount;
        }
        return count;
    }
    update(commandEncoder, dt, aspectRatio) {
        const attractors = Attractors.getPreset();
        if (Page.Canvas.isMouseDown()) {
            const attractor = {
                position: Page.Canvas.getMousePosition(),
                force: 10 * parameters_1.Parameters.attraction,
            };
            attractor.position[0] = 2 * attractor.position[0] - 1;
            attractor.position[1] = 2 * attractor.position[1] - 1;
            attractors.push(attractor);
        }
        Attractors.setOverlays(attractors);
        const uniformForce = [0, 3 * parameters_1.Parameters.gravity];
        const uniformsBufferData = this.buildComputeUniforms(dt, aspectRatio, uniformForce, attractors);
        WebGPU.device.queue.writeBuffer(this.computeUniformsBuffer, 0, uniformsBufferData);
        for (const particlesBatch of this.particleBatches) {
            const computePass = commandEncoder.beginComputePass();
            computePass.setPipeline(this.computePipeline);
            computePass.setBindGroup(0, particlesBatch.computeBindgroup);
            computePass.dispatchWorkgroups(particlesBatch.dispatchSize);
            computePass.end();
        }
    }
    draw(commandEncoder, webgpuCanvas) {
        let renderer;
        const instanced = (parameters_1.Parameters.spriteSize > 1);
        if (parameters_1.Parameters.colorMode === parameters_1.ColorMode.UNICOLOR) {
            if (parameters_1.Parameters.highColorQuality) {
                if (instanced) {
                    renderer = this.rendererInstancedMonocolorHighQuality;
                }
                else {
                    renderer = this.rendererMonocolorHighQuality;
                }
            }
            else {
                if (instanced) {
                    renderer = this.rendererInstancedMonocolor;
                }
                else {
                    renderer = this.rendererMonocolor;
                }
            }
        }
        else if (parameters_1.Parameters.colorSource === parameters_1.ColorSource.IMAGE) {
            if (instanced) {
                renderer = this.rendererInstancedMulticolor;
            }
            else {
                renderer = this.rendererMulticolor;
            }
        }
        else {
            if (instanced) {
                renderer = this.rendererInstancedMulticolorVelocity;
            }
            else {
                renderer = this.rendererMulticolorVelocity;
            }
        }
        renderer.particleColor = parameters_1.Parameters.particleColor;
        renderer.particleOpacity = parameters_1.Parameters.opacity;
        renderer.enableAdditiveBlending = parameters_1.Parameters.blending;
        renderer.spriteSize = parameters_1.Parameters.spriteSize;
        renderer.draw(commandEncoder, webgpuCanvas, this.particleBatches);
    }
    reset(wantedParticlesCount) {
        for (const particlesBatch of this.particleBatches) {
            if (particlesBatch.gpuBuffer) {
                particlesBatch.gpuBuffer.destroy();
            }
            if (particlesBatch.colorsBuffer) {
                particlesBatch.colorsBuffer.destroy();
            }
        }
        this.particleBatches.length = 0;
        let totalGpuBufferSize = 0, totalColorBufferSize = 0;
        const particleSize = Float32Array.BYTES_PER_ELEMENT * (2 + 2);
        const maxDispatchSize = Math.floor(WebGPU.device.limits.maxStorageBufferBindingSize / particleSize / Engine.WORKGROUP_SIZE);
        let particlesLeftToAllocate = wantedParticlesCount;
        while (particlesLeftToAllocate > 0) {
            const idealDispatchSize = Math.ceil(particlesLeftToAllocate / Engine.WORKGROUP_SIZE);
            const dispatchSize = Math.min(idealDispatchSize, maxDispatchSize);
            const particlesCount = dispatchSize * Engine.WORKGROUP_SIZE;
            particlesLeftToAllocate -= particlesCount;
            const gpuBufferSize = particlesCount * particleSize;
            const gpuBuffer = WebGPU.device.createBuffer({
                size: gpuBufferSize,
                usage: GPUBufferUsage.VERTEX | GPUBufferUsage.STORAGE,
                mappedAtCreation: true,
            });
            totalGpuBufferSize += gpuBufferSize;
            const colorsBufferSize = particlesCount * Uint32Array.BYTES_PER_ELEMENT;
            const colorsGpuBuffer = WebGPU.device.createBuffer({
                size: colorsBufferSize,
                usage: GPUBufferUsage.VERTEX | GPUBufferUsage.STORAGE,
                mappedAtCreation: false,
            });
            totalColorBufferSize += colorsBufferSize;
            const gpuBufferData = gpuBuffer.getMappedRange();
            const particlesBuffer = new Float32Array(gpuBufferData);
            for (let iParticle = 0; iParticle < particlesCount; iParticle++) {
                particlesBuffer[4 * iParticle + 0] = Math.random() * 2 - 1;
                particlesBuffer[4 * iParticle + 1] = Math.random() * 2 - 1;
                particlesBuffer[4 * iParticle + 2] = 0;
                particlesBuffer[4 * iParticle + 3] = 0;
            }
            gpuBuffer.unmap();
            const computeBindgroup = WebGPU.device.createBindGroup({
                layout: this.computePipeline.getBindGroupLayout(0),
                entries: [
                    {
                        binding: 0,
                        resource: {
                            buffer: gpuBuffer
                        }
                    },
                    {
                        binding: 1,
                        resource: {
                            buffer: this.computeUniformsBuffer
                        }
                    }
                ]
            });
            const initializeColorsComputeBindgroup = WebGPU.device.createBindGroup({
                layout: this.initializeColorsComputePipeline.getBindGroupLayout(0),
                entries: [
                    {
                        binding: 0,
                        resource: {
                            buffer: gpuBuffer
                        }
                    },
                    {
                        binding: 1,
                        resource: {
                            buffer: colorsGpuBuffer
                        }
                    }
                ]
            });
            this.particleBatches.push({
                gpuBuffer,
                computeBindgroup,
                colorsBuffer: colorsGpuBuffer,
                initializeColorsComputeBindgroup,
                particlesCount,
                dispatchSize,
            });
        }
        console.info(`GPU memory used:\n  - positions/velocities: ${(0, helpers_1.bytesToString)(totalGpuBufferSize)}\n  - colors: ${(0, helpers_1.bytesToString)(totalColorBufferSize)}`);
    }
    initializeColors(commandEncoder, sampler, texture) {
        const textureBindgroup = WebGPU.device.createBindGroup({
            layout: this.initializeColorsComputePipeline.getBindGroupLayout(1),
            entries: [
                {
                    binding: 0,
                    resource: sampler
                },
                {
                    binding: 1,
                    resource: texture.createView()
                }
            ]
        });
        for (const particlesBatch of this.particleBatches) {
            const computePass = commandEncoder.beginComputePass();
            computePass.setPipeline(this.initializeColorsComputePipeline);
            computePass.setBindGroup(0, particlesBatch.initializeColorsComputeBindgroup);
            computePass.setBindGroup(1, textureBindgroup);
            computePass.dispatchWorkgroups(particlesBatch.dispatchSize);
            computePass.end();
        }
    }
    buildComputeUniforms(dt, aspectRatio, force, attractors) {
        if (attractors.length > MAX_ATTRACTORS) {
            throw new Error(`Too many attractors (${attractors.length}, max is ${MAX_ATTRACTORS}).`);
        }
        const buffer = new ArrayBuffer(96);
        new Float32Array(buffer, 0, 2).set([force[0], force[1]]);
        new Float32Array(buffer, 8, 1).set([dt]);
        new Uint32Array(buffer, 12, 1).set([parameters_1.Parameters.bounce ? 1 : 0]);
        new Float32Array(buffer, 16, 1).set([parameters_1.Parameters.friction]);
        new Float32Array(buffer, 20, 1).set([aspectRatio]);
        new Uint32Array(buffer, 24, 1).set([attractors.length]);
        const attractorsData = [];
        for (const attractor of attractors) {
            attractorsData.push(attractor.position[0]);
            attractorsData.push(attractor.position[1]);
            attractorsData.push(attractor.force);
            attractorsData.push(0); // padding
        }
        new Float32Array(buffer, 32, attractorsData.length).set(attractorsData);
        return buffer;
    }
}
exports.Engine = Engine;
Engine.WORKGROUP_SIZE = 256;


/***/ }),

/***/ "./src/ts/helpers.ts":
/*!***************************!*\
  !*** ./src/ts/helpers.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bytesToString = void 0;
function bytesToString(bytes) {
    let quantity;
    let unit;
    if (bytes < 1024) {
        quantity = bytes;
        unit = "B";
    }
    else if (bytes < 1024 * 1024) {
        quantity = bytes / 1024;
        unit = "KB";
    }
    else {
        quantity = bytes / 1024 / 1024;
        unit = "MB";
    }
    return Math.ceil(quantity).toLocaleString() + " " + unit;
}
exports.bytesToString = bytesToString;


/***/ }),

/***/ "./src/ts/image.ts":
/*!*************************!*\
  !*** ./src/ts/image.ts ***!
  \*************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getTexture = exports.getSampler = void 0;
const WebGPU = __importStar(__webpack_require__(/*! ./webgpu-utils/webgpu-device */ "./src/ts/webgpu-utils/webgpu-device.ts"));
let linearSampler;
let texture;
async function getTexture(path) {
    if (!texture || texture.path !== path) {
        if (texture) {
            texture.gpuTexture.destroy();
        }
        const image = document.createElement("img");
        image.src = path;
        await image.decode();
        const imageBitmap = await createImageBitmap(image);
        const gpuTexture = WebGPU.device.createTexture({
            size: [imageBitmap.width, imageBitmap.height, 1],
            format: 'rgba8unorm',
            usage: GPUTextureUsage.TEXTURE_BINDING |
                GPUTextureUsage.COPY_DST |
                GPUTextureUsage.RENDER_ATTACHMENT
        });
        WebGPU.device.queue.copyExternalImageToTexture({ source: imageBitmap }, { texture: gpuTexture }, [imageBitmap.width, imageBitmap.height]);
        texture = {
            path,
            gpuTexture
        };
    }
    return texture.gpuTexture;
}
exports.getTexture = getTexture;
function getSampler() {
    if (!linearSampler) {
        linearSampler = WebGPU.device.createSampler({
            addressModeU: "clamp-to-edge",
            addressModeV: "clamp-to-edge",
            magFilter: "linear",
            minFilter: "linear",
        });
    }
    return linearSampler;
}
exports.getSampler = getSampler;


/***/ }),

/***/ "./src/ts/main.ts":
/*!************************!*\
  !*** ./src/ts/main.ts ***!
  \************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/// <reference types="./page-interface-generated" />
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const engine_1 = __webpack_require__(/*! ./engine */ "./src/ts/engine.ts");
const Image = __importStar(__webpack_require__(/*! ./image */ "./src/ts/image.ts"));
const parameters_1 = __webpack_require__(/*! ./parameters */ "./src/ts/parameters.ts");
const webgpu_canvas_1 = __webpack_require__(/*! ./webgpu-utils/webgpu-canvas */ "./src/ts/webgpu-utils/webgpu-canvas.ts");
const WebGPU = __importStar(__webpack_require__(/*! ./webgpu-utils/webgpu-device */ "./src/ts/webgpu-utils/webgpu-device.ts"));
const Attractors = __importStar(__webpack_require__(/*! ./attractors */ "./src/ts/attractors.ts"));
async function main(canvas, canvasContainer) {
    await WebGPU.initialize();
    const device = WebGPU.device;
    const webgpuCanvas = new webgpu_canvas_1.WebGPUCanvas(canvas);
    const engine = new engine_1.Engine(webgpuCanvas.textureFormat);
    Attractors.setContainer(canvasContainer);
    let lastRun = performance.now();
    let needToReset = true;
    parameters_1.Parameters.resetObservers.push(() => { needToReset = true; });
    async function mainLoop() {
        const now = performance.now();
        const dt = parameters_1.Parameters.speed * Math.min(1 / 60, 0.001 * (now - lastRun));
        lastRun = now;
        const commandEncoder = device.createCommandEncoder();
        if (needToReset) {
            needToReset = false;
            engine.reset(parameters_1.Parameters.particlesCount);
            Page.Canvas.setIndicatorText("particles-count", engine.particlesCount.toLocaleString());
            if (parameters_1.Parameters.colorMode === parameters_1.ColorMode.MULTICOLOR) {
                const sampler = Image.getSampler();
                Page.Canvas.showLoader(true);
                const imageUrl = await parameters_1.Parameters.inputImageUrl();
                const image = await Image.getTexture(imageUrl);
                Page.Canvas.showLoader(false);
                engine.initializeColors(commandEncoder, sampler, image);
            }
        }
        webgpuCanvas.adjustSize();
        Attractors.update(dt);
        engine.update(commandEncoder, dt, webgpuCanvas.width / webgpuCanvas.height);
        engine.draw(commandEncoder, webgpuCanvas);
        device.queue.submit([commandEncoder.finish()]);
        requestAnimationFrame(mainLoop);
    }
    requestAnimationFrame(mainLoop);
}
const canvasElement = Page.Canvas.getCanvas();
const canvasContainer = Page.Canvas.getCanvasContainer();
if (!canvasElement || !canvasContainer) {
    throw new Error("Could not find canvas on page.");
}
main(canvasElement, canvasContainer);


/***/ }),

/***/ "./src/ts/parameters.ts":
/*!******************************!*\
  !*** ./src/ts/parameters.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/// <reference types="./page-interface-generated" />
/// <reference types="./webgpu-utils/image-type" />
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Parameters = exports.ColorSource = exports.ColorMode = exports.AttractorsPreset = void 0;
const ladybug_png_1 = __importDefault(__webpack_require__(/*! ../resources/ladybug.png */ "./src/resources/ladybug.png"));
const colors_png_1 = __importDefault(__webpack_require__(/*! ../resources/colors.png */ "./src/resources/colors.png"));
const controlId = {
    PARTICLES_COUNT_ID: "particles-count-range-id",
    SPEED_RANGE_ID: "speed-range-id",
    FRICTION_RANGE_ID: "friction-range-id",
    BOUNCE_CHECKBOX_ID: "bounce-checkbox-id",
    GRAVITY_RANGE_ID: "gravity-range-id",
    RESET_BUTTON_ID: "reset-button-id",
    ATTRACTION_RANGE_ID: "attraction-range-id",
    ATTRACTORS_PRESET_SELECT_ID: "attractors-preset-select-id",
    ATTRACTORS_DISPLAY_CHECKBOX_ID: "display-attractors-checkbox-id",
    COLOR_MODE_TABS_ID: "colors-mode-tabs-id",
    COLOR_AUTO_CHECKBOX_ID: "auto-color-checkbox-id",
    COLOR_HIGH_QUALITY_CHECKBOX_ID: "high-color-quality-checkbox-id",
    PARTICLE_COLORPICKER_ID: "particle-color-id",
    COLOR_SOURCE_TABS_ID: "color-source-tabs-id",
    IMAGE_SELECT_ID: "image-preset-select-id",
    IMAGE_UPLOAD_BUTTON_ID: "input-image-upload-button",
    SPRITE_SIZE_RANGE_ID: "sprite-size-range-id",
    BLENDING_CHECKBOX_ID: "blending-checkbox-id",
    OPACITY_RANGE_ID: "opacity-range-id",
    SHOW_INDICATORS_CHECKBOX_ID: "show-indicators-checkbox-id",
};
var AttractorsPreset;
(function (AttractorsPreset) {
    AttractorsPreset["NONE"] = "none";
    AttractorsPreset["ORBIT"] = "orbit";
    AttractorsPreset["SINES"] = "sines";
    AttractorsPreset["CENTRAL_ATTRACTIVE"] = "central-attractive";
    AttractorsPreset["CENTRAL_REPULSIVE"] = "central-repulsive";
})(AttractorsPreset || (exports.AttractorsPreset = AttractorsPreset = {}));
var ColorMode;
(function (ColorMode) {
    ColorMode["UNICOLOR"] = "unicolor";
    ColorMode["MULTICOLOR"] = "multicolor";
})(ColorMode || (exports.ColorMode = ColorMode = {}));
var ColorSource;
(function (ColorSource) {
    ColorSource["IMAGE"] = "image";
    ColorSource["VELOCITY"] = "velocity";
})(ColorSource || (exports.ColorSource = ColorSource = {}));
var ImagePreset;
(function (ImagePreset) {
    ImagePreset["COLORS"] = "colors";
    ImagePreset["LADYBUG"] = "ladybug";
})(ImagePreset || (ImagePreset = {}));
let customImageFile = null;
class Parameters {
    static get particlesCount() {
        return 1000000 * Page.Range.getValue(controlId.PARTICLES_COUNT_ID);
    }
    static get speed() {
        return Page.Range.getValue(controlId.SPEED_RANGE_ID);
    }
    static get friction() {
        return Page.Range.getValue(controlId.FRICTION_RANGE_ID);
    }
    static get bounce() {
        return Page.Checkbox.isChecked(controlId.BOUNCE_CHECKBOX_ID);
    }
    static get gravity() {
        return Page.Range.getValue(controlId.GRAVITY_RANGE_ID);
    }
    static get attraction() {
        return Page.Range.getValue(controlId.ATTRACTION_RANGE_ID);
    }
    static get attractorsPreset() {
        return Page.Select.getValue(controlId.ATTRACTORS_PRESET_SELECT_ID);
    }
    static get displayAttractors() {
        return Page.Checkbox.isChecked(controlId.ATTRACTORS_DISPLAY_CHECKBOX_ID);
    }
    static get colorMode() {
        return Page.Tabs.getValues(controlId.COLOR_MODE_TABS_ID)[0];
    }
    static get autoColor() {
        return Page.Checkbox.isChecked(controlId.COLOR_AUTO_CHECKBOX_ID);
    }
    static get highColorQuality() {
        return Page.Checkbox.isChecked(controlId.COLOR_HIGH_QUALITY_CHECKBOX_ID);
    }
    static get particleColor() {
        if (Parameters.autoColor) {
            const cycleLength = 60000;
            const now = (performance.now() % cycleLength) / cycleLength * 6;
            const min = 0.2;
            let r = min, g = min, b = min;
            if (now < 1) {
                r = 1;
                g = min + (1 - min) * now;
            }
            else if (now < 2) {
                r = min + (1 - min) * (2 - now);
                g = 1;
            }
            else if (now < 3) {
                g = 1;
                b = min + (1 - min) * (now - 2);
            }
            else if (now < 4) {
                g = min + (1 - min) * (4 - now);
                b = 1;
            }
            else if (now < 5) {
                r = min + (1 - min) * (now - 4);
                b = 1;
            }
            else {
                r = 1;
                b = min + (1 - min) * (6 - now);
            }
            return [r, g, b];
        }
        else {
            const color = Page.ColorPicker.getValue(controlId.PARTICLE_COLORPICKER_ID);
            return [color.r / 255, color.g / 255, color.b / 255];
        }
    }
    static get colorSource() {
        return Page.Tabs.getValues(controlId.COLOR_SOURCE_TABS_ID)[0];
    }
    static async inputImageUrl() {
        if (customImageFile) {
            return new Promise((resolve) => {
                if (customImageFile) {
                    const reader = new FileReader();
                    reader.onload = () => {
                        resolve(reader.result.toString());
                    };
                    reader.readAsDataURL(customImageFile);
                }
            });
        }
        else {
            const imagePreset = Page.Select.getValue(controlId.IMAGE_SELECT_ID);
            if (imagePreset === ImagePreset.COLORS) {
                return colors_png_1.default;
            }
            else {
                return ladybug_png_1.default;
            }
        }
    }
    static get spriteSize() {
        return Page.Range.getValue(controlId.SPRITE_SIZE_RANGE_ID);
    }
    static get blending() {
        return Page.Checkbox.isChecked(controlId.BLENDING_CHECKBOX_ID);
    }
    static get opacity() {
        return Page.Range.getValue(controlId.OPACITY_RANGE_ID);
    }
}
exports.Parameters = Parameters;
Parameters.resetObservers = [];
Parameters.speedChangeObservers = [];
Page.Range.addObserver(controlId.SPEED_RANGE_ID, () => {
    for (const observer of Parameters.speedChangeObservers) {
        observer();
    }
});
function callResetObservers() {
    for (const observer of Parameters.resetObservers) {
        observer();
    }
}
function updateColorsVisibility() {
    const isUnicolor = (Parameters.colorMode === ColorMode.UNICOLOR);
    const imageColorSource = (Parameters.colorSource === ColorSource.IMAGE);
    Page.Controls.setVisibility(controlId.COLOR_AUTO_CHECKBOX_ID, isUnicolor);
    Page.Controls.setVisibility(controlId.COLOR_HIGH_QUALITY_CHECKBOX_ID, isUnicolor);
    Page.Controls.setVisibility(controlId.PARTICLE_COLORPICKER_ID, isUnicolor && !Parameters.autoColor);
    Page.Controls.setVisibility(controlId.COLOR_SOURCE_TABS_ID, !isUnicolor);
    Page.Controls.setVisibility(controlId.IMAGE_SELECT_ID, !isUnicolor && imageColorSource);
    Page.Controls.setVisibility(controlId.IMAGE_UPLOAD_BUTTON_ID, !isUnicolor && imageColorSource);
}
Page.Range.addLazyObserver(controlId.PARTICLES_COUNT_ID, callResetObservers);
Page.Button.addObserver(controlId.RESET_BUTTON_ID, callResetObservers);
Page.Tabs.addObserver(controlId.COLOR_MODE_TABS_ID, () => {
    updateColorsVisibility();
    if (Parameters.colorMode === ColorMode.MULTICOLOR) {
        callResetObservers();
    }
});
Page.Checkbox.addObserver(controlId.COLOR_AUTO_CHECKBOX_ID, updateColorsVisibility);
Page.Tabs.addObserver(controlId.COLOR_SOURCE_TABS_ID, updateColorsVisibility);
Page.Select.addObserver(controlId.IMAGE_SELECT_ID, () => {
    customImageFile = null;
    Page.FileControl.clearFileUpload(controlId.IMAGE_UPLOAD_BUTTON_ID);
    callResetObservers();
});
Page.FileControl.addUploadObserver(controlId.IMAGE_UPLOAD_BUTTON_ID, (filesList) => {
    Page.Select.setValue(controlId.IMAGE_SELECT_ID, null);
    customImageFile = filesList[0] || null;
    callResetObservers();
});
updateColorsVisibility();
Page.Checkbox.addObserver(controlId.SHOW_INDICATORS_CHECKBOX_ID, (show) => {
    Page.Canvas.setIndicatorsVisibility(show);
});
Page.Canvas.setIndicatorsVisibility(Page.Checkbox.isChecked(controlId.SHOW_INDICATORS_CHECKBOX_ID));
Page.Checkbox.addObserver(controlId.BLENDING_CHECKBOX_ID, (hasBlending) => {
    Page.Controls.setVisibility(controlId.OPACITY_RANGE_ID, hasBlending);
});
Page.Controls.setVisibility(controlId.OPACITY_RANGE_ID, Page.Checkbox.isChecked(controlId.BLENDING_CHECKBOX_ID));


/***/ }),

/***/ "./src/ts/render/composition.ts":
/*!**************************************!*\
  !*** ./src/ts/render/composition.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Composition = void 0;
const composition_wgsl_1 = __importDefault(__webpack_require__(/*! ../../shaders/composition.wgsl */ "./src/shaders/composition.wgsl"));
const parameters_1 = __webpack_require__(/*! ../parameters */ "./src/ts/parameters.ts");
const WebGPU = __importStar(__webpack_require__(/*! ../webgpu-utils/webgpu-device */ "./src/ts/webgpu-utils/webgpu-device.ts"));
class Composition {
    constructor(targetTextureFormat) {
        this.textureWidth = -1;
        this.textureHeight = -1;
        this.textureFormat = "r8unorm";
        const shaderModule = WebGPU.device.createShaderModule({ code: composition_wgsl_1.default });
        this.pipeline = WebGPU.device.createRenderPipeline({
            vertex: {
                module: shaderModule,
                entryPoint: "main_vertex",
                buffers: []
            },
            fragment: {
                module: shaderModule,
                entryPoint: "main_fragment",
                targets: [{
                        format: targetTextureFormat,
                    }],
            },
            primitive: {
                cullMode: "none",
                topology: "triangle-strip",
            },
            layout: "auto"
        });
        this.uniformsBuffer = WebGPU.device.createBuffer({
            size: 32,
            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM,
        });
        this.textureSampler = WebGPU.device.createSampler({
            addressModeU: "clamp-to-edge",
            addressModeV: "clamp-to-edge",
            magFilter: "linear",
            minFilter: "linear",
        });
    }
    getRenderToTexturePassEncoder(commandEncoder, webgpuCanvas) {
        this.resizeTextureIfNeeded(webgpuCanvas.width, webgpuCanvas.height);
        return commandEncoder.beginRenderPass(this.renderToTexturePassDescriptor);
    }
    apply(commandEncoder, webgpuCanvas) {
        const color = parameters_1.Parameters.particleColor;
        const uniformsData = new ArrayBuffer(20);
        new Float32Array(uniformsData, 0, 4).set([color[0], color[1], color[2], parameters_1.Parameters.opacity]);
        new Uint32Array(uniformsData, 16, 1).set([parameters_1.Parameters.blending ? 1 : 0]);
        WebGPU.device.queue.writeBuffer(this.uniformsBuffer, 0, uniformsData);
        const renderPassEncoder = webgpuCanvas.beginRenderPass(commandEncoder);
        renderPassEncoder.setPipeline(this.pipeline);
        renderPassEncoder.setBindGroup(0, this.bindgroup);
        renderPassEncoder.draw(4, 1, 0, 0);
        renderPassEncoder.end();
    }
    resizeTextureIfNeeded(wantedWidth, wantedHeight) {
        if (this.textureWidth !== wantedWidth || this.textureHeight !== wantedHeight) {
            if (this.texture) {
                this.texture.destroy();
            }
            this.texture = WebGPU.device.createTexture({
                size: [wantedWidth, wantedHeight],
                format: this.textureFormat,
                usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING,
            });
            this.textureWidth = wantedWidth;
            this.textureHeight = wantedHeight;
            this.bindgroup = WebGPU.device.createBindGroup({
                layout: this.pipeline.getBindGroupLayout(0),
                entries: [
                    {
                        binding: 0,
                        resource: {
                            buffer: this.uniformsBuffer,
                        }
                    },
                    {
                        binding: 1,
                        resource: this.texture.createView()
                    },
                    {
                        binding: 2,
                        resource: this.textureSampler
                    }
                ]
            });
            this.renderToTexturePassDescriptor = {
                colorAttachments: [{
                        view: this.texture.createView(),
                        loadOp: 'clear',
                        clearValue: { r: 0, g: 0, b: 0, a: 0 },
                        storeOp: 'store'
                    }],
            };
        }
    }
}
exports.Composition = Composition;


/***/ }),

/***/ "./src/ts/render/renderer-high-quality.ts":
/*!************************************************!*\
  !*** ./src/ts/render/renderer-high-quality.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RendererHighQuality = void 0;
const composition_1 = __webpack_require__(/*! ./composition */ "./src/ts/render/composition.ts");
// Rather than accumulating directly particles color,
// this renderer uses deferred rendering to:
// - first count the particles count per pixel (render to texture with additive blending)
// - then compute the final color during compositing.
class RendererHighQuality {
    constructor(targetTextureFormat) {
        this.particleColor = [0, 0, 0];
        this.particleOpacity = 1;
        this.enableAdditiveBlending = true;
        this.spriteSize = 2;
        this.composition = new composition_1.Composition(targetTextureFormat);
    }
    draw(commandEncoder, webgpuCanvas, particlesBatches) {
        this.renderToTexture(commandEncoder, webgpuCanvas, particlesBatches);
        this.applyComposition(commandEncoder, webgpuCanvas);
    }
    renderToTexture(commandEncoder, webgpuCanvas, particlesBatches) {
        this.renderer.particleColor = [1 / 255, 0, 0];
        this.renderer.particleOpacity = 1;
        this.renderer.enableAdditiveBlending = true;
        this.renderer.spriteSize = this.spriteSize;
        const textureRenderPassEncoder = this.composition.getRenderToTexturePassEncoder(commandEncoder, webgpuCanvas);
        this.renderer.drawInternal(textureRenderPassEncoder, webgpuCanvas.width, webgpuCanvas.height, particlesBatches);
        textureRenderPassEncoder.end();
    }
    applyComposition(commandEncoder, webgpuCanvas) {
        this.composition.apply(commandEncoder, webgpuCanvas);
    }
}
exports.RendererHighQuality = RendererHighQuality;


/***/ }),

/***/ "./src/ts/render/renderer-instanced-monocolor-high-quality.ts":
/*!********************************************************************!*\
  !*** ./src/ts/render/renderer-instanced-monocolor-high-quality.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/// <reference types="../webgpu-utils/wgsl-type" />
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RendererInstancedMonocolorHighQuality = void 0;
const renderer_high_quality_1 = __webpack_require__(/*! ./renderer-high-quality */ "./src/ts/render/renderer-high-quality.ts");
const renderer_instanced_monocolor_1 = __webpack_require__(/*! ./renderer-instanced-monocolor */ "./src/ts/render/renderer-instanced-monocolor.ts");
class RendererInstancedMonocolorHighQuality extends renderer_high_quality_1.RendererHighQuality {
    constructor(targetTextureFormat) {
        super(targetTextureFormat);
        this.renderer = new renderer_instanced_monocolor_1.RendererInstancedMonocolor(this.composition.textureFormat);
    }
}
exports.RendererInstancedMonocolorHighQuality = RendererInstancedMonocolorHighQuality;


/***/ }),

/***/ "./src/ts/render/renderer-instanced-monocolor.ts":
/*!*******************************************************!*\
  !*** ./src/ts/render/renderer-instanced-monocolor.ts ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/// <reference types="../webgpu-utils/wgsl-type" />
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RendererInstancedMonocolor = void 0;
const draw_instanced_monocolor_wgsl_1 = __importDefault(__webpack_require__(/*! ../../shaders/draw-instanced-monocolor.wgsl */ "./src/shaders/draw-instanced-monocolor.wgsl"));
const WebGPU = __importStar(__webpack_require__(/*! ../webgpu-utils/webgpu-device */ "./src/ts/webgpu-utils/webgpu-device.ts"));
const renderer_instanced_1 = __webpack_require__(/*! ./renderer-instanced */ "./src/ts/render/renderer-instanced.ts");
class RendererInstancedMonocolor extends renderer_instanced_1.RendererInstanced {
    constructor(targetTextureFormat) {
        super(targetTextureFormat);
        const shaderModule = WebGPU.device.createShaderModule({ code: draw_instanced_monocolor_wgsl_1.default });
        this.createRenderPipelines({
            vertex: {
                module: shaderModule,
                entryPoint: "main_vertex",
                buffers: [
                    {
                        attributes: [
                            {
                                shaderLocation: 0,
                                offset: 0,
                                format: "float32x2",
                            }
                        ],
                        arrayStride: Float32Array.BYTES_PER_ELEMENT * 4,
                        stepMode: "instance",
                    },
                    {
                        attributes: [
                            {
                                shaderLocation: 1,
                                offset: 0,
                                format: "float32x2",
                            }
                        ],
                        arrayStride: Float32Array.BYTES_PER_ELEMENT * 2,
                        stepMode: "vertex",
                    }
                ]
            },
            fragment: {
                module: shaderModule,
                entryPoint: "main_fragment",
                targets: [],
            },
            primitive: {
                cullMode: "none",
                topology: "triangle-list",
            },
            layout: "auto"
        });
    }
    drawInternal(renderPassEncoder, canvasWidth, canvasHeight, particleBatches) {
        super.updateUniformsBuffer(canvasWidth, canvasHeight);
        renderPassEncoder.setPipeline(this.pipeline.renderPipeline);
        renderPassEncoder.setBindGroup(0, this.pipeline.uniformsBindgroup);
        renderPassEncoder.setVertexBuffer(1, this.quadBuffer);
        for (const particlesBatch of particleBatches) {
            renderPassEncoder.setVertexBuffer(0, particlesBatch.gpuBuffer);
            renderPassEncoder.draw(6, particlesBatch.particlesCount, 0, 0);
        }
    }
}
exports.RendererInstancedMonocolor = RendererInstancedMonocolor;


/***/ }),

/***/ "./src/ts/render/renderer-instanced-multicolor-velocity.ts":
/*!*****************************************************************!*\
  !*** ./src/ts/render/renderer-instanced-multicolor-velocity.ts ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/// <reference types="../webgpu-utils/wgsl-type" />
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RendererInstancedMulticolorVelocity = void 0;
const draw_instanced_multicolor_velocity_wgsl_1 = __importDefault(__webpack_require__(/*! ../../shaders/draw-instanced-multicolor-velocity.wgsl */ "./src/shaders/draw-instanced-multicolor-velocity.wgsl"));
const color_part_wgsl_1 = __importDefault(__webpack_require__(/*! ../../shaders/utils/color.part.wgsl */ "./src/shaders/utils/color.part.wgsl"));
const WebGPU = __importStar(__webpack_require__(/*! ../webgpu-utils/webgpu-device */ "./src/ts/webgpu-utils/webgpu-device.ts"));
const renderer_instanced_1 = __webpack_require__(/*! ./renderer-instanced */ "./src/ts/render/renderer-instanced.ts");
class RendererInstancedMulticolorVelocity extends renderer_instanced_1.RendererInstanced {
    constructor(targetTextureFormat) {
        super(targetTextureFormat);
        const shaderModule = WebGPU.device.createShaderModule({ code: color_part_wgsl_1.default + draw_instanced_multicolor_velocity_wgsl_1.default });
        this.createRenderPipelines({
            vertex: {
                module: shaderModule,
                entryPoint: "main_vertex",
                buffers: [
                    {
                        attributes: [
                            {
                                shaderLocation: 0,
                                offset: 0,
                                format: "float32x2",
                            },
                            {
                                shaderLocation: 1,
                                offset: Float32Array.BYTES_PER_ELEMENT * 2,
                                format: "float32x2",
                            }
                        ],
                        arrayStride: Float32Array.BYTES_PER_ELEMENT * 4,
                        stepMode: "instance",
                    },
                    {
                        attributes: [
                            {
                                shaderLocation: 2,
                                offset: 0,
                                format: "float32x2",
                            }
                        ],
                        arrayStride: Float32Array.BYTES_PER_ELEMENT * 2,
                        stepMode: "vertex",
                    }
                ]
            },
            fragment: {
                module: shaderModule,
                entryPoint: "main_fragment",
                targets: [],
            },
            primitive: {
                cullMode: "none",
                topology: "triangle-list",
            },
            layout: "auto"
        });
    }
    drawInternal(renderPassEncoder, canvasWidth, canvasHeight, particleBatches) {
        super.updateUniformsBuffer(canvasWidth, canvasHeight);
        renderPassEncoder.setPipeline(this.pipeline.renderPipeline);
        renderPassEncoder.setBindGroup(0, this.pipeline.uniformsBindgroup);
        renderPassEncoder.setVertexBuffer(1, this.quadBuffer);
        for (const particlesBatch of particleBatches) {
            renderPassEncoder.setVertexBuffer(0, particlesBatch.gpuBuffer);
            renderPassEncoder.draw(6, particlesBatch.particlesCount, 0, 0);
        }
    }
}
exports.RendererInstancedMulticolorVelocity = RendererInstancedMulticolorVelocity;


/***/ }),

/***/ "./src/ts/render/renderer-instanced-multicolor.ts":
/*!********************************************************!*\
  !*** ./src/ts/render/renderer-instanced-multicolor.ts ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/// <reference types="../webgpu-utils/wgsl-type" />
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RendererInstancedMulticolor = void 0;
const draw_instanced_multicolor_wgsl_1 = __importDefault(__webpack_require__(/*! ../../shaders/draw-instanced-multicolor.wgsl */ "./src/shaders/draw-instanced-multicolor.wgsl"));
const color_part_wgsl_1 = __importDefault(__webpack_require__(/*! ../../shaders/utils/color.part.wgsl */ "./src/shaders/utils/color.part.wgsl"));
const WebGPU = __importStar(__webpack_require__(/*! ../webgpu-utils/webgpu-device */ "./src/ts/webgpu-utils/webgpu-device.ts"));
const renderer_instanced_1 = __webpack_require__(/*! ./renderer-instanced */ "./src/ts/render/renderer-instanced.ts");
class RendererInstancedMulticolor extends renderer_instanced_1.RendererInstanced {
    constructor(targetTextureFormat) {
        super(targetTextureFormat);
        const shaderModule = WebGPU.device.createShaderModule({ code: color_part_wgsl_1.default + draw_instanced_multicolor_wgsl_1.default });
        this.createRenderPipelines({
            vertex: {
                module: shaderModule,
                entryPoint: "main_vertex",
                buffers: [
                    {
                        attributes: [
                            {
                                shaderLocation: 0,
                                offset: 0,
                                format: "float32x2",
                            }
                        ],
                        arrayStride: Float32Array.BYTES_PER_ELEMENT * 4,
                        stepMode: "instance",
                    },
                    {
                        attributes: [
                            {
                                shaderLocation: 1,
                                offset: 0,
                                format: "float32x2",
                            }
                        ],
                        arrayStride: Float32Array.BYTES_PER_ELEMENT * 2,
                        stepMode: "vertex",
                    },
                    {
                        attributes: [
                            {
                                shaderLocation: 2,
                                offset: 0,
                                format: "uint32",
                            }
                        ],
                        arrayStride: Uint32Array.BYTES_PER_ELEMENT,
                        stepMode: "instance",
                    }
                ]
            },
            fragment: {
                module: shaderModule,
                entryPoint: "main_fragment",
                targets: [],
            },
            primitive: {
                cullMode: "none",
                topology: "triangle-list",
            },
            layout: "auto"
        });
    }
    drawInternal(renderPassEncoder, canvasWidth, canvasHeight, particleBatches) {
        super.updateUniformsBuffer(canvasWidth, canvasHeight);
        renderPassEncoder.setPipeline(this.pipeline.renderPipeline);
        renderPassEncoder.setBindGroup(0, this.pipeline.uniformsBindgroup);
        renderPassEncoder.setVertexBuffer(1, this.quadBuffer);
        for (const particlesBatch of particleBatches) {
            renderPassEncoder.setVertexBuffer(0, particlesBatch.gpuBuffer);
            renderPassEncoder.setVertexBuffer(2, particlesBatch.colorsBuffer);
            renderPassEncoder.draw(6, particlesBatch.particlesCount, 0, 0);
        }
    }
}
exports.RendererInstancedMulticolor = RendererInstancedMulticolor;


/***/ }),

/***/ "./src/ts/render/renderer-instanced.ts":
/*!*********************************************!*\
  !*** ./src/ts/render/renderer-instanced.ts ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/// <reference types="../webgpu-utils/wgsl-type" />
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RendererInstanced = void 0;
const WebGPU = __importStar(__webpack_require__(/*! ../webgpu-utils/webgpu-device */ "./src/ts/webgpu-utils/webgpu-device.ts"));
const renderer_1 = __webpack_require__(/*! ./renderer */ "./src/ts/render/renderer.ts");
class RendererInstanced extends renderer_1.Renderer {
    constructor(targetTextureFormat) {
        super(targetTextureFormat);
        this.quadBuffer = WebGPU.device.createBuffer({
            size: Float32Array.BYTES_PER_ELEMENT * 2 * 6,
            usage: GPUBufferUsage.VERTEX,
            mappedAtCreation: true,
        });
        new Float32Array(this.quadBuffer.getMappedRange()).set([
            -1, -1, +1, -1, +1, +1,
            -1, -1, +1, +1, -1, +1
        ]);
        this.quadBuffer.unmap();
    }
}
exports.RendererInstanced = RendererInstanced;


/***/ }),

/***/ "./src/ts/render/renderer-monocolor-high-quality.ts":
/*!**********************************************************!*\
  !*** ./src/ts/render/renderer-monocolor-high-quality.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/// <reference types="../webgpu-utils/wgsl-type" />
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RendererMonocolorHighQuality = void 0;
const renderer_high_quality_1 = __webpack_require__(/*! ./renderer-high-quality */ "./src/ts/render/renderer-high-quality.ts");
const renderer_monocolor_1 = __webpack_require__(/*! ./renderer-monocolor */ "./src/ts/render/renderer-monocolor.ts");
class RendererMonocolorHighQuality extends renderer_high_quality_1.RendererHighQuality {
    constructor(targetTextureFormat) {
        super(targetTextureFormat);
        this.renderer = new renderer_monocolor_1.RendererMonocolor(this.composition.textureFormat);
    }
}
exports.RendererMonocolorHighQuality = RendererMonocolorHighQuality;


/***/ }),

/***/ "./src/ts/render/renderer-monocolor.ts":
/*!*********************************************!*\
  !*** ./src/ts/render/renderer-monocolor.ts ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/// <reference types="../webgpu-utils/wgsl-type" />
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RendererMonocolor = void 0;
const draw_monocolor_wgsl_1 = __importDefault(__webpack_require__(/*! ../../shaders/draw-monocolor.wgsl */ "./src/shaders/draw-monocolor.wgsl"));
const WebGPU = __importStar(__webpack_require__(/*! ../webgpu-utils/webgpu-device */ "./src/ts/webgpu-utils/webgpu-device.ts"));
const renderer_1 = __webpack_require__(/*! ./renderer */ "./src/ts/render/renderer.ts");
class RendererMonocolor extends renderer_1.Renderer {
    constructor(targetTextureFormat) {
        super(targetTextureFormat);
        const shaderModule = WebGPU.device.createShaderModule({ code: draw_monocolor_wgsl_1.default });
        this.createRenderPipelines({
            vertex: {
                module: shaderModule,
                entryPoint: "main_vertex",
                buffers: [
                    {
                        attributes: [
                            {
                                shaderLocation: 0,
                                offset: 0,
                                format: "float32x2",
                            }
                        ],
                        arrayStride: Float32Array.BYTES_PER_ELEMENT * 4,
                        stepMode: "vertex",
                    }
                ]
            },
            fragment: {
                module: shaderModule,
                entryPoint: "main_fragment",
                targets: [],
            },
            primitive: {
                cullMode: "none",
                topology: "point-list",
            },
            layout: "auto"
        });
    }
    drawInternal(renderPassEncoder, canvasWidth, canvasHeight, particleBatches) {
        super.updateUniformsBuffer(canvasWidth, canvasHeight);
        renderPassEncoder.setPipeline(this.pipeline.renderPipeline);
        renderPassEncoder.setBindGroup(0, this.pipeline.uniformsBindgroup);
        for (const particlesBatch of particleBatches) {
            renderPassEncoder.setVertexBuffer(0, particlesBatch.gpuBuffer);
            renderPassEncoder.draw(particlesBatch.particlesCount, 1, 0, 0);
        }
    }
}
exports.RendererMonocolor = RendererMonocolor;


/***/ }),

/***/ "./src/ts/render/renderer-multicolor-velocity.ts":
/*!*******************************************************!*\
  !*** ./src/ts/render/renderer-multicolor-velocity.ts ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/// <reference types="../webgpu-utils/wgsl-type" />
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RendererMulticolorVelocity = void 0;
const draw_multicolor_velocity_wgsl_1 = __importDefault(__webpack_require__(/*! ../../shaders/draw-multicolor-velocity.wgsl */ "./src/shaders/draw-multicolor-velocity.wgsl"));
const color_part_wgsl_1 = __importDefault(__webpack_require__(/*! ../../shaders/utils/color.part.wgsl */ "./src/shaders/utils/color.part.wgsl"));
const WebGPU = __importStar(__webpack_require__(/*! ../webgpu-utils/webgpu-device */ "./src/ts/webgpu-utils/webgpu-device.ts"));
const renderer_1 = __webpack_require__(/*! ./renderer */ "./src/ts/render/renderer.ts");
class RendererMulticolorVelocity extends renderer_1.Renderer {
    constructor(targetTextureFormat) {
        super(targetTextureFormat);
        const shaderModule = WebGPU.device.createShaderModule({ code: color_part_wgsl_1.default + draw_multicolor_velocity_wgsl_1.default });
        this.createRenderPipelines({
            vertex: {
                module: shaderModule,
                entryPoint: "main_vertex",
                buffers: [
                    {
                        attributes: [
                            {
                                shaderLocation: 0,
                                offset: 0,
                                format: "float32x2",
                            },
                            {
                                shaderLocation: 1,
                                offset: Float32Array.BYTES_PER_ELEMENT * 2,
                                format: "float32x2",
                            }
                        ],
                        arrayStride: Float32Array.BYTES_PER_ELEMENT * 4,
                        stepMode: "vertex",
                    }
                ]
            },
            fragment: {
                module: shaderModule,
                entryPoint: "main_fragment",
                targets: [],
            },
            primitive: {
                cullMode: "none",
                topology: "point-list",
            },
            layout: "auto"
        });
    }
    drawInternal(renderPassEncoder, canvasWidth, canvasHeight, particleBatches) {
        super.updateUniformsBuffer(canvasWidth, canvasHeight);
        renderPassEncoder.setPipeline(this.pipeline.renderPipeline);
        renderPassEncoder.setBindGroup(0, this.pipeline.uniformsBindgroup);
        for (const particlesBatch of particleBatches) {
            renderPassEncoder.setVertexBuffer(0, particlesBatch.gpuBuffer);
            renderPassEncoder.draw(particlesBatch.particlesCount, 1, 0, 0);
        }
    }
}
exports.RendererMulticolorVelocity = RendererMulticolorVelocity;


/***/ }),

/***/ "./src/ts/render/renderer-multicolor.ts":
/*!**********************************************!*\
  !*** ./src/ts/render/renderer-multicolor.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/// <reference types="../webgpu-utils/wgsl-type" />
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RendererMulticolor = void 0;
const draw_multicolor_wgsl_1 = __importDefault(__webpack_require__(/*! ../../shaders/draw-multicolor.wgsl */ "./src/shaders/draw-multicolor.wgsl"));
const color_part_wgsl_1 = __importDefault(__webpack_require__(/*! ../../shaders/utils/color.part.wgsl */ "./src/shaders/utils/color.part.wgsl"));
const WebGPU = __importStar(__webpack_require__(/*! ../webgpu-utils/webgpu-device */ "./src/ts/webgpu-utils/webgpu-device.ts"));
const renderer_1 = __webpack_require__(/*! ./renderer */ "./src/ts/render/renderer.ts");
class RendererMulticolor extends renderer_1.Renderer {
    constructor(targetTextureFormat) {
        super(targetTextureFormat);
        const shaderModule = WebGPU.device.createShaderModule({ code: color_part_wgsl_1.default + draw_multicolor_wgsl_1.default });
        this.createRenderPipelines({
            vertex: {
                module: shaderModule,
                entryPoint: "main_vertex",
                buffers: [
                    {
                        attributes: [
                            {
                                shaderLocation: 0,
                                offset: 0,
                                format: "float32x2",
                            }
                        ],
                        arrayStride: Float32Array.BYTES_PER_ELEMENT * 4,
                        stepMode: "vertex",
                    },
                    {
                        attributes: [
                            {
                                shaderLocation: 1,
                                offset: 0,
                                format: "uint32",
                            }
                        ],
                        arrayStride: Uint32Array.BYTES_PER_ELEMENT,
                        stepMode: "vertex",
                    }
                ]
            },
            fragment: {
                module: shaderModule,
                entryPoint: "main_fragment",
                targets: [],
            },
            primitive: {
                cullMode: "none",
                topology: "point-list",
            },
            layout: "auto"
        });
    }
    drawInternal(renderPassEncoder, canvasWidth, canvasHeight, particleBatches) {
        super.updateUniformsBuffer(canvasWidth, canvasHeight);
        renderPassEncoder.setPipeline(this.pipeline.renderPipeline);
        renderPassEncoder.setBindGroup(0, this.pipeline.uniformsBindgroup);
        for (const particlesBatch of particleBatches) {
            renderPassEncoder.setVertexBuffer(0, particlesBatch.gpuBuffer);
            renderPassEncoder.setVertexBuffer(1, particlesBatch.colorsBuffer);
            renderPassEncoder.draw(particlesBatch.particlesCount, 1, 0, 0);
        }
    }
}
exports.RendererMulticolor = RendererMulticolor;


/***/ }),

/***/ "./src/ts/render/renderer.ts":
/*!***********************************!*\
  !*** ./src/ts/render/renderer.ts ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Renderer = void 0;
const WebGPU = __importStar(__webpack_require__(/*! ../webgpu-utils/webgpu-device */ "./src/ts/webgpu-utils/webgpu-device.ts"));
class Renderer {
    constructor(targetTextureFormat) {
        this.targetTextureFormat = targetTextureFormat;
        this.particleColor = [0, 0, 0];
        this.particleOpacity = 1;
        this.enableAdditiveBlending = true;
        this.spriteSize = 2;
        this.uniformsBuffer = WebGPU.device.createBuffer({
            size: 32,
            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM,
        });
    }
    draw(commandEncoder, webgpuCanvas, particleBatches) {
        const renderPassEncoder = webgpuCanvas.beginRenderPass(commandEncoder);
        this.drawInternal(renderPassEncoder, webgpuCanvas.width, webgpuCanvas.height, particleBatches);
        renderPassEncoder.end();
    }
    createRenderPipelines(descriptor) {
        if (!descriptor.fragment) {
            throw new Error("Missing property 'fragment' on descriptor.");
        }
        descriptor.fragment.targets = [{
                format: this.targetTextureFormat
            }];
        this.pipelineNoBlending = this.createPipeline(descriptor);
        descriptor.fragment.targets = [{
                format: this.targetTextureFormat,
                blend: {
                    color: {
                        srcFactor: 'src-alpha',
                        dstFactor: 'one',
                        operation: 'add',
                    },
                    alpha: {
                        srcFactor: 'zero',
                        dstFactor: 'one',
                        operation: 'add',
                    }
                }
            }];
        this.pipelineAdditiveBlending = this.createPipeline(descriptor);
    }
    updateUniformsBuffer(canvasWidth, canvasHeight) {
        const uniformsData = [this.particleColor[0], this.particleColor[1], this.particleColor[2], this.particleOpacity, this.spriteSize / canvasWidth, this.spriteSize / canvasHeight];
        WebGPU.device.queue.writeBuffer(this.uniformsBuffer, 0, new Float32Array(uniformsData).buffer);
    }
    get pipeline() {
        if (this.enableAdditiveBlending) {
            return this.pipelineAdditiveBlending;
        }
        else {
            return this.pipelineNoBlending;
        }
    }
    createPipeline(descriptor) {
        const pipeline = WebGPU.device.createRenderPipeline(descriptor);
        const uniformsBindgroup = WebGPU.device.createBindGroup({
            layout: pipeline.getBindGroupLayout(0),
            entries: [
                {
                    binding: 0,
                    resource: {
                        buffer: this.uniformsBuffer,
                    }
                }
            ]
        });
        return { renderPipeline: pipeline, uniformsBindgroup };
    }
}
exports.Renderer = Renderer;


/***/ }),

/***/ "./src/ts/webgpu-utils/webgpu-canvas.ts":
/*!**********************************************!*\
  !*** ./src/ts/webgpu-utils/webgpu-canvas.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGPUCanvas = void 0;
const WebGPU = __importStar(__webpack_require__(/*! ./webgpu-device */ "./src/ts/webgpu-utils/webgpu-device.ts"));
class WebGPUCanvas {
    constructor(canvas) {
        this.canvas = canvas;
        this.devicePixelRatio = window.devicePixelRatio;
        {
            const contextName = "webgpu";
            const context = canvas.getContext(contextName);
            if (!context) {
                throw new Error(`Failed to get a '${contextName}' context from canvas.`);
            }
            this.context = context;
        }
        this.canvasConfiguration = {
            device: WebGPU.device,
            format: navigator.gpu.getPreferredCanvasFormat(),
            usage: GPUTextureUsage.RENDER_ATTACHMENT,
            alphaMode: "opaque",
            // no "size" attribute to use the canvas' width and height
        };
        this.context.configure(this.canvasConfiguration);
        this.adjustSize();
        this.textureFormat = this.canvasConfiguration.format;
        this.clearColor = { r: 0, g: 0, b: 0, a: 1 };
    }
    get width() {
        return this.canvas.width;
    }
    get height() {
        return this.canvas.height;
    }
    adjustSize() {
        const actualWidth = Math.floor(this.devicePixelRatio * this.canvas.clientWidth);
        const actualHeight = Math.floor(this.devicePixelRatio * this.canvas.clientHeight);
        if (this.canvas.width !== actualWidth || this.canvas.height !== actualHeight) {
            this.canvas.width = actualWidth;
            this.canvas.height = actualHeight;
        }
    }
    beginRenderPass(commandEncoder) {
        const renderPassDescriptor = this.getRenderPassDescriptor();
        const renderPassEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
        renderPassEncoder.setViewport(0, 0, this.width, this.height, 0, 1);
        renderPassEncoder.setScissorRect(0, 0, this.width, this.height);
        return renderPassEncoder;
    }
    getRenderPassDescriptor() {
        const colorAttachment = {
            view: this.context.getCurrentTexture().createView(),
            loadOp: 'clear',
            clearValue: this.clearColor,
            storeOp: 'store'
        };
        const renderPassDesc = {
            colorAttachments: [colorAttachment],
        };
        return renderPassDesc;
    }
}
exports.WebGPUCanvas = WebGPUCanvas;


/***/ }),

/***/ "./src/ts/webgpu-utils/webgpu-device.ts":
/*!**********************************************!*\
  !*** ./src/ts/webgpu-utils/webgpu-device.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {


/// <reference types="../page-interface-generated" />
/// <reference types="@webgpu/types" />
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.initialize = exports.gpu = exports.device = exports.adapter = void 0;
function throwAndDisplayException(id, message) {
    Page.Demopage.setErrorMessage(id, message);
    Page.Canvas.toggleFullscreen(false);
    throw new Error(message);
}
const gpu = navigator.gpu;
exports.gpu = gpu;
if (!gpu) {
    throwAndDisplayException("webgpu-support", "Your browser does not seem to support WebGPU.");
}
let adapter = null;
exports.adapter = adapter;
let device = null;
exports.device = device;
async function requestDevice() {
    if (!device) {
        exports.adapter = adapter = await gpu.requestAdapter({
            powerPreference: "high-performance"
        });
        if (adapter) {
            if (adapter.isFallbackAdapter) {
                Page.Demopage.setErrorMessage("webgpu-is-fallback", "The retrieved GPU adapter is fallback. The performance might be degraded.");
            }
            exports.device = device = await adapter.requestDevice();
        }
        else {
            throwAndDisplayException("webgpu-adapter", "Request for GPU adapter failed.");
        }
    }
}
exports.initialize = requestDevice;


/***/ }),

/***/ "./src/resources/colors.png":
/*!**********************************!*\
  !*** ./src/resources/colors.png ***!
  \**********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "..\\rc\\images\\b7a8198c185b8b92aebb.png";

/***/ }),

/***/ "./src/resources/ladybug.png":
/*!***********************************!*\
  !*** ./src/resources/ladybug.png ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "..\\rc\\images\\a17685859ad122820967.png";

/***/ }),

/***/ "./src/shaders/composition.wgsl":
/*!**************************************!*\
  !*** ./src/shaders/composition.wgsl ***!
  \**************************************/
/***/ ((module) => {

module.exports = "struct Uniforms {             //             align(32)  size(20)\r\n    color: vec4<f32>,         // offset(0)   align(16)  size(16)\r\n    additiveBlending: u32,    // offset(16)  align(4)   size(4)\r\n};\r\n\r\n@group(0) @binding(0) var<uniform> uniforms: Uniforms;\r\n@group(0) @binding(1) var accumulationTexture: texture_2d<f32>;\r\n@group(0) @binding(2) var accumulationTextureSampler: sampler;\r\n\r\nstruct VertexOut {\r\n    @builtin(position) position: vec4<f32>,\r\n    @location(0) uv: vec2<f32>,\r\n}\r\n\r\n@vertex\r\nfn main_vertex(@builtin(vertex_index) inVertexIndex: u32) -> VertexOut {\r\n    var out: VertexOut;\r\n    if (inVertexIndex == 0u) {\r\n        out.uv = vec2<f32>(0.0, 0.0);\r\n    } else if (inVertexIndex == 1u) {\r\n        out.uv = vec2<f32>(0.0, 1.0);\r\n    } else if (inVertexIndex == 2u) {\r\n        out.uv = vec2<f32>(1.0, 0.0);\r\n    } else {\r\n        out.uv = vec2<f32>(1.0, 1.0);\r\n    }\r\n\r\n    out.position = vec4<f32>(2.0 * out.uv.x - 1.0, 1.0 - 2.0 * out.uv.y, 0.0, 1.0);\r\n    return out;\r\n}\r\n\r\n@fragment\r\nfn main_fragment(@location(0) uv: vec2<f32>) -> @location(0) vec4<f32> {\r\n    let cumulated = textureSample(accumulationTexture, accumulationTextureSampler, uv).r;\r\n\r\n    if (uniforms.additiveBlending == 1u) {\r\n        return vec4<f32>(255.0 * cumulated * uniforms.color.a * uniforms.color.rgb, 1.0);\r\n    } else {\r\n        return step(0.001, cumulated) * vec4<f32>(uniforms.color.rgb, 1.0);\r\n    }\r\n}\r\n";

/***/ }),

/***/ "./src/shaders/draw-instanced-monocolor.wgsl":
/*!***************************************************!*\
  !*** ./src/shaders/draw-instanced-monocolor.wgsl ***!
  \***************************************************/
/***/ ((module) => {

module.exports = "struct Uniforms {             //             align(16)  size(24)\r\n    color: vec4<f32>,         // offset(0)   align(16)  size(16)\r\n    spriteSize: vec2<f32>,    // offset(16)   align(8)  size(8)\r\n};\r\n\r\nstruct VSOut {\r\n    @builtin(position) position: vec4<f32>,\r\n    @location(0) localPosition: vec2<f32>, // in {-1, +1}^2\r\n};\r\n\r\n@group(0) @binding(0) var<uniform> uniforms: Uniforms;\r\n\r\n@vertex\r\nfn main_vertex(@location(0) inPosition: vec2<f32>, @location(1) quadCorner: vec2<f32>) -> VSOut {\r\n    var vsOut: VSOut;\r\n    vsOut.position = vec4<f32>(inPosition + uniforms.spriteSize * quadCorner, 0.0, 1.0);\r\n    vsOut.position.y = -vsOut.position.y;\r\n    vsOut.localPosition = quadCorner;\r\n    return vsOut;\r\n}\r\n\r\n@fragment\r\nfn main_fragment(@location(0) localPosition: vec2<f32>) -> @location(0) vec4<f32> {\r\n    let distanceFromCenter: f32 = length(localPosition);\r\n    if (distanceFromCenter > 1.0) {\r\n        discard;\r\n    }\r\n\r\n    return uniforms.color;\r\n}\r\n";

/***/ }),

/***/ "./src/shaders/draw-instanced-multicolor-velocity.wgsl":
/*!*************************************************************!*\
  !*** ./src/shaders/draw-instanced-multicolor-velocity.wgsl ***!
  \*************************************************************/
/***/ ((module) => {

module.exports = "struct Uniforms {             //             align(16)  size(24)\r\n    color: vec4<f32>,         // offset(0)   align(16)  size(16)\r\n    spriteSize: vec2<f32>,    // offset(16)   align(8)  size(8)\r\n};\r\n\r\nstruct VertexOutput {\r\n    @builtin(position) position: vec4<f32>,\r\n    @location(0) localPosition: vec2<f32>, // in {-1, +1}^2\r\n    @location(1) @interpolate(flat) color: vec4<f32>,\r\n};\r\n\r\n@group(0) @binding(0) var<uniform> uniforms: Uniforms;\r\n\r\n@vertex\r\nfn main_vertex(@location(0) inPosition: vec2<f32>, @location(1) inVelocity: vec2<f32>, @location(2) quadCorner: vec2<f32>) -> VertexOutput {\r\n    var vsOut: VertexOutput;\r\n    vsOut.position = vec4<f32>(inPosition + uniforms.spriteSize * quadCorner, 0.0, 1.0);\r\n    vsOut.position.y = -vsOut.position.y;\r\n    vsOut.localPosition = quadCorner;\r\n    vsOut.color = colorFromVelocity(inVelocity, uniforms.color.a);\r\n    return vsOut;\r\n}\r\n\r\n@fragment\r\nfn main_fragment(@location(0) localPosition: vec2<f32>, @location(1) @interpolate(flat) color: vec4<f32>) -> @location(0) vec4<f32> {\r\n    let distanceFromCenter: f32 = length(localPosition);\r\n    if (distanceFromCenter > 1.0) {\r\n        discard;\r\n    }\r\n\r\n    return color;\r\n}\r\n";

/***/ }),

/***/ "./src/shaders/draw-instanced-multicolor.wgsl":
/*!****************************************************!*\
  !*** ./src/shaders/draw-instanced-multicolor.wgsl ***!
  \****************************************************/
/***/ ((module) => {

module.exports = "struct Uniforms {             //             align(16)  size(24)\r\n    color: vec4<f32>,         // offset(0)   align(16)  size(16)\r\n    spriteSize: vec2<f32>,    // offset(16)   align(8)  size(8)\r\n};\r\n\r\nstruct VertexOutput {\r\n    @builtin(position) position: vec4<f32>,\r\n    @location(0) localPosition: vec2<f32>, // in {-1, +1}^2\r\n    @location(1) @interpolate(flat) color: u32,\r\n};\r\n\r\n@group(0) @binding(0) var<uniform> uniforms: Uniforms;\r\n\r\n@vertex\r\nfn main_vertex(@location(0) inPosition: vec2<f32>, @location(1) quadCorner: vec2<f32>, @location(2) inColor: u32) -> VertexOutput {\r\n    var vsOut: VertexOutput;\r\n    vsOut.position = vec4<f32>(inPosition + uniforms.spriteSize * quadCorner, 0.0, 1.0);\r\n    vsOut.position.y = -vsOut.position.y;\r\n    vsOut.localPosition = quadCorner;\r\n    vsOut.color = inColor;\r\n    return vsOut;\r\n}\r\n\r\n@fragment\r\nfn main_fragment(@location(0) localPosition: vec2<f32>, @location(1) @interpolate(flat) color: u32) -> @location(0) vec4<f32> {\r\n    let distanceFromCenter: f32 = length(localPosition);\r\n    if (distanceFromCenter > 1.0) {\r\n        discard;\r\n    }\r\n\r\n    return unpackColor(color, uniforms.color.a);\r\n}\r\n";

/***/ }),

/***/ "./src/shaders/draw-monocolor.wgsl":
/*!*****************************************!*\
  !*** ./src/shaders/draw-monocolor.wgsl ***!
  \*****************************************/
/***/ ((module) => {

module.exports = "@vertex\r\nfn main_vertex(@location(0) inPosition: vec2<f32>) -> @builtin(position) vec4<f32> {\r\n    return vec4<f32>(inPosition.x, -inPosition.y, 0.0, 1.0);\r\n}\r\n\r\nstruct Uniforms {             //             align(16)  size(16)\r\n    color: vec4<f32>,         // offset(0)   align(16)  size(16)\r\n};\r\n\r\n@group(0) @binding(0) var<uniform> uniforms: Uniforms;\r\n\r\n@fragment\r\nfn main_fragment() -> @location(0) vec4<f32> {\r\n    return uniforms.color;\r\n}\r\n";

/***/ }),

/***/ "./src/shaders/draw-multicolor-velocity.wgsl":
/*!***************************************************!*\
  !*** ./src/shaders/draw-multicolor-velocity.wgsl ***!
  \***************************************************/
/***/ ((module) => {

module.exports = "struct VSOut {\r\n    @builtin(position) position: vec4<f32>,\r\n    @location(0) @interpolate(flat) color: vec4<f32>,\r\n};\r\n\r\nstruct Uniforms {             //             align(16)  size(16)\r\n    color: vec4<f32>,         // offset(0)   align(16)  size(16)\r\n};\r\n\r\n@group(0) @binding(0) var<uniform> uniforms: Uniforms;\r\n\r\n@vertex\r\nfn main_vertex(@location(0) inPosition: vec2<f32>, @location(1) inVelocity: vec2<f32>) -> VSOut {\r\n    var output: VSOut;\r\n    output.position = vec4<f32>(inPosition.x, -inPosition.y, 0.0, 1.0);\r\n    output.color = colorFromVelocity(inVelocity, uniforms.color.a);\r\n    return output;\r\n}\r\n\r\n@fragment\r\nfn main_fragment(@location(0) @interpolate(flat) color: vec4<f32>) -> @location(0) vec4<f32> {\r\n    return color;\r\n}\r\n";

/***/ }),

/***/ "./src/shaders/draw-multicolor.wgsl":
/*!******************************************!*\
  !*** ./src/shaders/draw-multicolor.wgsl ***!
  \******************************************/
/***/ ((module) => {

module.exports = "struct VSOut {\r\n    @builtin(position) position: vec4<f32>,\r\n    @location(0) @interpolate(flat) color: u32,\r\n};\r\n\r\n@vertex\r\nfn main_vertex(@location(0) inPosition: vec2<f32>, @location(1) inColor: u32) -> VSOut {\r\n    var output: VSOut;\r\n    output.position = vec4<f32>(inPosition.x, -inPosition.y, 0.0, 1.0);\r\n    output.color = inColor;\r\n    return output;\r\n}\r\n\r\nstruct Uniforms {             //             align(16)  size(16)\r\n    color: vec4<f32>,         // offset(0)   align(16)  size(16)\r\n};\r\n\r\n@group(0) @binding(0) var<uniform> uniforms: Uniforms;\r\n\r\n@fragment\r\nfn main_fragment(@location(0) @interpolate(flat) color: u32) -> @location(0) vec4<f32> {\r\n    return unpackColor(color, uniforms.color.a);\r\n}\r\n";

/***/ }),

/***/ "./src/shaders/initialize-colors.wgsl":
/*!********************************************!*\
  !*** ./src/shaders/initialize-colors.wgsl ***!
  \********************************************/
/***/ ((module) => {

module.exports = "struct Particle {\r\n    position: vec2<f32>,\r\n    velocity: vec2<f32>,\r\n};\r\n\r\nstruct ParticlesBuffer {\r\n    particles: array<Particle>,\r\n};\r\n\r\nstruct ColorsBuffer {\r\n    color: array<u32>,\r\n};\r\n\r\n@group(0) @binding(0) var<storage,read> particlesStorage: ParticlesBuffer;\r\n@group(0) @binding(1) var<storage,read_write> colorsStorage: ColorsBuffer;\r\n@group(1) @binding(0) var inputSampler : sampler;\r\n@group(1) @binding(1) var inputTexture: texture_2d<f32>;\r\n\r\n@compute @workgroup_size(256)\r\nfn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {\r\n    let index: u32 = GlobalInvocationID.x;\r\n\r\n    let uv = 0.5 + 0.5 * particlesStorage.particles[index].position;\r\n    let color = textureSampleLevel(inputTexture, inputSampler, uv, 0.0).rgb;\r\n    colorsStorage.color[index] = packColor(color);\r\n}\r\n";

/***/ }),

/***/ "./src/shaders/update.wgsl":
/*!*********************************!*\
  !*** ./src/shaders/update.wgsl ***!
  \*********************************/
/***/ ((module) => {

module.exports = "struct Particle {\r\n    position: vec2<f32>,\r\n    velocity: vec2<f32>\r\n};\r\n\r\nstruct ParticlesBuffer {\r\n    particles: array<Particle>,\r\n};\r\n\r\nstruct Attractor {                                 //             align(8)  size(16)\r\n    position: vec2<f32>,                           // offset(0)   align(8)  size(8)\r\n    force: f32,                                    // offset(8)   align(4)  size(4)\r\n    // -- implicit padding --                      // offset(12)            size(4)\r\n};\r\n\r\nstruct Uniforms {                                  //             align(8)  size(48)\r\n    force: vec2<f32>,                              // offset(0)   align(8)  size(8)\r\n    dt: f32,                                       // offset(8)   align(4)  size(4)\r\n    bounce: u32,                                   // offset(12)  align(4)  size(4)\r\n\r\n    friction: f32,                                 // offset(16)  align(4)  size(4)\r\n    aspectRatio: f32,                              // offset(20)  align(4)  size(4)\r\n    attractorsCount: u32,                          // offset(24)  align(4)  size(4)\r\n    // -- implicit padding --                      // offset(28)            size(4)\r\n    @align(16) attractors: array<Attractor, 4>,    // offset(32)  align(16) size(16) stride(16)\r\n};\r\n\r\n@group(0) @binding(0) var<storage,read_write> particlesStorage: ParticlesBuffer;\r\n@group(0) @binding(1) var<uniform> uniforms: Uniforms;\r\n\r\n@compute @workgroup_size(256)\r\nfn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {\r\n    let index: u32 = GlobalInvocationID.x;\r\n\r\n    var particle = particlesStorage.particles[index];\r\n\r\n    let applyAspectRatio = vec2<f32>(uniforms.aspectRatio, 1.0);\r\n\r\n    var force: vec2<f32> = uniforms.force * applyAspectRatio;\r\n    for (var i = 0u; i < uniforms.attractorsCount; i = i + 1u) {\r\n        var toAttractor: vec2<f32> = (uniforms.attractors[i].position - particle.position) * applyAspectRatio;\r\n        let squaredDistance: f32 = dot(toAttractor, toAttractor);\r\n        force = force + uniforms.attractors[i].force * toAttractor / (squaredDistance + 0.01);\r\n    }\r\n\r\n    particle.velocity = uniforms.friction * (particle.velocity + uniforms.dt * force);\r\n    particle.position = particle.position + uniforms.dt * particle.velocity / applyAspectRatio;\r\n\r\n    if (uniforms.bounce != 0u) {\r\n        if (particle.position.x < -1.0) {\r\n            particle.position.x = -2.0 - particle.position.x;\r\n            particle.velocity.x = -particle.velocity.x;\r\n        }\r\n        if (particle.position.y < -1.0) {\r\n            particle.position.y = -2.0 - particle.position.y;\r\n            particle.velocity.y = -particle.velocity.y;\r\n        }\r\n\r\n        if (particle.position.x > 1.0) {\r\n            particle.position.x = 2.0 - particle.position.x;\r\n            particle.velocity.x = -particle.velocity.x;\r\n        }\r\n        if (particle.position.y > 1.0) {\r\n            particle.position.y = 2.0 - particle.position.y;\r\n            particle.velocity.y = -particle.velocity.y;\r\n        }\r\n    }\r\n\r\n    particlesStorage.particles[index] = particle;\r\n}\r\n";

/***/ }),

/***/ "./src/shaders/utils/color.part.wgsl":
/*!*******************************************!*\
  !*** ./src/shaders/utils/color.part.wgsl ***!
  \*******************************************/
/***/ ((module) => {

module.exports = "fn unpackColor(packed: u32, alpha: f32) -> vec4<f32> {\r\n    return vec4<f32>(unpack4x8unorm(packed).rgb, alpha);\r\n}\r\n\r\nfn packColor(color: vec3<f32>) -> u32 {\r\n    return pack4x8unorm(vec4<f32>(color, 1.0));\r\n}\r\n\r\nfn colorFromHue(normalizedHue: f32, alpha: f32) -> vec4<f32> {\r\n    let value = normalizedHue * 6.0;\r\n    if (value < 1.0) {\r\n        return vec4<f32>(1.0, value, 0.0, alpha);\r\n    } else if (value < 2.0) {\r\n        return vec4<f32>(2.0 - value, 1.0, 0.0, alpha);\r\n    } else if (value < 3.0) {\r\n        return vec4<f32>(0.0, 1.0, value - 2.0, alpha);\r\n    } else if (value < 4.0) {\r\n        return vec4<f32>(0.0, 4.0 - value, 1.0, alpha);\r\n    } else if (value < 5.0) {\r\n        return vec4<f32>(value - 4.0, 0.0, 1.0, alpha);\r\n    }\r\n    return vec4<f32>(1.0, 0.0, 6.0 - value, alpha);\r\n}\r\n\r\nfn colorFromVelocity(velocity: vec2<f32>, alpha: f32) -> vec4<f32> {\r\n    let normalizedHue: f32 = 0.5 + 0.5 * atan2(velocity.y, velocity.x) / 3.14159;\r\n    return colorFromHue(normalizedHue, alpha);\r\n}\r\n";

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && !scriptUrl) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/ts/main.ts");
/******/ 	
/******/ })()
;
//# sourceMappingURL=main.js.map


================================================
FILE: docs/script/page.js
================================================
var Page;
(function (Page) {
    var Demopage;
    (function (Demopage) {
        var errorsBlockId = "error-messages";
        var errorsBlock = document.getElementById(errorsBlockId);
        if (!errorsBlock) {
            throw new Error("Cannot find element '" + errorsBlockId + "'.");
        }
        function getErrorById(id) {
            if (errorsBlock) {
                return errorsBlock.querySelector("span[id=error-message-" + id + "]");
            }
            return null;
        }
        function setErrorMessage(id, message) {
            if (errorsBlock) {
                var existingSpan = getErrorById(id);
                if (existingSpan) {
                    existingSpan.innerHTML = message;
                    return;
                }
                else {
                    var newSpan = document.createElement("span");
                    newSpan.id = "error-message-" + id;
                    newSpan.innerText = message;
                    errorsBlock.appendChild(newSpan);
                    errorsBlock.appendChild(document.createElement("br"));
                }
            }
        }
        Demopage.setErrorMessage = setErrorMessage;
        function removeErrorMessage(id) {
            if (errorsBlock) {
                var span = getErrorById(id);
                if (span) {
                    var br = span.nextElementSibling;
                    if (br) {
                        errorsBlock.removeChild(br);
                    }
                    errorsBlock.removeChild(span);
                }
            }
        }
        Demopage.removeErrorMessage = removeErrorMessage;
    })(Demopage = Page.Demopage || (Page.Demopage = {}));
})(Page || (Page = {}));

var Page;
(function (Page) {
    var Helpers;
    (function (Helpers) {
        var Utils;
        (function (Utils) {
            function selectorAll(base, selector) {
                var elements = base.querySelectorAll(selector);
                var result = [];
                for (var i = 0; i < elements.length; i++) {
                    result.push(elements[i]);
                }
                return result;
            }
            Utils.selectorAll = selectorAll;
            /** @throws if no element was found */
            function selector(base, selector) {
                var element = base.querySelector(selector);
                if (!element) {
                    throw new Error("No element matching '".concat(selector, "'."));
                }
                return element;
            }
            Utils.selector = selector;
            function touchArray(touchList) {
                var result = [];
                for (var i = 0; i < touchList.length; i++) {
                    result.push(touchList[i]);
                }
                return result;
            }
            Utils.touchArray = touchArray;
            function findFirst(array, predicate) {
                if (typeof Array.prototype.findIndex === "function") {
                    return array.findIndex(predicate);
                }
                else {
                    for (var i = 0; i < array.length; i++) {
                        if (predicate(array[i])) {
                            return i;
                        }
                    }
                    return -1;
                }
            }
            Utils.findFirst = findFirst;
        })(Utils = Helpers.Utils || (Helpers.Utils = {}));
        var URL;
        (function (URL) {
            var PARAMETERS_PREFIX = "page";
            var URLBuilder = /** @class */ (function () {
                function URLBuilder(url) {
                    this.queryParameters = {};
                    var queryStringDelimiterIndex = url.indexOf(URLBuilder.queryDelimiter);
                    if (queryStringDelimiterIndex < 0) {
                        this.baseUrl = url;
                    }
                    else {
                        this.baseUrl = url.substring(0, queryStringDelimiterIndex);
                        var queryString = url.substring(queryStringDelimiterIndex + URLBuilder.queryDelimiter.length);
                        var splitParameters = queryString.split(URLBuilder.parameterDelimiter);
                        for (var _i = 0, splitParameters_1 = splitParameters; _i < splitParameters_1.length; _i++) {
                            var parameter = splitParameters_1[_i];
                            var keyValue = parameter.split(URLBuilder.keyValueDelimiter);
                            if (keyValue.length === 2) {
                                var key = decodeURIComponent(keyValue[0]);
                                var value = decodeURIComponent(keyValue[1]);
                                this.queryParameters[key] = value;
                            }
                            else {
                                console.log("Unable to parse query string parameter '" + parameter + "'.");
                            }
                        }
                    }
                }
                URLBuilder.prototype.setQueryParameter = function (name, value) {
                    if (value === null) {
                        delete this.queryParameters[name];
                    }
                    else {
                        this.queryParameters[name] = value;
                    }
                };
                URLBuilder.prototype.loopOnParameters = function (prefix, callback) {
                    for (var _i = 0, _a = Object.keys(this.queryParameters); _i < _a.length; _i++) {
                        var parameterName = _a[_i];
                        if (parameterName.indexOf(prefix) === 0 && parameterName.length > prefix.length) {
                            var parameterValue = this.queryParameters[parameterName];
                            var shortParameterName = parameterName.substring(prefix.length);
                            callback(shortParameterName, parameterValue);
                        }
                    }
                };
                URLBuilder.prototype.buildUrl = function () {
                    var parameters = [];
                    for (var _i = 0, _a = Object.keys(this.queryParameters); _i < _a.length; _i++) {
                        var parameterName = _a[_i];
                        var parameterValue = this.queryParameters[parameterName];
                        var encodedName = encodeURIComponent(parameterName);
                        var encodedValue = encodeURIComponent(parameterValue);
                        parameters.push(encodedName + URLBuilder.keyValueDelimiter + encodedValue);
                    }
                    var queryString = parameters.join(URLBuilder.parameterDelimiter);
                    if (queryString) {
                        return this.baseUrl + URLBuilder.queryDelimiter + queryString;
                    }
                    else {
                        return this.baseUrl;
                    }
                };
                URLBuilder.queryDelimiter = "?";
                URLBuilder.parameterDelimiter = "&";
                URLBuilder.keyValueDelimiter = "=";
                return URLBuilder;
            }());
            function buildPrefix() {
                var prefixes = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    prefixes[_i] = arguments[_i];
                }
                return prefixes.join(":") + ":";
            }
            function updateUrl(newUrl) {
                window.history.replaceState("", "", newUrl);
            }
            function loopOnParameters(prefix, callback) {
                var urlBuilder = new URLBuilder(window.location.href);
                var fullPrefix = buildPrefix(PARAMETERS_PREFIX, prefix);
                urlBuilder.loopOnParameters(fullPrefix, callback);
            }
            URL.loopOnParameters = loopOnParameters;
            function setQueryParameter(prefix, name, value) {
                var urlBuilder = new URLBuilder(window.location.href);
                var fullPrefix = buildPrefix(PARAMETERS_PREFIX, prefix);
                urlBuilder.setQueryParameter(fullPrefix + name, value);
                updateUrl(urlBuilder.buildUrl());
            }
            URL.setQueryParameter = setQueryParameter;
            function removeQueryParameter(prefix, name) {
                var urlBuilder = new URLBuilder(window.location.href);
                var fullPrefix = buildPrefix(PARAMETERS_PREFIX, prefix);
                urlBuilder.setQueryParameter(fullPrefix + name, null);
                updateUrl(urlBuilder.buildUrl());
            }
            URL.removeQueryParameter = removeQueryParameter;
        })(URL = Helpers.URL || (Helpers.URL = {}));
        var Events;
        (function (Events) {
            function callAfterDOMLoaded(callback) {
                if (document.readyState === "loading") { // Loading hasn't finished yet
                    document.addEventListener("DOMContentLoaded", callback);
                }
                else { // `DOMContentLoaded` has already fired
                    callback();
                }
            }
            Events.callAfterDOMLoaded = callAfterDOMLoaded;
        })(Events = Helpers.Events || (Helpers.Events = {}));
        var Cache = /** @class */ (function () {
            function Cache(objectsName, loadObjectsFunction) {
                this.objectsName = objectsName;
                this.loadObjectsFunction = loadObjectsFunction;
                this.cacheObject = null;
            }
            /** @throws An Error if the ID is unknown */
            Cache.prototype.getById = function (id) {
                var object = this.safeCacheObject[id];
                if (!object) {
                    throw new Error("Invalid '".concat(this.objectsName, "' cache object id '").concat(id, "'."));
                }
                return object;
            };
            /** @returns null if the ID is unknown */
            Cache.prototype.getByIdSafe = function (id) {
                return this.safeCacheObject[id] || null;
            };
            Cache.prototype.load = function () {
                if (!this.cacheObject) {
                    this.cacheObject = this.loadCacheObject();
                }
            };
            Object.defineProperty(Cache.prototype, "safeCacheObject", {
                get: function () {
                    if (!this.cacheObject) {
                        this.load();
                    }
                    return this.cacheObject;
                },
                enumerable: false,
                configurable: true
            });
            Cache.prototype.loadCacheObject = function () {
                var index = {};
                var objects = this.loadObjectsFunction();
                for (var _i = 0, objects_1 = objects; _i < objects_1.length; _i++) {
                    var object = objects_1[_i];
                    if (typeof index[object.id] !== "undefined") {
                        throw new Error("Object '".concat(object.id, "' is already in cache."));
                    }
                    index[object.id] = object;
                }
                return index;
            };
            return Cache;
        }());
        Helpers.Cache = Cache;
        var Storage = /** @class */ (function () {
            function Storage(prefix, serialize, tryDeserialize) {
                this.prefix = prefix;
                this.serialize = serialize;
                this.tryDeserialize = tryDeserialize;
            }
            Storage.prototype.storeState = function (control) {
                var valueAsString = this.serialize(control);
                Page.Helpers.URL.setQueryParameter(this.prefix, control.id, valueAsString);
            };
            Storage.prototype.clearStoredState = function (control) {
                Page.Helpers.URL.removeQueryParameter(this.prefix, control.id);
            };
            Storage.prototype.applyStoredState = function () {
                var _this = this;
                Page.Helpers.URL.loopOnParameters(this.prefix, function (controlId, value) {
                    if (!_this.tryDeserialize(controlId, value)) {
                        console.log("Removing invalid query parameter '" + controlId + "=" + value + "'.");
                        Page.Helpers.URL.removeQueryParameter(_this.prefix, controlId);
                    }
                });
            };
            return Storage;
        }());
        Helpers.Storage = Storage;
    })(Helpers = Page.Helpers || (Page.Helpers = {}));
})(Page || (Page = {}));


var Page;
(function (Page) {
    var Controls;
    (function (Controls) {
        function getElementBySelector(selector) {
            var elt = document.querySelector(selector);
            if (!elt) {
                console.error("Cannot find control '" + selector + "'.");
            }
            return elt;
        }
        function setVisibility(id, visible) {
            var control = getElementBySelector("div#control-" + id);
            if (control) {
                control.style.display = visible ? "" : "none";
            }
        }
        Controls.setVisibility = setVisibility;
    })(Controls = Page.Controls || (Page.Controls = {}));
})(Page || (Page = {}));
(function (Page) {
    var Sections;
    (function (Sections) {
        function getElementBySelector(selector) {
            var elt = document.querySelector(selector);
            if (!elt) {
                console.error("Cannot find section '" + selector + "'.");
            }
            return elt;
        }
        function reevaluateSeparatorsVisibility(controlsBlockElement) {
            function isHr(element) {
                return element.tagName.toLowerCase() === "hr";
            }
            function isVisible(element) {
                return element.style.display !== "none";
            }
            var sectionsOrHr = Page.Helpers.Utils.selectorAll(controlsBlockElement, "section, hr");
            //remove duplicate HRs
            var lastWasHr = false;
            for (var _i = 0, sectionsOrHr_1 = sectionsOrHr; _i < sectionsOrHr_1.length; _i++) {
                var sectionOrHr = sectionsOrHr_1[_i];
                if (isHr(sectionOrHr)) {
                    sectionOrHr.style.display = lastWasHr ? "none" : "";
                    lastWasHr = true;
                }
                else if (isVisible(sectionOrHr)) {
                    lastWasHr = false;
                }
            }
            // remove leading HRs
            for (var _a = 0, sectionsOrHr_2 = sectionsOrHr; _a < sectionsOrHr_2.length; _a++) {
                var sectionOrHr = sectionsOrHr_2[_a];
                if (isHr(sectionOrHr)) {
                    sectionOrHr.style.display = "none";
                }
                else if (isVisible(sectionOrHr)) {
                    break;
                }
            }
            // remove trailing HRs
            for (var i = sectionsOrHr.length - 1; i >= 0; i--) {
                var sectionOrHr = sectionsOrHr[i];
                if (isHr(sectionOrHr)) {
                    sectionOrHr.style.display = "none";
                }
                else if (isVisible(sectionOrHr)) {
                    break;
                }
            }
        }
        function setVisibility(id, visible) {
            var section = getElementBySelector("section#section-" + id);
            if (section && section.parentElement) {
                section.style.display = visible ? "" : "none";
                reevaluateSeparatorsVisibility(section.parentElement);
            }
        }
        Sections.setVisibility = setVisibility;
    })(Sections = Page.Sections || (Page.Sections = {}));
})(Page || (Page = {}));


var Page;
(function (Page) {
    var Range;
    (function (Range_1) {
        var Range = /** @class */ (function () {
            function Range(container) {
                var _this = this;
                this.onInputObservers = [];
                this.onChangeObservers = [];
                this.inputElement = Page.Helpers.Utils.selector(container, "input[type='range']");
                this.progressLeftElement = Page.Helpers.Utils.selector(container, ".range-progress-left");
                this.tooltipElement = Page.Helpers.Utils.selector(container, "output.range-tooltip");
                this.id = this.inputElement.id;
                var inputMin = +this.inputElement.min;
                var inputMax = +this.inputElement.max;
                var inputStep = +this.inputElement.step;
                this.nbDecimalsToDisplay = Range.getMaxNbDecimals(inputMin, inputMax, inputStep);
                this.inputElement.addEventListener("input", function (event) {
                    event.stopPropagation();
                    _this.reloadValue();
                    _this.callSpecificObservers(_this.onInputObservers);
                });
                this.inputElement.addEventListener("change", function (event) {
                    event.stopPropagation();
                    _this.reloadValue();
                    rangesStorage.storeState(_this);
                    _this.callSpecificObservers(_this.onChangeObservers);
                });
                this.reloadValue();
            }
            Object.defineProperty(Range.prototype, "value", {
                get: function () {
                    return this._value;
                },
                set: function (newValue) {
                    this.inputElement.value = "" + newValue;
                    this.reloadValue();
                },
                enumerable: false,
                configurable: true
            });
            Range.prototype.callObservers = function () {
                this.callSpecificObservers(this.onInputObservers);
                this.callSpecificObservers(this.onChangeObservers);
            };
            Range.prototype.callSpecificObservers = function (observers) {
                for (var _i = 0, observers_1 = observers; _i < observers_1.length; _i++) {
                    var observer = observers_1[_i];
                    observer(this.value);
                }
            };
            Range.prototype.updateAppearance = function () {
                var currentLength = +this.inputElement.value - +this.inputElement.min;
                var totalLength = +this.inputElement.max - +this.inputElement.min;
                var progression = currentLength / totalLength;
                progression = Math.max(0, Math.min(1, progression));
                this.progressLeftElement.style.width = (100 * progression) + "%";
                var text;
                if (this.nbDecimalsToDisplay < 0) {
                    text = this.inputElement.value;
                }
                else {
                    text = (+this.inputElement.value).toFixed(this.nbDecimalsToDisplay);
                }
                this.tooltipElement.textContent = text;
            };
            Range.prototype.reloadValue = function () {
                this._value = +this.inputElement.value;
                this.updateAppearance();
            };
            Range.getMaxNbDecimals = function () {
                var numbers = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    numbers[_i] = arguments[_i];
                }
                var nbDecimals = -1;
                for (var _a = 0, numbers_1 = numbers; _a < numbers_1.length; _a++) {
                    var n = numbers_1[_a];
                    var local = Range.nbDecimals(n);
                    if (n < 0) {
                        return -1;
                    }
                    else if (nbDecimals < local) {
                        nbDecimals = local;
                    }
                }
                return nbDecimals;
            };
            Range.nbDecimals = function (x) {
                var xAsString = x.toString();
                if (/^[0-9]+$/.test(xAsString)) {
                    return 0;
                }
                else if (/^[0-9]+\.[0-9]+$/.test(xAsString)) {
                    return xAsString.length - (xAsString.indexOf(".") + 1);
                }
                return -1; // failed to parse
            };
            return Range;
        }());
        var rangesCache = new Page.Helpers.Cache("Range", function () {
            var selector = ".range-container > input[type='range']";
            var rangeElements = Page.Helpers.Utils.selectorAll(document, selector);
            return rangeElements.map(function (rangeElement) {
                var container = rangeElement.parentElement;
                return new Range(container);
            });
        });
        var rangesStorage = new Page.Helpers.Storage("range", function (range) {
            return "" + range.value;
        }, function (id, serializedValue) {
            var range = rangesCache.getByIdSafe(id);
            if (range) {
                range.value = +serializedValue;
                range.callObservers();
                return true;
            }
            return false;
        });
        Page.Helpers.Events.callAfterDOMLoaded(function () {
            rangesCache.load();
            rangesStorage.applyStoredState();
        });
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var isIE11 = !!window.MSInputMethodContext && !!document.documentMode;
        function addObserver(rangeId, observer) {
            var range = rangesCache.getById(rangeId);
            if (isIE11) { // bug in IE 11, input event is never fired
                range.onChangeObservers.push(observer);
            }
            else {
                range.onInputObservers.push(observer);
            }
        }
        Range_1.addObserver = addObserver;
        /**
         * Callback will be called only when the value stops changing.
         */
        function addLazyObserver(rangeId, observer) {
            var range = rangesCache.getById(rangeId);
            range.onChangeObservers.push(observer);
        }
        Range_1.addLazyObserver = addLazyObserver;
        function getValue(rangeId) {
            var range = rangesCache.getById(rangeId);
            return range.value;
        }
        Range_1.getValue = getValue;
        function setValue(rangeId, value) {
            var range = rangesCache.getById(rangeId);
            range.value = value;
        }
        Range_1.setValue = setValue;
        function storeState(rangeId) {
            var range = rangesCache.getById(rangeId);
            rangesStorage.storeState(range);
        }
        Range_1.storeState = storeState;
        function clearStoredState(rangeId) {
            var range = rangesCache.getById(rangeId);
            rangesStorage.clearStoredState(range);
        }
        Range_1.clearStoredState = clearStoredState;
    })(Range = Page.Range || (Page.Range = {}));
})(Page || (Page = {}));


var Page;
(function (Page) {
    var Checkbox;
    (function (Checkbox_1) {
        var Checkbox = /** @class */ (function () {
            function Checkbox(element) {
                var _this = this;
                this.observers = [];
                this.id = element.id;
                this.element = element;
                this.reloadValue();
                this.element.addEventListener("change", function () {
                    _this.reloadValue();
                    checkboxesStorage.storeState(_this);
                    _this.callObservers();
                });
            }
            Object.defineProperty(Checkbox.prototype, "checked", {
                get: function () {
                    return this._checked;
                },
                set: function (newChecked) {
                    this.element.checked = newChecked;
                    this.reloadValue();
                },
                enumerable: false,
                configurable: true
            });
            Checkbox.prototype.callObservers = function () {
                for (var _i = 0, _a = this.observers; _i < _a.length; _i++) {
                    var observer = _a[_i];
                    observer(this.checked);
                }
            };
            Checkbox.prototype.reloadValue = function () {
                this._checked = this.element.checked;
            };
            return Checkbox;
        }());
        var checkboxesCache = new Page.Helpers.Cache("Checkbox", function () {
            var selector = "div.checkbox > input[type=checkbox][id]";
            var elements = Page.Helpers.Utils.selectorAll(document, selector);
            return elements.map(function (element) {
                return new Checkbox(element);
            });
        });
        var checkboxesStorage = new Page.Helpers.Storage("checkbox", function (checkbox) {
            return checkbox.checked ? "true" : "false";
        }, function (id, serializedValue) {
            var checkbox = checkboxesCache.getByIdSafe(id);
            if (checkbox && (serializedValue === "true" || serializedValue === "false")) {
                checkbox.checked = (serializedValue === "true");
                checkbox.callObservers();
                return true;
            }
            return false;
        });
        Page.Helpers.Events.callAfterDOMLoaded(function () {
            checkboxesCache.load();
            checkboxesStorage.applyStoredState();
        });
        function addObserver(checkboxId, observer) {
            var checkbox = checkboxesCache.getById(checkboxId);
            checkbox.observers.push(observer);
        }
        Checkbox_1.addObserver = addObserver;
        function setChecked(checkboxId, value) {
            var checkbox = checkboxesCache.getById(checkboxId);
            checkbox.checked = value;
        }
        Checkbox_1.setChecked = setChecked;
        function isChecked(checkboxId) {
            var checkbox = checkboxesCache.getById(checkboxId);
            return checkbox.checked;
        }
        Checkbox_1.isChecked = isChecked;
        function storeState(checkboxId) {
            var checkbox = checkboxesCache.getById(checkboxId);
            checkboxesStorage.storeState(checkbox);
        }
        Checkbox_1.storeState = storeState;
        function clearStoredState(checkboxId) {
            var checkbox = checkboxesCache.getById(checkboxId);
            checkboxesStorage.clearStoredState(checkbox);
        }
        Checkbox_1.clearStoredState = clearStoredState;
    })(Checkbox = Page.Checkbox || (Page.Checkbox = {}));
})(Page || (Page = {}));

var Page;
(function (Page) {
    var Button;
    (function (Button_1) {
        var Button = /** @class */ (function () {
            function Button(element) {
                var _this = this;
                this.observers = [];
                this.id = element.id;
                this.element = element;
                this.element.addEventListener("click", function (event) {
                    event.stopPropagation();
                    for (var _i = 0, _a = _this.observers; _i < _a.length; _i++) {
                        var observer = _a[_i];
                        observer();
                    }
                }, false);
            }
            Object.defineProperty(Button.prototype, "label", {
                set: function (newLabel) {
                    this.element.innerText = newLabel;
                },
                enumerable: false,
                configurable: true
            });
            return Button;
        }());
        var buttonsCache = new Page.Helpers.Cache("Button", function () {
            var elements = Page.Helpers.Utils.selectorAll(document, "button[id]");
            return elements.map(function (element) {
                return new Button(element);
            });
        });
        function addObserver(buttonId, observer) {
            var button = buttonsCache.getById(buttonId);
            button.observers.push(observer);
        }
        Button_1.addObserver = addObserver;
        function setLabel(buttonId, label) {
            var button = buttonsCache.getById(buttonId);
            button.label = label;
        }
        Button_1.setLabel = setLabel;
    })(Button = Page.Button || (Page.Button = {}));
})(Page || (Page = {}));


var Page;
(function (Page) {
    var Select;
    (function (Select_1) {
        var Select = /** @class */ (function () {
            function Select(container) {
                var _this = this;
                this.observers = [];
                this.id = container.id;
                this.containerElement = container;
                this.currentValueElement = Page.Helpers.Utils.selector(container, ".select-current-value");
                this.valuesListElement = Page.Helpers.Utils.selector(container, ".select-values-list");
                this.placeholder = this.valuesListElement.dataset["placeholder"] || "";
                this.currentValue = this.currentValueElement.dataset["value"] || null;
                this.valueElements = [];
                var elements = this.valuesListElement.querySelectorAll(".select-value[data-value]");
                for (var i = 0; i < elements.length; i++) {
                    this.valueElements.push(elements[i]);
                }
                this.containerElement.style.width = "".concat(this.computeMinimumWidth(), "px");
                document.addEventListener("click", function (event) {
                    var clickedElement = event.target;
                    var isExpanded = _this.containerElement.classList.contains(Select.EXPANDED_CLASS);
                    if (isExpanded) {
                        var clickedOnValuesList = _this.valuesListElement.contains(clickedElement);
                        if (clickedOnValuesList) {
                            for (var _i = 0, _a = _this.valueElements; _i < _a.length; _i++) {
                                var valueElement = _a[_i];
                                if (valueElement.contains(clickedElement)) {
                                    _this.currentValue = valueElement.dataset["value"] || null;
                                    _this.currentValueElement.dataset["value"] = _this.currentValue || undefined;
                                    _this.currentValueElement.textContent = valueElement.textContent;
                                    selectStorage.storeState(_this);
                                    _this.callObservers();
                                }
                            }
                        }
                        _this.containerElement.classList.remove(Select.EXPANDED_CLASS);
                    }
                    else {
                        var clickedOnCurrentValue = _this.currentValueElement.contains(clickedElement);
                        if (clickedOnCurrentValue) {
                            _this.containerElement.classList.add(Select.EXPANDED_CLASS);
                        }
                    }
                });
            }
            Object.defineProperty(Select.prototype, "value", {
                get: function () {
                    return this.currentValue || null;
                },
                set: function (v) {
                    if (v === null) {
                        this.currentValueElement.removeAttribute("data-value");
                        this.currentValueElement.textContent = this.placeholder;
                        this.currentValue = null;
                    }
                    else {
                        for (var _i = 0, _a = this.valueElements; _i < _a.length; _i++) {
                            var valueElement = _a[_i];
                            var valueFromHtml = valueElement.dataset["value"];
                            if (valueFromHtml === v) {
                                this.currentValue = valueFromHtml;
                                this.currentValueElement.dataset["value"] = valueFromHtml;
                                this.currentValueElement.textContent = valueElement.textContent;
                                return;
                            }
                        }
                        console.log("No \"".concat(v, "\" value for \"").concat(this.id, "\" select."));
                    }
                },
                enumerable: false,
                configurable: true
            });
            Select.prototype.callObservers = function () {
                for (var _i = 0, _a = this.observers; _i < _a.length; _i++) {
                    var observer = _a[_i];
                    observer(this.value);
                }
            };
            Select.prototype.computeMinimumWidth = function () {
                var result = 0;
                this.valuesListElement.style.opacity = "0";
                this.valuesListElement.style.width = "auto";
                this.valuesListElement.style.fontWeight = "bold";
                this.valuesListElement.style.display = "block";
                var placeholderValue = document.createElement("div");
                placeholderValue.classList.add("select-value");
                placeholderValue.textContent = this.placeholder;
                this.valuesListElement.appendChild(placeholderValue);
                var parentNode = this.containerElement.parentNode;
                if (!parentNode) {
                    throw new Error("Select in not attached");
                }
                var nextSiblingNode = this.containerElement.nextSibling;
                parentNode.removeChild(this.containerElement);
                document.body.appendChild(this.containerElement);
                result = this.valuesListElement.getBoundingClientRect().width;
                document.body.removeChild(this.containerElement);
                parentNode.insertBefore(this.containerElement, nextSiblingNode);
                this.valuesListElement.removeChild(placeholderValue);
                this.valuesListElement.style.display = "";
                this.valuesListElement.style.fontWeight = "";
                this.valuesListElement.style.width = "";
                this.valuesListElement.style.opacity = "";
                var MARGIN = 30;
                return result + MARGIN;
            };
            Select.EXPANDED_CLASS = "expanded";
            return Select;
        }());
        var selectsCache = new Page.Helpers.Cache("Select", function () {
            var containerElements = Page.Helpers.Utils.selectorAll(document, ".select-container[id]");
            return containerElements.map(function (containerElement) {
                return new Select(containerElement);
            });
        });
        var selectStorage = new Page.Helpers.Storage("select", function (select) {
            return select.value;
        }, function (id, serializedValue) {
            var select = selectsCache.getByIdSafe(id);
            if (select) {
                select.value = serializedValue;
                select.callObservers();
                return true;
            }
            return false;
        });
        Page.Helpers.Events.callAfterDOMLoaded(function () {
            selectsCache.load();
            selectStorage.applyStoredState();
        });
        function addObserver(id, observer) {
            var select = selectsCache.getById(id);
            select.observers.push(observer);
        }
        Select_1.addObserver = addObserver;
        function getValue(id) {
            var select = selectsCache.getById(id);
            return select.value;
        }
        Select_1.getValue = getValue;
        function setValue(id, value) {
            var select = selectsCache.getById(id);
            select.value = value;
        }
        Select_1.setValue = setValue;
        function storeState(id) {
            var select = selectsCache.getById(id);
            selectStorage.storeState(select);
        }
        Select_1.storeState = storeState;
        function clearStoredState(id) {
            var select = selectsCache.getById(id);
            selectStorage.clearStoredState(select);
        }
        Select_1.clearStoredState = clearStoredState;
    })(Select = Page.Select || (Page.Select = {}));
})(Page || (Page = {}));


var Page;
(function (Page) {
    var Tabs;
    (function (Tabs_1) {
        var Tabs = /** @class */ (function () {
            function Tabs(container) {
                var _this = this;
                this.observers = [];
                this.id = Tabs.computeShortId(container.id);
                this.inputElements = [];
                var inputElements = Page.Helpers.Utils.selectorAll(container, "input");
                for (var _i = 0, inputElements_1 = inputElements; _i < inputElements_1.length; _i++) {
                    var inputElement = inputElements_1[_i];
                    this.inputElements.push(inputElement);
                    inputElement.addEventListener("change", function (event) {
                        event.stopPropagation();
                        _this.reloadValues();
                        tabsStorage.storeState(_this);
                        _this.callObservers();
                    }, false);
                }
                this.reloadValues();
            }
            Tabs.computeShortId = function (fullId) {
                if (fullId.lastIndexOf(Tabs.ID_SUFFIX) != fullId.length - Tabs.ID_SUFFIX.length) {
                    throw new Error("Invalid tabs container id: '" + fullId + "'.");
                }
                return fullId.substring(0, fullId.length - Tabs.ID_SUFFIX.length);
            };
            Object.defineProperty(Tabs.prototype, "values", {
                get: function () {
                    return this._values;
                },
                set: function (newValues) {
                    for (var _i = 0, _a = this.inputElements; _i < _a.length; _i++) {
                        var inputElement = _a[_i];
                        var isWanted = false;
                        for (var _b = 0, newValues_1 = newValues; _b < newValues_1.length; _b++) {
                            var newValue = newValues_1[_b];
                            if (inputElement.value === newValue) {
                                isWanted = true;
                                break;
                            }
                        }
                        inputElement.checked = isWanted;
                    }
                    this.reloadValues();
                },
                enumerable: false,
                configurable: true
            });
            Tabs.prototype.callObservers = function () {
                for (var _i = 0, _a = this.observers; _i < _a.length; _i++) {
                    var observer = _a[_i];
                    observer(this._values);
                }
            };
            Tabs.prototype.reloadValues = function () {
                var values = [];
                for (var _i = 0, _a = this.inputElements; _i < _a.length; _i++) {
                    var inputElement = _a[_i];
                    if (inputElement.checked) {
                        values.push(inputElement.value);
                    }
                }
                this._values = values;
            };
            Tabs.ID_SUFFIX = "-id";
            return Tabs;
        }());
        var tabsCache = new Page.Helpers.Cache("Tabs", function () {
            var containerElements = Page.Helpers.Utils.selectorAll(document, "div.tabs[id]");
            return containerElements.map(function (containerElement) {
                return new Tabs(containerElement);
            });
        });
        var tabsStorage = new Page.Helpers.Storage("tabs", function (tabs) {
            var valuesList = tabs.values;
            return valuesList.join(";");
        }, function (id, serializedValue) {
            var values = serializedValue.split(";");
            var tabs = tabsCache.getByIdSafe(id);
            if (tabs) {
                tabs.values = values;
                tabs.callObservers();
                return true;
            }
            return false;
        });
        Page.Helpers.Events.callAfterDOMLoaded(function () {
            tabsCache.load();
            tabsStorage.applyStoredState();
        });
        function addObserver(tabsId, observer) {
            var tabs = tabsCache.getById(tabsId);
            tabs.observers.push(observer);
        }
        Tabs_1.addObserver = addObserver;
        function getValues(tabsId) {
            var tabs = tabsCache.getById(tabsId);
            return tabs.values;
        }
        Tabs_1.getValues = getValues;
        function setValues(tabsId, values, updateURLStorage) {
            if (updateURLStorage === void 0) { updateURLStorage = false; }
            var tabs = tabsCache.getById(tabsId);
            tabs.values = values;
            if (updateURLStorage) {
                tabsStorage.storeState(tabs);
            }
        }
        Tabs_1.setValues = setValues;
        function storeState(tabsId) {
            var tabs = tabsCache.getById(tabsId);
            tabsStorage.storeState(tabs);
        }
        Tabs_1.storeState = storeState;
        function clearStoredState(tabsIdd) {
            var tabs = tabsCache.getById(tabsIdd);
            tabsStorage.clearStoredState(tabs);
        }
        Tabs_1.clearStoredState = clearStoredState;
    })(Tabs = Page.Tabs || (Page.Tabs = {}));
})(Page || (Page = {}));


var Page;
(function (Page) {
    var ColorPicker;
    (function (ColorPicker_1) {
        function clamp(value, min, max) {
            return Math.max(min, Math.min(max, value));
        }
        function roundAndClamp(value, min, max) {
            var rounded = Math.round(value);
            return clamp(rounded, min, max);
        }
        function positiveModulus(a, b) {
            return ((a % b) + b) % b;
        }
        var ColorSpace;
        (function (ColorSpace) {
            function parseHexa(value) {
                if (/^#[0-9a-fA-F]{6}$/.test(value)) {
                    return value.toUpperCase();
                }
                return null;
            }
            ColorSpace.parseHexa = parseHexa;
            function hsvToRgb(hsv) {
                var h2 = hsv.h / 60;
                var c = hsv.s * hsv.v;
                var x = c * (1 - Math.abs(positiveModulus(h2, 2) - 1));
                var rgb;
                if (h2 <= 1) {
                    rgb = { r: c, g: x, b: 0 };
                }
                else if (h2 <= 2) {
                    rgb = { r: x, g: c, b: 0 };
                }
                else if (h2 <= 3) {
                    rgb = { r: 0, g: c, b: x };
                }
                else if (h2 <= 4) {
                    rgb = { r: 0, g: x, b: c };
                }
                else if (h2 <= 5) {
                    rgb = { r: x, g: 0, b: c };
                }
                else {
                    rgb = { r: c, g: 0, b: x };
                }
                var m = hsv.v - c;
                rgb.r = roundAndClamp((rgb.r + m) * 255, 0, 255);
                rgb.g = roundAndClamp((rgb.g + m) * 255, 0, 255);
                rgb.b = roundAndClamp((rgb.b + m) * 255, 0, 255);
                return rgb;
            }
            ColorSpace.hsvToRgb = hsvToRgb;
            function rgbToHsv(rgb) {
                var nr = rgb.r / 255;
                var ng = rgb.g / 255;
                var nb = rgb.b / 255;
                var cmax = Math.max(nr, ng, nb);
                var cmin = Math.min(nr, ng, nb);
                var delta = cmax - cmin;
                var result = { h: 0, s: 0, v: cmax };
                if (delta !== 0) {
                    if (cmax === nr) {
                        result.h = 60 * (((ng - nb) / delta) % 6);
                    }
                    else if (cmax === ng) {
                        result.h = 60 * (((nb - nr) / delta) + 2);
                    }
                    else if (cmax === nb) {
                        result.h = 60 * (((nr - ng) / delta) + 4);
                    }
                }
                if (cmax !== 0) {
                    result.s = delta / cmax;
                }
                result.h = positiveModulus(result.h, 360);
                return result;
            }
            ColorSpace.rgbToHsv = rgbToHsv;
            function rgbToHex(rgb) {
                return "#" + charToHex(rgb.r) + charToHex(rgb.g) + charToHex(rgb.b);
            }
            ColorSpace.rgbToHex = rgbToHex;
            function hexToRgb(hex) {
                return {
                    r: parseInt(hex.substring(1, 3), 16),
                    g: parseInt(hex.substring(3, 5), 16),
                    b: parseInt(hex.substring(5, 7), 16),
                };
            }
            ColorSpace.hexToRgb = hexToRgb;
            function charToHex(value) {
                var hex = value.toString(16).toUpperCase();
                return hex.length === 2 ? hex : "0" + hex;
            }
        })(ColorSpace || (ColorSpace = {}));
        var ColorPicker = /** @class */ (function () {
            function ColorPicker(element) {
                var _this = this;
                this.observers = [];
                this.element = element;
                this.id = element.id;
                this.colorPreview = element.querySelector(".color-preview");
                this.colorPreviewText = element.querySelector(".color-value");
                this.updateVisiblePart();
                this.element.addEventListener("click", function () {
                    Popup.assignPopup(_this);
                });
            }
            Object.defineProperty(ColorPicker.prototype, "value", {
                get: function () {
                    var fromDataset = this.element.dataset["currentColor"];
                    if (!fromDataset) {
                        throw new Error("No current color on ColorPicker '".concat(this.id, "'."));
                    }
                    return fromDataset;
                },
                set: function (newValue) {
                    var previousValue = this.value;
                    if (previousValue !== newValue) {
                        this.element.dataset["currentColor"] = newValue;
                        this.updateVisiblePart();
                        var rgb = ColorSpace.hexToRgb(newValue);
                        for (var _i = 0, _a = this.observers; _i < _a.length; _i++) {
                            var observer = _a[_i];
                            observer(rgb);
                        }
                    }
                },
                enumerable: false,
                configurable: true
            });
            ColorPicker.prototype.attachPopup = function (popup) {
                var parentElement = this.element.parentElement;
                if (!parentElement) {
                    throw new Error("ColorPicker '".concat(this.id, "' is not attached."));
                }
                parentElement.appendChild(popup);
            };
            ColorPicker.prototype.updateVisiblePart = function () {
                var hexValue = this.value;
                this.colorPreview.style.background = hexValue;
                this.colorPreviewText.textContent = hexValue;
            };
            return ColorPicker;
        }());
        var colorPickersCache = new Page.Helpers.Cache("ColorPicker", function () {
            var containers = Page.Helpers.Utils.selectorAll(document, ".color-picker[id]");
            return containers.map(function (container) {
                return new ColorPicker(container);
            });
        });
        var colorPickersStorage = new Page.Helpers.Storage("color-picker", function (colorPicker) {
            return colorPicker.value;
        }, function (id, serializedValue) {
            var colorPicker = colorPickersCache.getByIdSafe(id);
            var hexValue = ColorSpace.parseHexa(serializedValue);
            if (colorPicker && hexValue) {
                colorPicker.value = hexValue;
                return true;
            }
            return false;
        });
        var Popup = /** @class */ (function () {
            function Popup() {
                var _this = this;
                this.hsv = { h: 200, s: 0.75, v: 0.5 };
                this.popupElement = Popup.buildElement("div", ["popup", "color-picker-popup"]);
                {
                    this.valueSaturationPicker = Popup.buildElement("div", ["block", "picker", "value-saturation-picker"]);
                    this.hueColorFilter = Popup.buildElement("span", ["color-filter", "outlined"]);
                    this.valueSaturationPicker.appendChild(this.hueColorFilter);
                    var valueColorFilter = Popup.buildElement("span", ["color-filter", "outlined"]);
                    valueColorFilter.style.background = "linear-gradient(to top, black, rgba(0,0,0,0))";
                    this.valueSaturationPicker.appendChild(valueColorFilter);
                    this.valueSaturationCursor = Popup.buildElement("span", ["cursor"]);
                    this.valueSaturationPicker.appendChild(this.valueSaturationCursor);
                    this.popupElement.appendChild(this.valueSaturationPicker);
                }
                {
                    this.huePicker = Popup.buildElement("div", ["block", "picker", "hue-picker"]);
                    var hueBar = Popup.buildElement("span", ["hue-bar"]);
                    this.huePicker.appendChild(hueBar);
                    this.hueCursor = Popup.buildElement("span", ["cursor"]);
                    this.huePicker.appendChild(this.hueCursor);
                    this.popupElement.appendChild(this.huePicker);
                }
                {
                    var previewBlock = Popup.buildElement("div", ["preview-block"]);
                    this.previewColor = Popup.buildElement("div", ["preview-color", "outlined"]);
                    this.previewColor.classList.add("block");
                    previewBlock.appendChild(this.previewColor);
                    {
                        var previewText = Popup.buildElement("table", ["block"]);
                        var hexaContainer = Popup.buildPreviewText(previewText, "hexa");
                        var hash = Popup.buildElement("span");
                        hash.textContent = "#";
                        hexaContainer.appendChild(hash);
                        this.previewHexaValue = document.createElement("input");
                        this.previewHexaValue.type = "text";
                        this.previewHexaValue.minLength = 6;
                        this.previewHexaValue.maxLength = 6;
                        this.previewHexaValue.size = 6;
                        this.previewHexaValue.pattern = "[0-9a-fA-F]{6}";
                        this.previewHexaValue.addEventListener("input", function () {
                            var newValue = "#" + _this.previewHexaValue.value;
                            var newHexa = ColorSpace.parseHexa(newValue);
                            if (newHexa) { // valid input
                                var newRgb = ColorSpace.hexToRgb(newValue);
                                var newHsl = ColorSpace.rgbToHsv(newRgb);
                                _this.hsv.h = newHsl.h;
                                _this.hsv.s = newHsl.s;
                                _this.hsv.v = newHsl.v;
                                _this.onInput();
                            }
                        });
                        hexaContainer.appendChild(this.previewHexaValue);
                        this.previewRgbValue = Popup.buildPreviewText(previewText, "rgb");
                        this.previewHslValue = Popup.buildPreviewText(previewText, "hsv");
                        previewBlock.appendChild(previewText);
                    }
                    this.popupElement.appendChild(previewBlock);
                }
                this.registerCursorEvent(this.huePicker, function (coords) {
                    _this.hsv.h = roundAndClamp(360 * coords.x, 0, 360);
                    _this.onInput();
                });
                this.registerCursorEvent(this.valueSaturationPicker, function (coords) {
                    _this.hsv.s = clamp(coords.x, 0, 1);
                    _this.hsv.v = clamp(1 - coords.y, 0, 1);
                    _this.onInput();
                    // retain exact position because rebuilding it from color is not exact
                    _this.valueSaturationCursor.style.left = Popup.percentageString(coords.x);
                    _this.valueSaturationCursor.style.top = Popup.percentageString(coords.y);
                });
                var isActive = false;
                this.popupElement.addEventListener("mousedown", function setActive() {
                    isActive = true;
                });
                window.addEventListener("mouseup", function (event) {
                    var clickedOutOfPopup = !_this.popupElement.contains(event.target);
                    if (clickedOutOfPopup && _this.popupElement.parentElement && !isActive) {
                        _this.popupElement.parentElement.removeChild(_this.popupElement);
                    }
                    isActive = false;
                });
            }
            Popup.assignPopup = function (colorPicker) {
                if (!Popup.popup) {
                    Popup.popup = new Popup();
                }
                Popup.popup.attach(colorPicker);
            };
            Popup.prototype.updateAppearance = function () {
                var rgb = ColorSpace.hsvToRgb(this.hsv);
                var hexString = ColorSpace.rgbToHex(rgb);
                var rgbString = "rgb(".concat(rgb.r, ", ").concat(rgb.g, ", ").concat(rgb.b, ")"); // real coor
                var hslString = "hsl(".concat(Math.round(this.hsv.h), ", 100%, 50%)"); // pure color
                // colors
                this.hueColorFilter.style.background = "linear-gradient(to right, white, ".concat(hslString, ")");
                this.hueCursor.style.background = hslString;
                this.valueSaturationCursor.style.background = rgbString;
                this.previewColor.style.background = rgbString;
                // text
                this.previewHexaValue.value = hexString.substring(1);
                this.previewRgbValue.textContent = "".concat(rgb.r, ", ").concat(rgb.g, ", ").concat(rgb.b);
                var percentSaturation = Popup.percentageString(this.hsv.s);
                var percentValue = Popup.percentageString(this.hsv.v);
                this.previewHslValue.textContent = "".concat(Math.round(this.hsv.h), "\u00B0, ").concat(percentSaturation, ", ").concat(percentValue);
                // cursors positions
                this.hueCursor.style.left = Popup.percentageString(this.hsv.h / 360);
                this.valueSaturationCursor.style.left = percentSaturation;
                this.valueSaturationCursor.style.top = Popup.percentageString(1 - this.hsv.v);
            };
            Popup.prototype.onInput = function () {
                var rgb = ColorSpace.hsvToRgb(this.hsv);
                var hexString = ColorSpace.rgbToHex(rgb);
                this.updateAppearance();
                if (this.currentControl) {
                    this.currentControl.value = hexString;
                }
                colorPickersStorage.storeState(this.currentControl);
            };
            Popup.prototype.attach = function (colorPicker) {
                this.currentControl = colorPicker;
                var currentHex = colorPicker.value;
                var currentRgb = ColorSpace.hexToRgb(currentHex);
                var currentHsv = ColorSpace.rgbToHsv(currentRgb);
                Popup.popup.hsv.h = currentHsv.h;
                Popup.popup.hsv.v = currentHsv.v;
                Popup.popup.hsv.s = currentHsv.s;
                Popup.popup.updateAppearance();
                // reset placement to avoid flickering due to the popup being temporarily out of screen
                this.popupElement.style.top = "";
                this.popupElement.style.left = "";
                this.currentControl.attachPopup(this.popupElement);
                this.fitPopupToContainer();
            };
            Popup.prototype.fitPopupToContainer = function () {
                if (this.popupElement.parentElement) {
                    var container = document.querySelector(".controls-block") || document.body;
                    var containerBox = container.getBoundingClientRect();
                    var margin = 16;
                    var containerRight = containerBox.left + containerBox.width - margin;
                    var containerBottom = containerBox.top + containerBox.height - margin;
                    this.popupElement.style.maxWidth = (containerBox.width - 2 * margin) + "px";
                    this.popupElement.style.maxHeight = (containerBox.height - 2 * margin) + "px";
                    var parentBox = this.popupElement.parentElement.getBoundingClientRect();
                    var popupBox = this.popupElement.getBoundingClientRect();
                    var leftOffset = Math.max(0, (containerBox.left + margin) - parentBox.left);
                    var rightOffset = Math.min(0, containerRight - (parentBox.left + popupBox.width));
                    var topOffset = Math.max(0, (containerBox.top + margin) - parentBox.top);
                    var bottomOffset = Math.min(0, containerBottom - (parentBox.top + popupBox.height));
                    this.popupElement.style.left = (leftOffset + rightOffset) + "px";
                    this.popupElement.style.top = (topOffset + bottomOffset) + "px";
                }
            };
            Popup.prototype.registerCursorEvent = function (container, callback) {
                function absoluteToRelative(clientX, clientY) {
                    var containerBox = container.getBoundingClientRect();
                    var relativeX = (clientX - containerBox.left) / containerBox.width;
                    var relativeY = (clientY - containerBox.top) / containerBox.height;
                    return {
                        x: Math.max(0, Math.min(1, relativeX)),
                        y: Math.max(0, Math.min(1, relativeY)),
                    };
                }
                var cursor = container.querySelector(".cursor");
                var handleOffset = { x: 0, y: 0 };
                var isBeingDragged = false;
                container.addEventListener("mousedown", function onMouseDown(event) {
                    isBeingDragged = true;
                    handleOffset.x = 0;
                    handleOffset.y = 0;
                    if (cursor && event.target === cursor) {
                        var cursorBox = cursor.getBoundingClientRect();
                        handleOffset.x = 0.5 * cursorBox.width - (event.clientX - cursorBox.left);
                        handleOffset.y = 0.5 * cursorBox.height - (event.clientY - cursorBox.top);
                    }
                    else {
                        var coords = absoluteToRelative(event.clientX, event.clientY);
                        callback(coords);
                    }
                });
                window.addEventListener("mouseup", function onMouseUp() {
                    isBeingDragged = false;
                });
                window.addEventListener("mousemove", function onMouseMove(event) {
                    if (isBeingDragged) {
                        var coords = absoluteToRelative(event.clientX + handleOffset.x, event.clientY + handleOffset.y);
                        callback(coords);
                    }
                });
                var currentTouchIds = [];
                container.addEventListener("touchstart", function onTouchStart(event) {
                    isBeingDragged = true;
                    var isFirstTouch = (currentTouchIds.length === 0);
                    var changedTouches = Page.Helpers.Utils.touchArray(event.changedTouches);
                    for (var _i = 0, changedTouches_1 = changedTouches; _i < changedTouches_1.length; _i++) {
                        var touch = changedTouches_1[_i];
                        var alreadyRegistered = false;
                        for (var _a = 0, currentTouchIds_1 = currentTouchIds; _a < currentTouchIds_1.length; _a++) {
                            var knownTouchId = currentTouchIds_1[_a];
                            if (touch.identifier === knownTouchId) {
                                alreadyRegistered = true;
                                break;
                            }
                        }
                        if (!alreadyRegistered) {
                            currentTouchIds.push(touch.identifier);
                        }
                    }
                    if (isFirstTouch && currentTouchIds.length > 0) {
                        var changedTouch = changedTouches[0];
                        if (!changedTouch) {
                            console.error("Should not happen: ColorPicker missed first touch.");
                        }
                        else {
                            var coords = absoluteToRelative(changedTouch.clientX, changedTouch.clientY);
                            callback(coords);
                        }
                    }
                }, false);
                window.addEventListener("touchend", function onTouchEnd(event) {
                    var knewAtLeastOneTouch = (currentTouchIds.length > 0);
                    var changedTouches = Page.Helpers.Utils.touchArray(event.changedTouches);
                    for (var _i = 0, changedTouches_2 = changedTouches; _i < changedTouches_2.length; _i++) {
                        var touch = changedTouches_2[_i];
                        for (var iC = 0; iC < currentTouchIds.length; ++iC) {
                            if (touch.identifier === currentTouchIds[iC]) {
                                currentTouchIds.splice(iC, 1);
                                iC--;
                            }
                        }
                    }
                    if (knewAtLeastOneTouch && currentTouchIds.length === 0) {
                        isBeingDragged = false;
                    }
                });
                window.addEventListener("touchmove", function onTouchMove(event) {
                    if (currentTouchIds.length > 0 && isBeingDragged) {
                        var touches = Page.Helpers.Utils.touchArray(event.changedTouches);
                        for (var _i = 0, touches_1 = touches; _i < touches_1.length; _i++) {
                            var touch = touches_1[_i];
                            for (var _a = 0, currentTouchIds_2 = currentTouchIds; _a < currentTouchIds_2.length; _a++) {
                                var knownTouch = currentTouchIds_2[_a];
                                if (touch.identifier === knownTouch) {
                                    var coords = absoluteToRelative(touch.clientX, touch.clientY);
                                    callback(coords);
                                    event.preventDefault();
                                    return;
                                }
                            }
                        }
                    }
                }, { passive: false });
            };
            Popup.buildElement = function (tagname, classList) {
                var element = document.createElement(tagname);
                if (classList) {
                    element.className = classList.join(" ");
                }
                return element;
            };
            Popup.buildPreviewText = function (container, name) {
                var row = document.createElement("tr");
                var nameSpan = document.createElement("td");
                nameSpan.textContent = name + ":";
                var valueSpan = document.createElement("td");
                row.appendChild(nameSpan);
                row.appendChild(valueSpan);
                container.appendChild(row);
                return valueSpan;
            };
            Popup.percentageString = function (value) {
                return Math.round(100 * value) + "%";
            };
            return Popup;
        }());
        Page.Helpers.Events.callAfterDOMLoaded(function () {
            colorPickersCache.load();
            colorPickersStorage.applyStoredState();
        });
        function addObserver(id, observer) {
            var colorPicker = colorPickersCache.getById(id);
            colorPicker.observers.push(observer);
        }
        ColorPicker_1.addObserver = addObserver;
        function getValue(id) {
            var colorPicker = colorPickersCache.getById(id);
            var hexValue = colorPicker.value;
            return ColorSpace.hexToRgb(hexValue);
        }
        ColorPicker_1.getValue = getValue;
        function getValueHex(id) {
            var colorPicker = colorPickersCache.getById(id);
            return colorPicker.value;
        }
        ColorPicker_1.getValueHex = getValueHex;
        /**
         * @param id control id
         * @param r integer in [0, 255]
         * @param g integer in [0, 255]
         * @param b integer in [0, 255]
         */
        function setValue(id, r, g, b) {
            var rgb = {
                r: roundAndClamp(r, 0, 255),
                g: roundAndClamp(g, 0, 255),
                b: roundAndClamp(b, 0, 255),
            };
            var hexValue = ColorSpace.rgbToHex(rgb);
            var colorPicker = colorPickersCache.getById(id);
            colorPicker.value = hexValue;
        }
        ColorPicker_1.setValue = setValue;
        function storeState(id) {
            var colorPicker = colorPickersCache.getById(id);
            colorPickersStorage.storeState(colorPicker);
        }
        ColorPicker_1.storeState = storeState;
        function clearStoredState(id) {
            var colorPicker = colorPickersCache.getById(id);
            colorPickersStorage.clearStoredState(colorPicker);
        }
        ColorPicker_1.clearStoredState = clearStoredState;
    })(ColorPicker = Page.ColorPicker || (Page.ColorPicker = {}));
})(Page || (Page = {}));

var Page;
(function (Page) {
    var FileControl;
    (function (FileControl) {
        var FileUpload = /** @class */ (function () {
            function FileUpload(container) {
                var _this = this;
                this.observers = [];
                this.inputElement = Page.Helpers.Utils.selector(container, "input");
                this.labelSpanElement = Page.Helpers.Utils.selector(container, "label > span");
                this.id = this.inputElement.id;
                this.inputElement.addEventListener("change", function (event) {
                    event.stopPropagation();
                    var files = _this.inputElement.files;
                    if (files && files.length === 1) {
                        _this.labelSpanElement.innerText = FileUpload.truncate(files[0].name);
                        for (var _i = 0, _a = _this.observers; _i < _a.length; _i++) {
                            var observer = _a[_i];
                            observer(files);
                        }
                    }
                }, false);
            }
            FileUpload.prototype.clear = function () {
                this.inputElement.value = "";
                this.labelSpanElement.innerText = this.labelSpanElement.dataset["placeholder"] || "Upload";
            };
            FileUpload.truncate = function (name) {
                if (name.length > FileUpload.filenameMaxSize) {
                    return name.substring(0, FileUpload.filenameMaxSize - 1) + "..." +
                        name.substring(name.length - (FileUpload.filenameMaxSize - 1));
                }
                return name;
            };
            FileUpload.filenameMaxSize = 16;
            return FileUpload;
        }());
        var FileDownload = /** @class */ (function () {
            function FileDownload(container) {
                var _this = this;
                this.observers = [];
                this.buttonElement = Page.Helpers.Utils.selector(container, "input");
                this.id = this.buttonElement.id;
                this.buttonElement.addEventListener("click", function (event) {
                    event.stopPropagation();
                    for (var _i = 0, _a = _this.observers; _i < _a.length; _i++) {
                        var observer = _a[_i];
                        observer();
                    }
                }, false);
            }
            return FileDownload;
        }());
        var fileUploadsCache = new Page.Helpers.Cache("FileUpload", function () {
            var selector = ".file-control.upload > input[id]";
            var fileUploadInputsElements = Page.Helpers.Utils.selectorAll(document, selector);
            return fileUploadInputsElements.map(function (fileUploadInputsElement) {
                var container = fileUploadInputsElement.parentElement;
                var fileUpload = new FileUpload(container);
                return fileUpload;
            });
        });
        var fileDownloadsCache = new Page.Helpers.Cache("FileDownload", function () {
            var selector = ".file-control.download > input[id]";
            var fileDownloadInputsElements = Page.Helpers.Utils.selectorAll(document, selector);
            return fileDownloadInputsElements.map(function (fileDownloadInputsElement) {
                var container = fileDownloadInputsElement.parentElement;
                return new FileDownload(container);
            });
        });
        Page.Helpers.Events.callAfterDOMLoaded(function () {
            fileUploadsCache.load();
            fileUploadsCache.load();
        });
        function addDownloadObserver(id, observer) {
            var fileDownload = fileDownloadsCache.getById(id);
            fileDownload.observers.push(observer);
        }
        FileControl.addDownloadObserver = addDownloadObserver;
        function addUploadObserver(id, observer) {
            var fileUpload = fileUploadsCache.getById(id);
            fileUpload.observers.push(observer);
        }
        FileControl.addUploadObserver = addUploadObserver;
        function clearFileUpload(id) {
            var fileUpload = fileUploadsCache.getById(id);
            fileUpload.clear();
        }
        FileControl.clearFileUpload = clearFileUpload;
    })(FileControl = Page.FileControl || (Page.FileControl = {}));
})(Page || (Page = {}));



var Page;
(function (Page) {
    var Canvas;
    (function (Canvas) {
        function getElementBySelector(selector) {
            var elt = document.querySelector(selector);
            if (!elt) {
                console.error("Cannot find element '" + selector + "'.");
            }
            return elt;
        }
        function getCanvasById(id) {
            return Page.Helpers.Utils.selector(document, "canvas[id=" + id + "]");
        }
        function getCheckboxFromId(id) {
            return Page.Helpers.Utils.selector(document, "input[type=checkbox][id=" + id + "]");
        }
        var canvasContainer = Page.Helpers.Utils.selector(document, "#canvas-container");
        var canvas = getCanvasById("canvas");
        var buttonsColumn = Page.Helpers.Utils.selector(document, "#canvas-buttons-column");
        var fullscreenCheckbox = getCheckboxFromId("fullscreen-checkbox-id");
        var sidePaneCheckbox = getCheckboxFromId("side-pane-checkbox-id");
        var loader = Page.Helpers.Utils.selector(canvasContainer, ".loader");
        var maxWidth = 512;
        var maxHeight = 512;
        function bindCanvasButtons() {
            function hideOverflow(value) {
                document.body.style.overflow = value ? "hidden" : "auto";
            }
            if (fullscreenCheckbox) {
                Page.Helpers.Events.callAfterDOMLoaded(function () {
                    hideOverflow(fullscreenCheckbox.checked);
                    fullscreenCheckbox.addEventListener("change", function () {
                        hideOverflow(fullscreenCheckbox.checked);
                    });
                });
                if (sidePaneCheckbox) {
                    fullscreenCheckbox.addEventListener("change", function () {
                        if (fullscreenCheckbox.checked) {
                            sidePaneCheckbox.checked = false;
                        }
                    }, false);
                }
            }
        }
        bindCanvasButtons();
        function getCanvasSize() {
            var rect = canvas.getBoundingClientRect();
            return [Math.floor(rect.width), Math.floor(rect.height)];
        }
        var lastCanvasSize = [0, 0];
        var canvasResizeObservers = [];
        function inPx(size) {
            return size + "px";
        }
        /**
         * Calls callbacks if needed.
         */
        function updateCanvasSize() {
            canvasContainer.style.width = "100vw";
            var size = getCanvasSize();
            if (fullscreenCheckbox.checked) {
                canvasContainer.style.height = "100%";
                canvasContainer.style.maxWidth = "";
                canvasContainer.style.maxHeight = "";
            }
            else {
                size[1] = size[0] * maxHeight / maxWidth;
                canvasContainer.style.height = inPx(size[1]);
                canvasContainer.style.maxWidth = inPx(maxWidth);
                canvasContainer.style.maxHeight = inPx(maxHeight);
            }
            if (size[0] !== lastCanvasSize[0] || size[1] !== lastCanvasSize[1]) {
                lastCanvasSize = getCanvasSize();
                for (var _i = 0, canvasResizeObservers_1 = canvasResizeObservers; _i < canvasResizeObservers_1.length; _i++) {
                    var observer = canvasResizeObservers_1[_i];
                    observer(lastCanvasSize[0], lastCanvasSize[1]);
                }
            }
        }
        Page.Helpers.Events.callAfterDOMLoaded(updateCanvasSize);
        fullscreenCheckbox.addEventListener("change", updateCanvasSize, false);
        window.addEventListener("resize", updateCanvasSize, false);
        var fullscreenToggleObservers = [updateCanvasSize];
        var mouseDownObservers = [];
        var mouseUpObservers = [];
        var mouseDragObservers = [];
        var mouseMoveObservers = [];
        var mouseEnterObservers = [];
        var mouseLeaveObservers = [];
        var mouseWheelObservers = [];
        /* Bind fullscreen events */
        if (fullscreenCheckbox) {
            fullscreenCheckbox.addEventListener("change", function () {
                var isFullscreen = fullscreenCheckbox.checked;
                for (var _i = 0, fullscreenToggleObservers_1 = fullscreenToggleObservers; _i < fullscreenToggleObservers_1.length; _i++) {
                    var observer = fullscreenToggleObservers_1[_i];
                    observer(isFullscreen);
                }
            }, false);
        }
        document.addEventListener("keydown", function (event) {
            if (event.keyCode === 27) {
                Canvas.toggleFullscreen(false);
            }
        });
        function clientToRelative(clientX, clientY) {
            var rect = canvas.getBoundingClientRect();
            return [
                (clientX - rect.left) / rect.width,
                (clientY - rect.top) / rect.height,
            ];
        }
        var Mouse;
        (function (Mouse) {
            var mousePosition = [0, 0];
            var clientMousePosition = [0, 0];
            var isMouseDownInternal = false;
            function getMousePosition() {
                return [mousePosition[0], mousePosition[1]];
            }
            Mouse.getMousePosition = getMousePosition;
            function setMousePosition(x, y) {
                mousePosition[0] = x;
                mousePosition[1] = y;
            }
            Mouse.setMousePosition = setMousePosition;
            function isMouseDown() {
                return isMouseDownInternal;
            }
            Mouse.isMouseDown = isMouseDown;
            function mouseDown(clientX, clientY) {
                var pos = clientToRelative(clientX, clientY);
                setMousePosition(pos[0], pos[1]);
                isMouseDownInternal = true;
                for (var _i = 0, mouseDownObservers_1 = mouseDownObservers; _i < mouseDownObservers_1.length; _i++) {
                    var observer = mouseDownObservers_1[_i];
                    observer();
                }
            }
            Mouse.mouseDown = mouseDown;
            function mouseUp() {
                if (isMouseDownInternal) {
                    isMouseDownInternal = false;
                    for (var _i = 0, mouseUpObservers_1 = mouseUpObservers; _i < mouseUpObservers_1.length; _i++) {
                        var observer = mouseUpObservers_1[_i];
                        observer();
                    }
                }
            }
            Mouse.mouseUp = mouseUp;
            function mouseMove(clientX, clientY) {
                clientMousePosition[0] = clientX;
                clientMousePosition[1] = clientY;
                var newPos = clientToRelative(clientX, clientY);
                var dX = newPos[0] - mousePosition[0];
                var dY = newPos[1] - mousePosition[1];
                // Update the mousePosition before calling the observers,
                // because they might call getMousePosition() and it needs to be up to date.
                mousePosition[0] = newPos[0];
                mousePosition[1] = newPos[1];
                if (isMouseDownInternal) {
                    for (var _i = 0, mouseDragObservers_1 = mouseDragObservers; _i < mouseDragObservers_1.length; _i++) {
                        var observer = mouseDragObservers_1[_i];
                        observer(dX, dY);
                    }
                }
                for (var _a = 0, mouseMoveObservers_1 = mouseMoveObservers; _a < mouseMoveObservers_1.length; _a++) {
                    var observer = mouseMoveObservers_1[_a];
                    observer(newPos[0], newPos[1]);
                }
            }
            Mouse.mouseMove = mouseMove;
            if (canvas) {
                canvas.addEventListener("mousedown", function (event) {
                    if (event.button === 0) {
                        mouseDown(event.clientX, event.clientY);
                    }
                }, false);
                canvas.addEventListener("mouseenter", function () {
                    for (var _i = 0, mouseEnterObservers_1 = mouseEnterObservers; _i < mouseEnterObservers_1.length; _i++) {
                        var observer = mouseEnterObservers_1[_i];
                        observer();
                    }
                }, false);
                canvas.addEventListener("mouseleave", function () {
                    for (var _i = 0, mouseLeaveObservers_1 = mouseLeaveObservers; _i < mouseLeaveObservers_1.length; _i++) {
                        var observer = mouseLeaveObservers_1[_i];
                        observer();
                    }
                }, false);
                canvas.addEventListener("wheel", function (event) {
                    if (mouseWheelObservers.length > 0) {
                        var delta = (event.deltaY > 0) ? 1 : -1;
                        for (var _i = 0, mouseWheelObservers_1 = mouseWheelObservers; _i < mouseWheelObservers_1.length; _i++) {
                            var observer = mouseWheelObservers_1[_i];
                            observer(delta, mousePosition);
                        }
                        event.preventDefault();
                        return false;
                    }
                    return true;
                }, false);
                window.addEventListener("mousemove", function (event) {
                    mouseMove(event.clientX, event.clientY);
                });
                window.addEventListener("mouseup", function (event) {
                    if (event.button === 0) {
                        mouseUp();
                    }
                });
                canvasResizeObservers.push(function () {
                    mouseMove(clientMousePosition[0], clientMousePosition[1]);
                });
            }
        })(Mouse || (Mouse = {}));
        (function Touch() {
            var currentTouches = [];
            var currentDistance = 0; // for pinching management
            function computeDistance(firstTouch, secondTouch) {
                var dX = firstTouch.clientX - secondTouch.clientX;
                var dY = firstTouch.clientY - secondTouch.clientY;
                return Math.sqrt(dX * dX + dY * dY);
            }
            function handleTouchStart(event) {
                var isFirstTouch = (currentTouches.length === 0);
                var changedTouches = Page.Helpers.Utils.touchArray(event.changedTouches);
                for (var _i = 0, changedTouches_1 = changedTouches; _i < changedTouches_1.length; _i++) {
                    var touch = changedTouches_1[_i];
                    var alreadyRegistered = false;
                    for (var _a = 0, currentTouches_1 = currentTouches; _a < currentTouches_1.length; _a++) {
                        var knownTouch = currentTouches_1[_a];
                        if (touch.identifier === knownTouch.id) {
                            alreadyRegistered = true;
                            break;
                        }
                    }
                    if (!alreadyRegistered) {
                        currentTouches.push({
                            id: touch.identifier,
                            clientX: touch.clientX,
                            clientY: touch.clientY,
                        });
                    }
                }
                if (isFirstTouch && currentTouches.length > 0) {
                    var currentTouch = currentTouches[0];
                    Mouse.mouseDown(currentTouch.clientX, currentTouch.clientY);
                }
                else if (currentTouches.length === 2) {
                    currentDistance = computeDistance(currentTouches[0], currentTouches[1]);
                }
            }
            function handleTouchEnd(event) {
                var knewAtLeastOneTouch = (currentTouches.length > 0);
                var changedTouches = Page.Helpers.Utils.touchArray(event.changedTouches);
                for (var _i = 0, changedTouches_2 = changedTouches; _i < changedTouches_2.length; _i++) {
                    var touch = changedTouches_2[_i];
                    for (var iC = 0; iC < currentTouches.length; ++iC) {
                        if (touch.identifier === currentTouches[iC].id) {
                            currentTouches.splice(iC, 1);
                            iC--;
                        }
                    }
                }
                if (currentTouches.length === 1) {
                    var firstTouch = currentTouches[0];
                    var newPos = clientToRelative(firstTouch.clientX, firstTouch.clientY);
                    Mouse.setMousePosition(newPos[0], newPos[1]);
                }
                else if (knewAtLeastOneTouch && currentTouches.length === 0) {
                    Mouse.mouseUp();
                }
            }
            function handleTouchMove(event) {
                var touches = Page.Helpers.Utils.touchArray(event.changedTouches);
                for (var _i = 0, touches_1 = touches; _i < touches_1.length; _i++) {
                    var touch = touches_1[_i];
                    for (var _a = 0, currentTouches_2 = currentTouches; _a < currentTouches_2.length; _a++) {
                        var knownTouch = currentTouches_2[_a];
                        if (touch.identifier === knownTouch.id) {
                            knownTouch.clientX = touch.clientX;
                            knownTouch.clientY = touch.clientY;
                        }
                    }
                }
                var nbObservers = mouseMoveObservers.length + mouseDragObservers.length;
                if (Mouse.isMouseDown() && nbObservers > 0) {
                    event.preventDefault();
                }
                if (currentTouches.length === 1) {
                    var firstTouch = currentTouches[0];
                    Mouse.mouseMove(firstTouch.clientX, firstTouch.clientY);
                }
                else if (currentTouches.length === 2) {
                    var firstTouch = currentTouches[0];
                    var secondTouch = currentTouches[1];
                    var newDistance = computeDistance(firstTouch, secondTouch);
                    var deltaDistance = (currentDistance - newDistance);
                    var zoomFactor = deltaDistance / currentDistance;
                    currentDistance = newDistance;
                    var zoomCenterXClient = 0.5 * (firstTouch.clientX + secondTouch.clientX);
                    var zoomCenterYClient = 0.5 * (firstTouch.clientY + secondTouch.clientY);
                    var zoomCenter = clientToRelative(zoomCenterXClient, zoomCenterYClient);
                    for (var _b = 0, mouseWheelObservers_2 = mouseWheelObservers; _b < mouseWheelObservers_2.length; _b++) {
                        var observer = mouseWheelObservers_2[_b];
                        observer(5 * zoomFactor, zoomCenter);
                    }
                }
            }
            if (canvas) {
                canvas.addEventListener("touchstart", handleTouchStart, false);
                window.addEventListener("touchend", handleTouchEnd);
                window.addEventListener("touchmove", handleTouchMove, { passive: false });
            }
        })();
        var Indicators;
        (function (Indicators) {
            var indicatorSpansCache = {};
            var suffix = "-indicator-id";
            function getIndicator(id) {
                var element = getElementBySelector("#" + id + suffix);
                if (!element) {
                    throw new Error("Could not find indicator '".concat(id, "'."));
                }
                return element;
            }
            Indicators.getIndicator = getIndicator;
            function getIndicatorSpan(id) {
                if (!indicatorSpansCache[id]) { // not yet in cache
                    var fullId = id + suffix;
                    var element = getElementBySelector("#" + fullId + " span");
                    if (!element) {
                        throw new Error("Could not find indicator span '".concat(id, "'."));
                    }
                    indicatorSpansCache[id] = element;
                }
                return indicatorSpansCache[id];
            }
            Indicators.getIndicatorSpan = getIndicatorSpan;
        })(Indicators || (Indicators = {}));
        var Storage;
        (function (Storage) {
            var PREFIX = "canvas";
            var FULLSCREEN_PARAMETER = "fullscreen";
            var SIDE_PANE_PARAMETER = "sidepane";
            var TRUE = "true";
            var FALSE = "false";
            function updateBooleanParameter(name, checked) {
                var value = checked ? TRUE : FALSE;
                Page.Helpers.URL.setQueryParameter(PREFIX, name, value);
            }
            function attachStorageEvents() {
                if (fullscreenCheckbox) {
                    fullscreenCheckbox.addEventListener("change", function () {
                        updateBooleanParameter(FULLSCREEN_PARAMETER, fullscreenCheckbox.checked);
                        Page.Helpers.URL.removeQueryParameter(PREFIX, SIDE_PANE_PARAMETER);
                    });
                }
                if (sidePaneCheckbox) {
                    sidePaneCheckbox.addEventListener("change", function () {
                        updateBooleanParameter(SIDE_PANE_PARAMETER, sidePaneCheckbox.checked);
                    });
                }
            }
            Storage.attachStorageEvents = attachStorageEvents;
            function applyStoredState() {
                Page.Helpers.URL.loopOnParameters(PREFIX, function (name, value) {
                    if (name === FULLSCREEN_PARAMETER && (value === TRUE || value === FALSE)) {
                        if (fullscreenCheckbox) {
                            fullscreenCheckbox.checked = (value === TRUE);
                        }
                    }
                    else if (name === SIDE_PANE_PARAMETER && (value === TRUE || value === FALSE)) {
                        if (sidePaneCheckbox) {
                            sidePaneCheckbox.checked = (value === TRUE);
                        }
                    }
                    else {
                        console.log("Removing invalid query parameter '" + name + "=" + value + "'.");
                        Page.Helpers.URL.removeQueryParameter(PREFIX, name);
                    }
                });
            }
            Storage.applyStoredState = applyStoredState;
        })(Storage || (Storage = {}));
        Storage.applyStoredState();
        Storage.attachStorageEvents();
        Canvas.Observers = Object.freeze({
            canvasResize: canvasResizeObservers,
            fullscreenToggle: fullscreenToggleObservers,
            mouseDown: mouseDownObservers,
            mouseDrag: mouseDragObservers,
            mouseEnter: mouseEnterObservers,
            mouseLeave: mouseLeaveObservers,
            mouseMove: mouseMoveObservers,
            mouseWheel: mouseWheelObservers,
            mouseUp: mouseUpObservers,
        });
        function getAspectRatio() {
            var size = getCanvasSize();
            return size[0] / size[1];
        }
        Canvas.getAspectRatio = getAspectRatio;
        function getCanvas() {
            return canvas;
        }
        Canvas.getCanvas = getCanvas;
        function getCanvasContainer() {
            return canvasContainer;
        }
        Canvas.getCanvasContainer = getCanvasContainer;
        function getSize() {
            return getCanvasSize();
        }
        Canvas.getSize = getSize;
        function getMousePosition() {
            return Mouse.getMousePosition();
        }
        Canvas.getMousePosition = getMousePosition;
        function isFullScreen() {
            return fullscreenCheckbox && fullscreenCheckbox.checked;
        }
        Canvas.isFullScreen = isFullScreen;
        function isMouseDown() {
            return Mouse.isMouseDown();
        }
        Canvas.isMouseDown = isMouseDown;
        function setIndicatorText(id, text) {
            var indicator = Indicators.getIndicatorSpan(id);
            if (indicator) {
                indicator.innerText = text;
            }
        }
        Canvas.setIndicatorText = setIndicatorText;
        function setIndicatorVisibility(id, visible) {
            var indicator = Indicators.getIndicator(id);
            if (indicator) {
                indicator.style.display = visible ? "" : "none";
            }
        }
        Canvas.setIndicatorVisibility = setIndicatorVisibility;
        function setIndicatorsVisibility(visible) {
            var indicators = document.getElementById("indicators");
            indicators.style.display = visible ? "" : "none";
        }
        Canvas.setIndicatorsVisibility = setIndicatorsVisibility;
        function setMaxSize(newMaxWidth, newMaxHeight) {
            maxWidth = newMaxWidth;
            maxHeight = newMaxHeight;
            updateCanvasSize();
        }
        Canvas.setMaxSize = setMaxSize;
        function setResizable(resizable) {
            buttonsColumn.style.display = resizable ? "" : "none";
        }
        Canvas.setResizable = setResizable;
        function setLoaderText(text) {
            if (loader) {
                loader.querySelector("span").innerText = text;
            }
        }
        Canvas.setLoaderText = setLoaderText;
        function showLoader(show) {
            if (loader) {
                loader.style.display = (show) ? "block" : "";
            }
        }
        Canvas.showLoader = showLoader;
        function toggleFullscreen(fullscreen) {
            if (fullscreenCheckbox) {
                var needToUpdate = fullscreen !== fullscreenCheckbox.checked;
                if (needToUpdate) {
                    fullscreenCheckbox.checked = fullscreen;
                    if (typeof window.CustomEvent === "function") {
                        fullscreenCheckbox.dispatchEvent(new CustomEvent("change"));
                    }
                    else if (typeof CustomEvent.prototype.initCustomEvent === "function") {
                        var changeEvent = document.createEvent("CustomEvent");
                        changeEvent.initCustomEvent("change", false, false, undefined);
                        fullscreenCheckbox.dispatchEvent(changeEvent);
                    }
                }
            }
        }
        Canvas.toggleFullscreen = toggleFullscreen;
    })(Canvas = Page.Canvas || (Page.Canvas = {}));
})(Page || (Page = {}));

Page.Canvas.setMaxSize(512,512);


================================================
FILE: src/generate-page.ts
================================================
import * as fs from "fs";
import * as path from "path";
import { Demopage } from "webpage-templates";


const data = {
    title: "Particles",
    description: "WebGPU implementation of particles in a gravity field",
    introduction: [
        "This is a basic particles simulation running fully on GPU, using the new WebGPU API.",
        "Particles evolve independently, following simple gravitational rules. There can be several attraction points at once. You can control one with your mouse by pressing the left mouse button."
    ],
    githubProjectName: "particles-webgpu",
    readme: {
        filepath: path.join(__dirname, "..", "README.md"),
        branchName: "main"
    },
    additionalLinks: [],
    styleFiles: [
        "css/attractor-overlay.css"
    ],
    scriptFiles: [
        "script/main.js"
    ],
    indicators: [
        {
            id: "particles-count",
            label: "Particles count"
        },
    ],
    canvas: {
        width: 512,
        height: 512,
        enableFullscreen: true
    },
    controlsSections: [
        {
            title: "Simulation",
            controls: [
                {
                    type: Demopage.supportedControls.Range,
                    title: "Particle count",
                    id: "particles-count-range-id",
                    min: 1,
                    max: 20,
                    value: 1,
                    step: 1
                },
                {
                    type: Demopage.supportedControls.Range,
                    title: "Speed",
                    id: "speed-range-id",
                    min: 0,
                    max: 1,
                    value: 0.5,
                    step: 0.05
                },
                {
                    type: Demopage.supportedControls.Range,
                    title: "Friction",
                    id: "friction-range-id",
                    min: 0.998,
                    max: 1,
                    value: 0.9995,
                    step: 0.0001
                },
                {
                    type: Demopage.supportedControls.Checkbox,
                    title: "Bounce",
                    id: "bounce-checkbox-id",
                    checked: true
                },
                {
                    type: Demopage.supportedControls.Range,
                    title: "Gravity",
                    id: "gravity-range-id",
                    min: 0,
                    max: 1,
                    value: 0.1,
                    step: 0.001
                },
                {
                    type: Demopage.supportedControls.Button,
                    id: "reset-button-id",
                    label: "Reset"
                },
            ]
        },
        {
            title: "Attractors",
            controls: [
                {
                    type: Demopage.supportedControls.Range,
                    title: "Mouse force",
                    id: "attraction-range-id",
                    min: -1,
                    max: 1,
                    value: 0.7,
                    step: 0.05
                },
                {
                    type: Demopage.supportedControls.Select,
                    title: "Preset",
                    id: "attractors-preset-select-id",
                    placeholder: "Custom",
                    options: [
                        {
                            value: "none",
                            label: "None",
                        },
                        {
                            value: "orbit",
                            label: "Orbit",
                            checked: true,
                        },
                        {
                            value: "sines",
                            label: "Sines",
                        },
                        {
                            value: "central-attractive",
                            label: "Central (attractive)",
                        },
                        {
                            value: "central-repulsive",
                            label: "Central (replusilve)",
                        },
                    ]
                },
                {
                    type: Demopage.supportedControls.Checkbox,
                    title: "Display",
                    id: "display-attractors-checkbox-id",
                    checked: true
                },
            ]
        },
        {
            title: "Colors",
            controls: [
                {
                    type: Demopage.supportedControls.Tabs,
                    title: "Mode",
                    id: "colors-mode-tabs-id",
                    unique: true,
                    options: [
                        {
                            value: "unicolor",
                            label: "Unicolor",
                            checked: true,
                        },
                        {
                            value: "multicolor",
                            label: "Multicolor",
                        },
                    ]
                },
                {
                    type: Demopage.supportedControls.Checkbox,
                    title: "Auto",
                    id: "auto-color-checkbox-id",
                    checked: true
                },
                {
                    type: Demopage.supportedControls.Checkbox,
                    title: "High quality",
                    id: "high-color-quality-checkbox-id",
                    checked: false
                },
                {
                    type: Demopage.supportedControls.ColorPicker,
                    title: "Particle color",
                    id: "particle-color-id",
                    defaultValueHex: "#BC4212"
                },
                {
                    type: Demopage.supportedControls.Tabs,
                    title: "Source",
                    id: "color-source-tabs-id",
                    unique: true,
                    options: [
                        {
                            value: "image",
                            label: "From image",
                            checked: true,
                        },
                        {
                            value: "velocity",
                            label: "From velocity",
                        },
                    ]
                },
                {
                    type: Demopage.supportedControls.Select,
                    title: "Image",
                    id: "image-preset-select-id",
                    placeholder: "Custom",
                    options: [
                        {
                            value: "colors",
                            label: "Colors",
                            checked: true,
                        },
                        {
                            value: "ladybug",
                            label: "Ladybug",
                        },
                    ]
                },
                {
                    type: Demopage.supportedControls.FileUpload,
                    title: "Custom",
                    id: "input-image-upload-button",
                    accept: [".png", ".jpg", ".bmp", ".webp"],
                    defaultMessage: "Upload an image"
                },
            ]
        },
        {
            title: "Rendering",
            controls: [
                {
                    type: Demopage.supportedControls.Range,
                    title: "Particle size",
                    id: "sprite-size-range-id",
                    min: 1,
                    max: 17,
                    value: 1,
                    step: 2
                },
                {
                    type: Demopage.supportedControls.Checkbox,
                    title: "Blending",
                    id: "blending-checkbox-id",
                    checked: true
                },
                {
                    type: Demopage.supportedControls.Range,
                    title: "Particle opacity",
                    id: "opacity-range-id",
                    min: 0.01,
                    max: 1,
                    value: 0.1,
                    step: 0.005
                },
                {
                    type: Demopage.supportedControls.Checkbox,
                    title: "Show indicators",
                    id: "show-indicators-checkbox-id",
                    checked: true
                },
            ]
        }
    ]
};

const SRC_DIR = path.resolve(__dirname);
const DEST_DIR = path.resolve(__dirname, "..", "docs");
const minified = true;

const buildResult = Demopage.build(data, DEST_DIR, {
    debug: !minified,
});

// disable linting on this file because it is generated
buildResult.pageScriptDeclaration = "/* tslint:disable */\n" + buildResult.pageScriptDeclaration;

const SCRIPT_DECLARATION_FILEPATH = path.join(SRC_DIR, "ts", "page-interface-generated.d.ts");
fs.writeFileSync(SCRIPT_DECLARATION_FILEPATH, buildResult.pageScriptDeclaration);

fs.copyFileSync(path.join(SRC_DIR, "resources", "attractor-overlay.css"), path.join(DEST_DIR, "css", "attractor-overlay.css"));



================================================
FILE: src/config/tsconfig.json
================================================
{
	"files": [
        "../ts/main.ts",
    ],
	"compilerOptions": {
		/* Type Checking */
		"allowUnreachableCode": false,
		"allowUnusedLabels": false,
		"alwaysStrict": true,
		"exactOptionalPropertyTypes": false,
		"noFallthroughCasesInSwitch": true,
		"noImplicitAny": true,
		"noImplicitOverride": true,
		"noImplicitReturns": true,
		"noImplicitThis": true,
		"noPropertyAccessFromIndexSignature": true,
		"noUncheckedIndexedAccess": true,
		"noUnusedLocals": true,
		"noUnusedParameters": true,
		"strict": true,
		"strictBindCallApply": true,
		"strictFunctionTypes": true,
		"strictNullChecks": true,
		"strictPropertyInitialization": false,
		"useUnknownInCatchVariables": true,

		/* Modules */
		"module": "commonjs",
		"moduleResolution": "node",

		/* Emit */
		"declaration": false,
		"removeComments": false,
		"sourceMap": true,

		/* JavaScript Support */
		"allowJs": false,

		/* Interop Constraints */
		"esModuleInterop": true,
		"forceConsistentCasingInFileNames": true,
		"isolatedModules": true, // because webpack is used for bundling

		/* Language and Environment */
		"target": "ES2017"
	}
}



================================================
FILE: src/config/webpack.config.js
================================================
const path = require("path");

const PROJECT_DIR = path.resolve(__dirname, "..", "..");
const INPUT_SCRIPT_DIR = path.join(PROJECT_DIR, "src", "ts");
const OUTPUT_SCRIPT_DIR = path.join(PROJECT_DIR, "docs", "script");

function buildConfig(entryFilename /* string */, outputFilename /* string */) /* object */ {
    return {
        name: entryFilename,
        devtool: "source-map",
        mode: "development",
        entry: path.join(INPUT_SCRIPT_DIR, entryFilename),
        output: {
            path: OUTPUT_SCRIPT_DIR,
            filename: outputFilename,
            assetModuleFilename: path.join("..", "rc", "images", "[hash][ext][query]")
        },
        target: ["web", "es2017"],
        resolve: {
            extensions: [".ts"]
        },
        module: {
            rules: [
                {
                    test: /\.ts$/,
                    exclude: /node_modules/,
                    use: [
                        {
                            loader: "ts-loader",
                            options: {
                                compilerOptions: {
                                    rootDir: INPUT_SCRIPT_DIR
                                },
                                configFile: path.join(PROJECT_DIR, "src", "config", 'tsconfig.json')
                            }
                        }
                    ],
                },
                {
                    test: /\.wgsl$/,
                    type: 'asset/source',
                },
                {
                    test: /\.png$/,
                    type: 'asset/resource',
                },
            ]
        }
    };
}

module.exports = [
    buildConfig("main.ts", "main.js"),
];



================================================
FILE: src/config/.eslintrc.json
================================================
{
    "root": true,
    "parser": "@typescript-eslint/parser",
    "ignorePatterns": [
        "*.d.ts",
        "*.js"
    ],
    "plugins": [
        "@typescript-eslint"
    ],
    "env": {
        "browser": true
    },
    "parserOptions": {
        "project": "./src/config/tsconfig.json"
    },
    "extends": [
        "eslint:recommended",
        "plugin:@typescript-eslint/recommended"
    ],
    "rules": {
        "@typescript-eslint/explicit-function-return-type": [
            "error",
            {
                "allowExpressions": true
            }
        ],
        "@typescript-eslint/no-inferrable-types": [
            "error",
            {
                "ignoreParameters": true,
                "ignoreProperties": true
            }
        ],
        "@typescript-eslint/no-non-null-assertion": "off",
		"@typescript-eslint/no-shadow": [
            "error"
        ],
        "indent": [
            "warn",
            4,
            {
                "SwitchCase": 1
            }
        ],
        "semi": [
            "error"
        ]
    }
}


================================================
FILE: src/resources/attractor-overlay.css
================================================
.attractor-overlay {
    position: absolute;
    content: '';
    transform: translate(-50%,-50%);
    width: 16px;
    height: 16px;
    border: 3px solid red;
    border-radius: 50%;
    background: none;
    pointer-events: none;
}



================================================
FILE: src/shaders/composition.wgsl
================================================
struct Uniforms {             //             align(32)  size(20)
    color: vec4<f32>,         // offset(0)   align(16)  size(16)
    additiveBlending: u32,    // offset(16)  align(4)   size(4)
};

@group(0) @binding(0) var<uniform> uniforms: Uniforms;
@group(0) @binding(1) var accumulationTexture: texture_2d<f32>;
@group(0) @binding(2) var accumulationTextureSampler: sampler;

struct VertexOut {
    @builtin(position) position: vec4<f32>,
    @location(0) uv: vec2<f32>,
}

@vertex
fn main_vertex(@builtin(vertex_index) inVertexIndex: u32) -> VertexOut {
    var out: VertexOut;
    if (inVertexIndex == 0u) {
        out.uv = vec2<f32>(0.0, 0.0);
    } else if (inVertexIndex == 1u) {
        out.uv = vec2<f32>(0.0, 1.0);
    } else if (inVertexIndex == 2u) {
        out.uv = vec2<f32>(1.0, 0.0);
    } else {
        out.uv = vec2<f32>(1.0, 1.0);
    }

    out.position = vec4<f32>(2.0 * out.uv.x - 1.0, 1.0 - 2.0 * out.uv.y, 0.0, 1.0);
    return out;
}

@fragment
fn main_fragment(@location(0) uv: vec2<f32>) -> @location(0) vec4<f32> {
    let cumulated = textureSample(accumulationTexture, accumulationTextureSampler, uv).r;

    if (uniforms.additiveBlending == 1u) {
        return vec4<f32>(255.0 * cumulated * uniforms.color.a * uniforms.color.rgb, 1.0);
    } else {
        return step(0.001, cumulated) * vec4<f32>(uniforms.color.rgb, 1.0);
    }
}



================================================
FILE: src/shaders/draw-instanced-monocolor.wgsl
================================================
struct Uniforms {             //             align(16)  size(24)
    color: vec4<f32>,         // offset(0)   align(16)  size(16)
    spriteSize: vec2<f32>,    // offset(16)   align(8)  size(8)
};

struct VSOut {
    @builtin(position) position: vec4<f32>,
    @location(0) localPosition: vec2<f32>, // in {-1, +1}^2
};

@group(0) @binding(0) var<uniform> uniforms: Uniforms;

@vertex
fn main_vertex(@location(0) inPosition: vec2<f32>, @location(1) quadCorner: vec2<f32>) -> VSOut {
    var vsOut: VSOut;
    vsOut.position = vec4<f32>(inPosition + uniforms.spriteSize * quadCorner, 0.0, 1.0);
    vsOut.position.y = -vsOut.position.y;
    vsOut.localPosition = quadCorner;
    return vsOut;
}

@fragment
fn main_fragment(@location(0) localPosition: vec2<f32>) -> @location(0) vec4<f32> {
    let distanceFromCenter: f32 = length(localPosition);
    if (distanceFromCenter > 1.0) {
        discard;
    }

    return uniforms.color;
}



================================================
FILE: src/shaders/draw-instanced-multicolor-velocity.wgsl
================================================
struct Uniforms {             //             align(16)  size(24)
    color: vec4<f32>,         // offset(0)   align(16)  size(16)
    spriteSize: vec2<f32>,    // offset(16)   align(8)  size(8)
};

struct VertexOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) localPosition: vec2<f32>, // in {-1, +1}^2
    @location(1) @interpolate(flat) color: vec4<f32>,
};

@group(0) @binding(0) var<uniform> uniforms: Uniforms;

@vertex
fn main_vertex(@location(0) inPosition: vec2<f32>, @location(1) inVelocity: vec2<f32>, @location(2) quadCorner: vec2<f32>) -> VertexOutput {
    var vsOut: VertexOutput;
    vsOut.position = vec4<f32>(inPosition + uniforms.spriteSize * quadCorner, 0.0, 1.0);
    vsOut.position.y = -vsOut.position.y;
    vsOut.localPosition = quadCorner;
    vsOut.color = colorFromVelocity(inVelocity, uniforms.color.a);
    return vsOut;
}

@fragment
fn main_fragment(@location(0) localPosition: vec2<f32>, @location(1) @interpolate(flat) color: vec4<f32>) -> @location(0) vec4<f32> {
    let distanceFromCenter: f32 = length(localPosition);
    if (distanceFromCenter > 1.0) {
        discard;
    }

    return color;
}



================================================
FILE: src/shaders/draw-instanced-multicolor.wgsl
================================================
struct Uniforms {             //             align(16)  size(24)
    color: vec4<f32>,         // offset(0)   align(16)  size(16)
    spriteSize: vec2<f32>,    // offset(16)   align(8)  size(8)
};

struct VertexOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) localPosition: vec2<f32>, // in {-1, +1}^2
    @location(1) @interpolate(flat) color: u32,
};

@group(0) @binding(0) var<uniform> uniforms: Uniforms;

@vertex
fn main_vertex(@location(0) inPosition: vec2<f32>, @location(1) quadCorner: vec2<f32>, @location(2) inColor: u32) -> VertexOutput {
    var vsOut: VertexOutput;
    vsOut.position = vec4<f32>(inPosition + uniforms.spriteSize * quadCorner, 0.0, 1.0);
    vsOut.position.y = -vsOut.position.y;
    vsOut.localPosition = quadCorner;
    vsOut.color = inColor;
    return vsOut;
}

@fragment
fn main_fragment(@location(0) localPosition: vec2<f32>, @location(1) @interpolate(flat) color: u32) -> @location(0) vec4<f32> {
    let distanceFromCenter: f32 = length(localPosition);
    if (distanceFromCenter > 1.0) {
        discard;
    }

    return unpackColor(color, uniforms.color.a);
}



================================================
FILE: src/shaders/draw-monocolor.wgsl
================================================
@vertex
fn main_vertex(@location(0) inPosition: vec2<f32>) -> @builtin(position) vec4<f32> {
    return vec4<f32>(inPosition.x, -inPosition.y, 0.0, 1.0);
}

struct Uniforms {             //             align(16)  size(16)
    color: vec4<f32>,         // offset(0)   align(16)  size(16)
};

@group(0) @binding(0) var<uniform> uniforms: Uniforms;

@fragment
fn main_fragment() -> @location(0) vec4<f32> {
    return uniforms.color;
}



================================================
FILE: src/shaders/draw-multicolor-velocity.wgsl
================================================
struct VSOut {
    @builtin(position) position: vec4<f32>,
    @location(0) @interpolate(flat) color: vec4<f32>,
};

struct Uniforms {             //             align(16)  size(16)
    color: vec4<f32>,         // offset(0)   align(16)  size(16)
};

@group(0) @binding(0) var<uniform> uniforms: Uniforms;

@vertex
fn main_vertex(@location(0) inPosition: vec2<f32>, @location(1) inVelocity: vec2<f32>) -> VSOut {
    var output: VSOut;
    output.position = vec4<f32>(inPosition.x, -inPosition.y, 0.0, 1.0);
    output.color = colorFromVelocity(inVelocity, uniforms.color.a);
    return output;
}

@fragment
fn main_fragment(@location(0) @interpolate(flat) color: vec4<f32>) -> @location(0) vec4<f32> {
    return color;
}



================================================
FILE: src/shaders/draw-multicolor.wgsl
================================================
struct VSOut {
    @builtin(position) position: vec4<f32>,
    @location(0) @interpolate(flat) color: u32,
};

@vertex
fn main_vertex(@location(0) inPosition: vec2<f32>, @location(1) inColor: u32) -> VSOut {
    var output: VSOut;
    output.position = vec4<f32>(inPosition.x, -inPosition.y, 0.0, 1.0);
    output.color = inColor;
    return output;
}

struct Uniforms {             //             align(16)  size(16)
    color: vec4<f32>,         // offset(0)   align(16)  size(16)
};

@group(0) @binding(0) var<uniform> uniforms: Uniforms;

@fragment
fn main_fragment(@location(0) @interpolate(flat) color: u32) -> @location(0) vec4<f32> {
    return unpackColor(color, uniforms.color.a);
}



================================================
FILE: src/shaders/initialize-colors.wgsl
================================================
struct Particle {
    position: vec2<f32>,
    velocity: vec2<f32>,
};

struct ParticlesBuffer {
    particles: array<Particle>,
};

struct ColorsBuffer {
    color: array<u32>,
};

@group(0) @binding(0) var<storage,read> particlesStorage: ParticlesBuffer;
@group(0) @binding(1) var<storage,read_write> colorsStorage: ColorsBuffer;
@group(1) @binding(0) var inputSampler : sampler;
@group(1) @binding(1) var inputTexture: texture_2d<f32>;

@compute @workgroup_size(256)
fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
    let index: u32 = GlobalInvocationID.x;

    let uv = 0.5 + 0.5 * particlesStorage.particles[index].position;
    let color = textureSampleLevel(inputTexture, inputSampler, uv, 0.0).rgb;
    colorsStorage.color[index] = packColor(color);
}



================================================
FILE: src/shaders/update.wgsl
================================================
struct Particle {
    position: vec2<f32>,
    velocity: vec2<f32>
};

struct ParticlesBuffer {
    particles: array<Particle>,
};

struct Attractor {                                 //             align(8)  size(16)
    position: vec2<f32>,                           // offset(0)   align(8)  size(8)
    force: f32,                                    // offset(8)   align(4)  size(4)
    // -- implicit padding --                      // offset(12)            size(4)
};

struct Uniforms {                                  //             align(8)  size(48)
    force: vec2<f32>,                              // offset(0)   align(8)  size(8)
    dt: f32,                                       // offset(8)   align(4)  size(4)
    bounce: u32,                                   // offset(12)  align(4)  size(4)

    friction: f32,                                 // offset(16)  align(4)  size(4)
    aspectRatio: f32,                              // offset(20)  align(4)  size(4)
    attractorsCount: u32,                          // offset(24)  align(4)  size(4)
    // -- implicit padding --                      // offset(28)            size(4)
    @align(16) attractors: array<Attractor, 4>,    // offset(32)  align(16) size(16) stride(16)
};

@group(0) @binding(0) var<storage,read_write> particlesStorage: ParticlesBuffer;
@group(0) @binding(1) var<uniform> uniforms: Uniforms;

@compute @workgroup_size(256)
fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
    let index: u32 = GlobalInvocationID.x;

    var particle = particlesStorage.particles[index];

    let applyAspectRatio = vec2<f32>(uniforms.aspectRatio, 1.0);

    var force: vec2<f32> = uniforms.force * applyAspectRatio;
    for (var i = 0u; i < uniforms.attractorsCount; i = i + 1u) {
        var toAttractor: vec2<f32> = (uniforms.attractors[i].position - particle.position) * applyAspectRatio;
        let squaredDistance: f32 = dot(toAttractor, toAttractor);
        force = force + uniforms.attractors[i].force * toAttractor / (squaredDistance + 0.01);
    }

    particle.velocity = uniforms.friction * (particle.velocity + uniforms.dt * force);
    particle.position = particle.position + uniforms.dt * particle.velocity / applyAspectRatio;

    if (uniforms.bounce != 0u) {
        if (particle.position.x < -1.0) {
            particle.position.x = -2.0 - particle.position.x;
            particle.velocity.x = -particle.velocity.x;
        }
        if (particle.position.y < -1.0) {
            particle.position.y = -2.0 - particle.position.y;
            particle.velocity.y = -particle.velocity.y;
        }

        if (particle.position.x > 1.0) {
            particle.position.x = 2.0 - particle.position.x;
            particle.velocity.x = -particle.velocity.x;
        }
        if (particle.position.y > 1.0) {
            particle.position.y = 2.0 - particle.position.y;
            particle.velocity.y = -particle.velocity.y;
        }
    }

    particlesStorage.particles[index] = particle;
}



================================================
FILE: src/shaders/utils/color.part.wgsl
================================================
fn unpackColor(packed: u32, alpha: f32) -> vec4<f32> {
    return vec4<f32>(unpack4x8unorm(packed).rgb, alpha);
}

fn packColor(color: vec3<f32>) -> u32 {
    return pack4x8unorm(vec4<f32>(color, 1.0));
}

fn colorFromHue(normalizedHue: f32, alpha: f32) -> vec4<f32> {
    let value = normalizedHue * 6.0;
    if (value < 1.0) {
        return vec4<f32>(1.0, value, 0.0, alpha);
    } else if (value < 2.0) {
        return vec4<f32>(2.0 - value, 1.0, 0.0, alpha);
    } else if (value < 3.0) {
        return vec4<f32>(0.0, 1.0, value - 2.0, alpha);
    } else if (value < 4.0) {
        return vec4<f32>(0.0, 4.0 - value, 1.0, alpha);
    } else if (value < 5.0) {
        return vec4<f32>(value - 4.0, 0.0, 1.0, alpha);
    }
    return vec4<f32>(1.0, 0.0, 6.0 - value, alpha);
}

fn colorFromVelocity(velocity: vec2<f32>, alpha: f32) -> vec4<f32> {
    let normalizedHue: f32 = 0.5 + 0.5 * atan2(velocity.y, velocity.x) / 3.14159;
    return colorFromHue(normalizedHue, alpha);
}



================================================
FILE: src/ts/attractors.ts
================================================
import { AttractorsPreset, Parameters } from "./parameters";

type Force = [number, number];
type Attractor = {
    position: [number, number];
    force: number;
}

let time = 0;

let container: HTMLElement;
const className = "attractor-overlay";

function setContainer(element: HTMLElement): void {
    container = element;
}

function setOverlays(attractors: Attractor[]): void {
    if (!container) {
        throw new Error("A container is needed for overlays.");
    }

    if (!Parameters.displayAttractors) {
        const elements = Array.from(container.querySelectorAll<HTMLElement>(`.${className}`));
        for (const element of elements) {
            const parentElement = element.parentElement;
            if (parentElement) {
                parentElement.removeChild(element);
            }
        }
        return;
    }

    const elements = Array.from(container.querySelectorAll<HTMLElement>(`.${className}`));
    while (elements.length > attractors.length) {
        const lastElement = elements.pop()!;
        const parentElement = lastElement.parentElement;
        if (parentElement) {
            parentElement.removeChild(lastElement);
        }
    }
    while (elements.length < attractors.length) {
        const newElement = document.createElement("span");
        newElement.className = className;
        container.appendChild(newElement);
        elements.push(newElement);
    }

    for (let i = 0; i < elements.length; i++) {
        const element = elements[i]!;
        const attractor = attractors[i]!;
        const x = 100 * (0.5 + 0.5 * attractor.position[0]);
        const y = 100 * (0.5 + 0.5 * attractor.position[1]);
        element.style.left = `${x.toFixed(2)}%`;
        element.style.top = `${y.toFixed(2)}%`;
    }
}

function getPreset(): Attractor[] {
    const attractorsList: Attractor[] = [];

    /* eslint indent: "off" */
    const preset = Parameters.attractorsPreset;
    switch (preset) {
        case AttractorsPreset.ORBIT:
            {
                attractorsList.push({
                    force: 7,
                    position: [0, 0],
                });
                attractorsList.push({
                    force: 5,
                    position: [0.4 * Math.cos(time), 0.4 * Math.sin(time)],
                });
                attractorsList.push({
                    force: 6,
                    position: [0.8 * Math.cos(-0.9 * time), 0.8 * Math.sin(-0.9 * time)],
                });
                break;
            }
        case AttractorsPreset.SINES:
            {
                attractorsList.push({
                    force: 7,
                    position: [0.7 * Math.cos(time), 0.7 * Math.sin(2 * time)],
                });
                attractorsList.push({
                    force: 7,
                    position: [0.7 * Math.cos(1.8 * (time + 0.5)), 0.7 * Math.sin(0.9 * (time + 0.5))],
                });
                break;
            }
        case AttractorsPreset.CENTRAL_ATTRACTIVE:
            {
                attractorsList.push({
                    force: 5,
                    position: [0, 0],
                });
                break;
            }
        case AttractorsPreset.CENTRAL_REPULSIVE:
            {
                attractorsList.push({
                    force: -5,
                    position: [0, 0],
                });
                break;
            }
        default:
            break;
    }

    const containerBox = container.getBoundingClientRect();
    const aspectRatio = containerBox.width / containerBox.height;

    for (const attractor of attractorsList) {
        attractor.position[0] /= aspectRatio;
    }

    return attractorsList;
}

function update(dt: number): void {
    time += dt;
}

export {
    getPreset,
    setOverlays,
    setContainer,
    update,
};
export type {
    Attractor,
    Force,
};



================================================
FILE: src/ts/engine.ts
================================================
/// <reference types="./page-interface-generated" />
/// <reference types="./webgpu-utils/wgsl-type" />

import InitializeColorsShaderSource from "../shaders/initialize-colors.wgsl";
import UpdateShaderSource from "../shaders/update.wgsl";
import ColorShaderPartSource from "../shaders/utils/color.part.wgsl";
import * as Attractors from "./attractors";
import { bytesToString } from "./helpers";
import { ColorMode, ColorSource, Parameters } from "./parameters";
import { IRenderer } from "./render/i-renderer";
import { RendererInstancedMonocolor } from "./render/renderer-instanced-monocolor";
import { RendererInstancedMonocolorHighQuality } from "./render/renderer-instanced-monocolor-high-quality";
import { RendererInstancedMulticolor } from "./render/renderer-instanced-multicolor";
import { RendererInstancedMulticolorVelocity } from "./render/renderer-instanced-multicolor-velocity";
import { RendererMonocolor } from "./render/renderer-monocolor";
import { RendererMonocolorHighQuality } from "./render/renderer-monocolor-high-quality";
import { RendererMulticolor } from "./render/renderer-multicolor";
import { RendererMulticolorVelocity } from "./render/renderer-multicolor-velocity";
import { WebGPUCanvas } from "./webgpu-utils/webgpu-canvas";
import * as WebGPU from "./webgpu-utils/webgpu-device";

const MAX_ATTRACTORS = 4;

type ParticlesBatch = {
    gpuBuffer: GPUBuffer;
    computeBindgroup: GPUBindGroup;
    colorsBuffer: GPUBuffer;
    initializeColorsComputeBindgroup: GPUBindGroup;
    particlesCount: number;
    dispatchSize: number;
}

class Engine {
    private static readonly WORKGROUP_SIZE = 256;

    private readonly computePipeline: GPUComputePipeline;
    private readonly computeUniformsBuffer: GPUBuffer;

    private readonly particleBatches: ParticlesBatch[] = [];

    private readonly initializeColorsComputePipeline: GPUComputePipeline;

    private readonly rendererMonocolor: RendererMonocolor;
    private readonly rendererMonocolorHighQuality: RendererMonocolorHighQuality;
    private readonly rendererMulticolor: RendererMulticolor;
    private readonly rendererMulticolorVelocity: RendererMulticolorVelocity;
    private readonly rendererInstancedMonocolor: RendererInstancedMonocolor;
    private readonly rendererInstancedMonocolorHighQuality: RendererInstancedMonocolorHighQuality;
    private readonly rendererInstancedMulticolor: RendererInstancedMulticolor;
    private readonly rendererInstancedMulticolorVelocity: RendererInstancedMulticolorVelocity;

    public constructor(targetTextureFormat: GPUTextureFormat) {
        this.rendererMonocolor = new RendererMonocolor(targetTextureFormat);
        this.rendererMonocolorHighQuality = new RendererMonocolorHighQuality(targetTextureFormat);
        this.rendererMulticolor = new RendererMulticolor(targetTextureFormat);
        this.rendererMulticolorVelocity = new RendererMulticolorVelocity(targetTextureFormat);
        this.rendererInstancedMonocolor = new RendererInstancedMonocolor(targetTextureFormat);
        this.rendererInstancedMonocolorHighQuality = new RendererInstancedMonocolorHighQuality(targetTextureFormat);
        this.rendererInstancedMulticolor = new RendererInstancedMulticolor(targetTextureFormat);
        this.rendererInstancedMulticolorVelocity = new RendererInstancedMulticolorVelocity(targetTextureFormat);

        this.computePipeline = WebGPU.device!.createComputePipeline({
            compute: {
                module: WebGPU.device!.createShaderModule({ code: UpdateShaderSource }),
                entryPoint: "main"
            },
            layout: "auto"
        });

        this.computeUniformsBuffer = WebGPU.device!.createBuffer({
            size: 96,
            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM,
        });

        this.initializeColorsComputePipeline = WebGPU.device!.createComputePipeline({
            compute: {
                module: WebGPU.device!.createShaderModule({ code: ColorShaderPartSource + InitializeColorsShaderSource }),
                entryPoint: "main",
            },
            layout: "auto"
        });
    }

    public get particlesCount(): number {
        let count = 0;
        for (const particlesBatch of this.particleBatches) {
            count += particlesBatch.particlesCount;
        }
        return count;
    }

    public update(commandEncoder: GPUCommandEncoder, dt: number, aspectRatio: number): void {
        const attractors = Attractors.getPreset();
        if (Page.Canvas.isMouseDown()) {
            const attractor: Attractors.Attractor = {
                position: Page.Canvas.getMousePosition() as [number, number],
                force: 10 * Parameters.attraction,
            };
            attractor.position[0] = 2 * attractor.position[0] - 1;
            attractor.position[1] = 2 * attractor.position[1] - 1;
            attractors.push(attractor);
        }
        Attractors.setOverlays(attractors);

        const uniformForce: Attractors.Force = [0, 3 * Parameters.gravity];
        const uniformsBufferData = this.buildComputeUniforms(dt, aspectRatio, uniformForce, attractors);
        WebGPU.device!.queue.writeBuffer(this.computeUniformsBuffer, 0, uniformsBufferData);

        for (const particlesBatch of this.particleBatches) {
            const computePass = commandEncoder.beginComputePass();
            computePass.setPipeline(this.computePipeline);
            computePass.setBindGroup(0, particlesBatch.computeBindgroup);
            computePass.dispatchWorkgroups(particlesBatch.dispatchSize);
            computePass.end();
        }
    }

    public draw(commandEncoder: GPUCommandEncoder, webgpuCanvas: WebGPUCanvas): void {
        let renderer: IRenderer;
        const instanced = (Parameters.spriteSize > 1);
        if (Parameters.colorMode === ColorMode.UNICOLOR) {
            if (Parameters.highColorQuality) {
                if (instanced) {
                    renderer = this.rendererInstancedMonocolorHighQuality;
                } else {
                    renderer = this.rendererMonocolorHighQuality;
                }
            } else {
                if (instanced) {
                    renderer = this.rendererInstancedMonocolor;
                } else {
                    renderer = this.rendererMonocolor;
                }
            }
        } else if (Parameters.colorSource === ColorSource.IMAGE) {
            if (instanced) {
                renderer = this.rendererInstancedMulticolor;
            } else {
                renderer = this.rendererMulticolor;
            }
        } else {
            if (instanced) {
                renderer = this.rendererInstancedMulticolorVelocity;
            } else {
                renderer = this.rendererMulticolorVelocity;
            }
        }

        renderer.particleColor = Parameters.particleColor;
        renderer.particleOpacity = Parameters.opacity;
        renderer.enableAdditiveBlending = Parameters.blending;
        renderer.spriteSize = Parameters.spriteSize;
        renderer.draw(commandEncoder, webgpuCanvas, this.particleBatches);
    }

    public reset(wantedParticlesCount: number): void {
        for (const particlesBatch of this.particleBatches) {
            if (particlesBatch.gpuBuffer) {
                particlesBatch.gpuBuffer.destroy();
            }
            if (particlesBatch.colorsBuffer) {
                particlesBatch.colorsBuffer.destroy();
            }
        }
        this.particleBatches.length = 0;

        let totalGpuBufferSize = 0, totalColorBufferSize = 0;

        const particleSize = Float32Array.BYTES_PER_ELEMENT * (2 + 2);
        const maxDispatchSize = Math.floor(WebGPU.device!.limits.maxStorageBufferBindingSize / particleSize / Engine.WORKGROUP_SIZE);

        let particlesLeftToAllocate = wantedParticlesCount;
        while (particlesLeftToAllocate > 0) {
            const idealDispatchSize = Math.ceil(particlesLeftToAllocate / Engine.WORKGROUP_SIZE);

            const dispatchSize = Math.min(idealDispatchSize, maxDispatchSize);
            const particlesCount = dispatchSize * Engine.WORKGROUP_SIZE;
            particlesLeftToAllocate -= particlesCount;

            const gpuBufferSize = particlesCount * particleSize;
            const gpuBuffer = WebGPU.device!.createBuffer({
                size: gpuBufferSize,
                usage: GPUBufferUsage.VERTEX | GPUBufferUsage.STORAGE,
                mappedAtCreation: true,
            });
            totalGpuBufferSize += gpuBufferSize;
            const colorsBufferSize = particlesCount * Uint32Array.BYTES_PER_ELEMENT;
            const colorsGpuBuffer = WebGPU.device!.createBuffer({
                size: colorsBufferSize,
                usage: GPUBufferUsage.VERTEX | GPUBufferUsage.STORAGE,
                mappedAtCreation: false,
            });
            totalColorBufferSize += colorsBufferSize;

            const gpuBufferData = gpuBuffer.getMappedRange();
            const particlesBuffer = new Float32Array(gpuBufferData);
            for (let iParticle = 0; iParticle < particlesCount; iParticle++) {
                particlesBuffer[4 * iParticle + 0] = Math.random() * 2 - 1;
                particlesBuffer[4 * iParticle + 1] = Math.random() * 2 - 1;
                particlesBuffer[4 * iParticle + 2] = 0;
                particlesBuffer[4 * iParticle + 3] = 0;
            }
            gpuBuffer.unmap();

            const computeBindgroup = WebGPU.device!.createBindGroup({
                layout: this.computePipeline.getBindGroupLayout(0),
                entries: [
                    {
                        binding: 0,
                        resource: {
                            buffer: gpuBuffer
                        }
                    },
                    {
                        binding: 1,
                        resource: {
                            buffer: this.computeUniformsBuffer
                        }
                    }
                ]
            });

            const initializeColorsComputeBindgroup = WebGPU.device!.createBindGroup({
                layout: this.initializeColorsComputePipeline.getBindGroupLayout(0),
                entries: [
                    {
                        binding: 0,
                        resource: {
                            buffer: gpuBuffer
                        }
                    },
                    {
                        binding: 1,
                        resource: {
                            buffer: colorsGpuBuffer
                        }
                    }
                ]
            });

            this.particleBatches.push({
                gpuBuffer,
                computeBindgroup,
                colorsBuffer: colorsGpuBuffer,
                initializeColorsComputeBindgroup,
                particlesCount,
                dispatchSize,
            });
        }

        console.info(`GPU memory used:\n  - positions/velocities: ${bytesToString(totalGpuBufferSize)}\n  - colors: ${bytesToString(totalColorBufferSize)}`);
    }

    public initializeColors(commandEncoder: GPUCommandEncoder, sampler: GPUSampler, texture: GPUTexture): void {
        const textureBindgroup = WebGPU.device!.createBindGroup({
            layout: this.initializeColorsComputePipeline.getBindGroupLayout(1),
            entries: [
                {
                    binding: 0,
                    resource: sampler
                },
                {
                    binding: 1,
                    resource: texture.createView()
                }
            ]
        });

        for (const particlesBatch of this.particleBatches) {
            const computePass = commandEncoder.beginComputePass();
            computePass.setPipeline(this.initializeColorsComputePipeline);
            computePass.setBindGroup(0, particlesBatch.initializeColorsComputeBindgroup);
            computePass.setBindGroup(1, textureBindgroup);
            computePass.dispatchWorkgroups(particlesBatch.dispatchSize);
            computePass.end();
        }
    }

    private buildComputeUniforms(dt: number, aspectRatio: number, force: Attractors.Force, attractors: Attractors.Attractor[]): ArrayBuffer {
        if (attractors.length > MAX_ATTRACTORS) {
            throw new Error(`Too many attractors (${attractors.length}, max is ${MAX_ATTRACTORS}).`);
        }

        const buffer = new ArrayBuffer(96);

        new Float32Array(buffer, 0, 2).set([force[0], force[1]]);
        new Float32Array(buffer, 8, 1).set([dt]);
        new Uint32Array(buffer, 12, 1).set([Parameters.bounce ? 1 : 0]);
        new Float32Array(buffer, 16, 1).set([Parameters.friction]);
        new Float32Array(buffer, 20, 1).set([aspectRatio]);
        new Uint32Array(buffer, 24, 1).set([attractors.length]);

        const attractorsData: number[] = [];
        for (const attractor of attractors) {
            attractorsData.push(attractor.position[0]);
            attractorsData.push(attractor.position[1]);
            attractorsData.push(attractor.force);
            attractorsData.push(0); // padding
        }
        new Float32Array(buffer, 32, attractorsData.length).set(attractorsData);

        return buffer;
    }
}

export {
    Engine,
};




================================================
FILE: src/ts/helpers.ts
================================================
function bytesToString(bytes: number): string {
    let quantity: number;
    let unit: string;

    if (bytes < 1024) {
        quantity = bytes;
        unit = "B";
    } else if (bytes < 1024 * 1024) {
        quantity = bytes / 1024;
        unit = "KB";
    } else {
        quantity = bytes / 1024 / 1024;
        unit = "MB";
    }

    return Math.ceil(quantity).toLocaleString() + " " + unit;
}

export {
    bytesToString,
};



================================================
FILE: src/ts/image.ts
================================================
import * as WebGPU from "./webgpu-utils/webgpu-device";

type Texture = {
    path: string;
    gpuTexture: GPUTexture;
}

let linearSampler: GPUSampler;
let texture: Texture;

async function getTexture(path: string): Promise<GPUTexture> {
    if (!texture || texture.path !== path) {
        if (texture) {
            texture.gpuTexture.destroy();
        }

        const image = document.createElement("img");
        image.src = path;
        await image.decode();
        const imageBitmap = await createImageBitmap(image);

        const gpuTexture = WebGPU.device!.createTexture({
            size: [imageBitmap.width, imageBitmap.height, 1],
            format: 'rgba8unorm',
            usage:
                GPUTextureUsage.TEXTURE_BINDING |
                GPUTextureUsage.COPY_DST |
                GPUTextureUsage.RENDER_ATTACHMENT
        });
        WebGPU.device!.queue.copyExternalImageToTexture(
            { source: imageBitmap },
            { texture: gpuTexture },
            [imageBitmap.width, imageBitmap.height]
        );

        texture = {
            path,
            gpuTexture
        };
    }

    return texture.gpuTexture;
}

function getSampler(): GPUSampler {
    if (!linearSampler) {
        linearSampler = WebGPU.device!.createSampler({
            addressModeU: "clamp-to-edge",
            addressModeV: "clamp-to-edge",
            magFilter: "linear",
            minFilter: "linear",
        });
    }
    return linearSampler;
}

export {
    getSampler,
    getTexture,
};



================================================
FILE: src/ts/main.ts
================================================
/// <reference types="./page-interface-generated" />

import { Engine } from "./engine";
import * as Image from "./image";
import { ColorMode, Parameters } from "./parameters";
import { WebGPUCanvas } from "./webgpu-utils/webgpu-canvas";
import * as WebGPU from "./webgpu-utils/webgpu-device";
import * as Attractors from "./attractors";

async function main(canvas: HTMLCanvasElement, canvasContainer: HTMLElement): Promise<void> {
    await WebGPU.initialize();
    const device = WebGPU.device as GPUDevice;
    const webgpuCanvas = new WebGPUCanvas(canvas);
    const engine = new Engine(webgpuCanvas.textureFormat);
    Attractors.setContainer(canvasContainer);

    let lastRun = performance.now();

    let needToReset = true;
    Parameters.resetObservers.push(() => { needToReset = true; });

    async function mainLoop(): Promise<void> {
        const now = performance.now();
        const dt = Parameters.speed * Math.min(1 / 60, 0.001 * (now - lastRun));
        lastRun = now;

        const commandEncoder = device.createCommandEncoder();

        if (needToReset) {
            needToReset = false;
            engine.reset(Parameters.particlesCount);
            Page.Canvas.setIndicatorText("particles-count", engine.particlesCount.toLocaleString());

            if (Parameters.colorMode === ColorMode.MULTICOLOR) {
                const sampler = Image.getSampler();
                Page.Canvas.showLoader(true);
                const imageUrl = await Parameters.inputImageUrl();
                const image = await Image.getTexture(imageUrl);
                Page.Canvas.showLoader(false);
                engine.initializeColors(commandEncoder, sampler, image);
            }
        }

        webgpuCanvas.adjustSize();

        Attractors.update(dt);
        engine.update(commandEncoder, dt, webgpuCanvas.width / webgpuCanvas.height);
        engine.draw(commandEncoder, webgpuCanvas);

        device.queue.submit([commandEncoder.finish()]);

        requestAnimationFrame(mainLoop);
    }

    requestAnimationFrame(mainLoop);
}

const canvasElement = Page.Canvas.getCanvas();
const canvasContainer = Page.Canvas.getCanvasContainer();
if (!canvasElement || !canvasContainer) {
    throw new Error("Could not find canvas on page.");
}
main(canvasElement, canvasContainer);



================================================
FILE: src/ts/parameters.ts
================================================
/// <reference types="./page-interface-generated" />
/// <reference types="./webgpu-utils/image-type" />

import ImageUrlLadybug from "../resources/ladybug.png";
import ImageUrlColors from "../resources/colors.png";

const controlId = {
    PARTICLES_COUNT_ID: "particles-count-range-id",
    SPEED_RANGE_ID: "speed-range-id",
    FRICTION_RANGE_ID: "friction-range-id",
    BOUNCE_CHECKBOX_ID: "bounce-checkbox-id",
    GRAVITY_RANGE_ID: "gravity-range-id",
    RESET_BUTTON_ID: "reset-button-id",

    ATTRACTION_RANGE_ID: "attraction-range-id",
    ATTRACTORS_PRESET_SELECT_ID: "attractors-preset-select-id",
    ATTRACTORS_DISPLAY_CHECKBOX_ID: "display-attractors-checkbox-id",

    COLOR_MODE_TABS_ID: "colors-mode-tabs-id",
    COLOR_AUTO_CHECKBOX_ID: "auto-color-checkbox-id",
    COLOR_HIGH_QUALITY_CHECKBOX_ID: "high-color-quality-checkbox-id",
    PARTICLE_COLORPICKER_ID: "particle-color-id",
    COLOR_SOURCE_TABS_ID: "color-source-tabs-id",
    IMAGE_SELECT_ID: "image-preset-select-id",
    IMAGE_UPLOAD_BUTTON_ID: "input-image-upload-button",

    SPRITE_SIZE_RANGE_ID: "sprite-size-range-id",
    BLENDING_CHECKBOX_ID: "blending-checkbox-id",
    OPACITY_RANGE_ID: "opacity-range-id",
    SHOW_INDICATORS_CHECKBOX_ID: "show-indicators-checkbox-id",
};

type VoidObserver = () => void;

enum AttractorsPreset {
    NONE = "none",
    ORBIT = "orbit",
    SINES = "sines",
    CENTRAL_ATTRACTIVE = "central-attractive",
    CENTRAL_REPULSIVE = "central-repulsive",
}

enum ColorMode {
    UNICOLOR = "unicolor",
    MULTICOLOR = "multicolor",
}

enum ColorSource {
    IMAGE = "image",
    VELOCITY = "velocity",
}

enum ImagePreset {
    COLORS = "colors",
    LADYBUG = "ladybug"
}

let customImageFile: File | null = null;

abstract class Parameters {
    public static readonly resetObservers: VoidObserver[] = [];
    public static readonly speedChangeObservers: VoidObserver[] = [];

    public static get particlesCount(): number {
        return 1000000 * Page.Range.getValue(controlId.PARTICLES_COUNT_ID);
    }
    public static get speed(): number {
        return Page.Range.getValue(controlId.SPEED_RANGE_ID);
    }
    public static get friction(): number {
        return Page.Range.getValue(controlId.FRICTION_RANGE_ID);
    }
    public static get bounce(): boolean {
        return Page.Checkbox.isChecked(controlId.BOUNCE_CHECKBOX_ID);
    }
    public static get gravity(): number {
        return Page.Range.getValue(controlId.GRAVITY_RANGE_ID);
    }

    public static get attraction(): number {
        return Page.Range.getValue(controlId.ATTRACTION_RANGE_ID);
    }
    public static get attractorsPreset(): AttractorsPreset {
        return Page.Select.getValue(controlId.ATTRACTORS_PRESET_SELECT_ID) as AttractorsPreset;
    }
    public static get displayAttractors(): boolean {
        return Page.Checkbox.isChecked(controlId.ATTRACTORS_DISPLAY_CHECKBOX_ID);
    }

    public static get colorMode(): ColorMode {
        return Page.Tabs.getValues(controlId.COLOR_MODE_TABS_ID)[0] as ColorMode;
    }
    public static get autoColor(): boolean {
        return Page.Checkbox.isChecked(controlId.COLOR_AUTO_CHECKBOX_ID);
    }
    public static get highColorQuality(): boolean {
        return Page.Checkbox.isChecked(controlId.COLOR_HIGH_QUALITY_CHECKBOX_ID);
    }
    public static get particleColor(): [number, number, number] {
        if (Parameters.autoColor) {
            const cycleLength = 60000;
            const now = (performance.now() % cycleLength) / cycleLength * 6;
            const min = 0.2;
            let r = min, g = min, b = min;
            if (now < 1) {
                r = 1;
                g = min + (1 - min) * now;
            } else if (now < 2) {
                r = min + (1 - min) * (2 - now);
                g = 1;
            } else if (now < 3) {
                g = 1;
                b = min + (1 - min) * (now - 2);
            } else if (now < 4) {
                g = min + (1 - min) * (4 - now);
                b = 1;
            } else if (now < 5) {
                r = min + (1 - min) * (now - 4);
                b = 1;
            } else {
                r = 1;
                b = min + (1 - min) * (6 - now);
            }
            return [r, g, b];
        } else {
            const color = Page.ColorPicker.getValue(controlId.PARTICLE_COLORPICKER_ID);
            return [color.r / 255, color.g / 255, color.b / 255];
        }
    }
    public static get colorSource(): ColorSource {
        return Page.Tabs.getValues(controlId.COLOR_SOURCE_TABS_ID)[0] as ColorSource;
    }
    public static async inputImageUrl(): Promise<string> {
        if (customImageFile) {
            return new Promise<string>((resolve: (value: string) => void) => {
                if (customImageFile) {
                    const reader = new FileReader();
                    reader.onload = () => {
                        resolve(reader.result!.toString());
                    };
                    reader.readAsDataURL(customImageFile);
                }
            });
        } else {
            const imagePreset = Page.Select.getValue(controlId.IMAGE_SELECT_ID) as ImagePreset;
            if (imagePreset === ImagePreset.COLORS) {
                return ImageUrlColors;
            } else {
                return ImageUrlLadybug;
            }
        }
    }

    public static get spriteSize(): number {
        return Page.Range.getValue(controlId.SPRITE_SIZE_RANGE_ID);
    }
    public static get blending(): boolean {
        return Page.Checkbox.isChecked(controlId.BLENDING_CHECKBOX_ID);
    }
    public static get opacity(): number {
        return Page.Range.getValue(controlId.OPACITY_RANGE_ID);
    }
}

Page.Range.addObserver(controlId.SPEED_RANGE_ID, () => {
    for (const observer of Parameters.speedChangeObservers) {
        observer();
    }
});

function callResetObservers(): void {
    for (const observer of Parameters.resetObservers) {
        observer();
    }
}

function updateColorsVisibility(): void {
    const isUnicolor = (Parameters.colorMode === ColorMode.UNICOLOR);
    const imageColorSource = (Parameters.colorSource === ColorSource.IMAGE);
    Page.Controls.setVisibility(controlId.COLOR_AUTO_CHECKBOX_ID, isUnicolor);
    Page.Controls.setVisibility(controlId.COLOR_HIGH_QUALITY_CHECKBOX_ID, isUnicolor);
    Page.Controls.setVisibility(controlId.PARTICLE_COLORPICKER_ID, isUnicolor && !Parameters.autoColor);
    Page.Controls.setVisibility(controlId.COLOR_SOURCE_TABS_ID, !isUnicolor);
    Page.Controls.setVisibility(controlId.IMAGE_SELECT_ID, !isUnicolor && imageColorSource);
    Page.Controls.setVisibility(controlId.IMAGE_UPLOAD_BUTTON_ID, !isUnicolor && imageColorSource);
}

Page.Range.addLazyObserver(controlId.PARTICLES_COUNT_ID, callResetObservers);
Page.Button.addObserver(controlId.RESET_BUTTON_ID, callResetObservers);
Page.Tabs.addObserver(controlId.COLOR_MODE_TABS_ID, () => {
    updateColorsVisibility();
    if (Parameters.colorMode === ColorMode.MULTICOLOR) {
        callResetObservers();
    }
});
Page.Checkbox.addObserver(controlId.COLOR_AUTO_CHECKBOX_ID, updateColorsVisibility);
Page.Tabs.addObserver(controlId.COLOR_SOURCE_TABS_ID, updateColorsVisibility);
Page.Select.addObserver(controlId.IMAGE_SELECT_ID, () => {
    customImageFile = null;
    Page.FileControl.clearFileUpload(controlId.IMAGE_UPLOAD_BUTTON_ID);
    callResetObservers();
});

Page.FileControl.addUploadObserver(controlId.IMAGE_UPLOAD_BUTTON_ID, (filesList: FileList) => {
    Page.Select.setValue(controlId.IMAGE_SELECT_ID, null);
    customImageFile = filesList[0] || null;
    callResetObservers();
});

updateColorsVisibility();

Page.Checkbox.addObserver(controlId.SHOW_INDICATORS_CHECKBOX_ID, (show: boolean) => {
    Page.Canvas.setIndicatorsVisibility(show);
});
Page.Canvas.setIndicatorsVisibility(Page.Checkbox.isChecked(controlId.SHOW_INDICATORS_CHECKBOX_ID));

Page.Checkbox.addObserver(controlId.BLENDING_CHECKBOX_ID, (hasBlending: boolean) => {
    Page.Controls.setVisibility(controlId.OPACITY_RANGE_ID, hasBlending);
});
Page.Controls.setVisibility(controlId.OPACITY_RANGE_ID, Page.Checkbox.isChecked(controlId.BLENDING_CHECKBOX_ID));

export {
    AttractorsPreset,
    ColorMode,
    ColorSource,
    Parameters,
};



================================================
FILE: src/ts/render/composition.ts
================================================
import ShaderSource from "../../shaders/composition.wgsl";
import { Parameters } from "../parameters";
import { WebGPUCanvas } from "../webgpu-utils/webgpu-canvas";
import * as WebGPU from "../webgpu-utils/webgpu-device";

class Composition {
    private readonly pipeline: GPURenderPipeline;

    private readonly uniformsBuffer: GPUBuffer;

    private texture: GPUTexture;
    private textureWidth: number = -1;
    private textureHeight: number = -1;
    private textureSampler: GPUSampler;
    private bindgroup: GPUBindGroup;
    public readonly textureFormat: GPUTextureFormat = "r8unorm";
    private renderToTexturePassDescriptor: GPURenderPassDescriptor;

    public constructor(targetTextureFormat: GPUTextureFormat) {
        const shaderModule = WebGPU.device!.createShaderModule({ code: ShaderSource });

        this.pipeline = WebGPU.device!.createRenderPipeline({
            vertex: {
                module: shaderModule,
                entryPoint: "main_vertex",
                buffers: []
            },
            fragment: {
                module: shaderModule,
                entryPoint: "main_fragment",
                targets: [{
                    format: targetTextureFormat,
                }],
            },
            primitive: {
                cullMode: "none",
                topology: "triangle-strip",
            },
            layout: "auto"
        });
        
        this.uniformsBuffer = WebGPU.device!.createBuffer({
            size: 32, // useful size: 20
            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM,
        });

        this.textureSampler = WebGPU.device!.createSampler({
            addressModeU: "clamp-to-edge",
            addressModeV: "clamp-to-edge",
            magFilter: "linear",
            minFilter: "linear",
        });
    }

    public getRenderToTexturePassEncoder(commandEncoder: GPUCommandEncoder, webgpuCanvas: WebGPUCanvas): GPURenderPassEncoder {
        this.resizeTextureIfNeeded(webgpuCanvas.width, webgpuCanvas.height);

        return commandEncoder.beginRenderPass(this.renderToTexturePassDescriptor);
    }

    public apply(commandEncoder: GPUCommandEncoder, webgpuCanvas: WebGPUCanvas): void {
        const color = Parameters.particleColor;
        const uniformsData = new ArrayBuffer(20);
        new Float32Array(uniformsData, 0, 4).set([color[0], color[1], color[2], Parameters.opacity]);
        new Uint32Array(uniformsData, 16, 1).set([Parameters.blending ? 1 : 0]);
        WebGPU.device!.queue.writeBuffer(this.uniformsBuffer, 0, uniformsData);

        const renderPassEncoder = webgpuCanvas.beginRenderPass(commandEncoder);
        renderPassEncoder.setPipeline(this.pipeline);
        renderPassEncoder.setBindGroup(0, this.bindgroup);
        renderPassEncoder.draw(4, 1, 0, 0);
        renderPassEncoder.end();
    }

    private resizeTextureIfNeeded(wantedWidth: number, wantedHeight: number): void {
        if (this.textureWidth !== wantedWidth || this.textureHeight !== wantedHeight) {
            if (this.texture) {
                this.texture.destroy();
            }

            this.texture = WebGPU.device!.createTexture({
                size: [wantedWidth, wantedHeight],
                format: this.textureFormat,
                usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING,
            });
            this.textureWidth = wantedWidth;
            this.textureHeight = wantedHeight;

            this.bindgroup = WebGPU.device!.createBindGroup({
                layout: this.pipeline.getBindGroupLayout(0),
                entries: [
                    {
                        binding: 0,
                        resource: {
                            buffer: this.uniformsBuffer,
                        }
                    },
                    {
                        binding: 1,
                        resource: this.texture.createView()
                    },
                    {
                        binding: 2,
                        resource: this.textureSampler
                    }
                ]
            });

            this.renderToTexturePassDescriptor = {
                colorAttachments: [{
                    view: this.texture.createView(),
                    loadOp: 'clear',
                    clearValue: {r: 0, g: 0, b: 0, a: 0},
                    storeOp: 'store'
                }],
            };
        }
    }
}

export {
    Composition,
};



================================================
FILE: src/ts/render/i-renderer.ts
================================================
import { WebGPUCanvas } from "../webgpu-utils/webgpu-canvas";

type RenderableParticlesBatch = {
    gpuBuffer: GPUBuffer;
    colorsBuffer: GPUBuffer;
    particlesCount: number;
}

interface IRenderer {
    particleColor: [number, number, number];
    particleOpacity: number;
    enableAdditiveBlending: boolean;
    spriteSize: number;

    draw(commandEncoder: GPUCommandEncoder, webgpuCanvas: WebGPUCanvas, particleBatches: RenderableParticlesBatch[]): void;
}

export type {
    IRenderer,
    RenderableParticlesBatch,
};



================================================
FILE: src/ts/render/renderer-high-quality.ts
================================================
import { WebGPUCanvas } from "../webgpu-utils/webgpu-canvas";
import { Composition } from "./composition";
import { IRenderer } from "./i-renderer";
import { RendererInstancedMonocolor } from "./renderer-instanced-monocolor";
import { RendererMonocolor } from "./renderer-monocolor";

type RenderableParticlesBatch = {
    gpuBuffer: GPUBuffer;
    particlesCount: number;
}

// Rather than accumulating directly particles color,
// this renderer uses deferred rendering to:
// - first count the particles count per pixel (render to texture with additive blending)
// - then compute the final color during compositing.
abstract class RendererHighQuality implements IRenderer {
    public particleColor: [number, number, number] = [0, 0, 0];
    public particleOpacity: number = 1;
    public enableAdditiveBlending: boolean = true;
    public spriteSize: number = 2;

    protected abstract readonly renderer: RendererMonocolor | RendererInstancedMonocolor;
    protected readonly composition: Composition;

    protected constructor(targetTextureFormat: GPUTextureFormat) {
        this.composition = new Composition(targetTextureFormat);
    }

    public draw(commandEncoder: GPUCommandEncoder, webgpuCanvas: WebGPUCanvas, particlesBatches: RenderableParticlesBatch[]): void {
        this.renderToTexture(commandEncoder, webgpuCanvas, particlesBatches);
        this.applyComposition(commandEncoder, webgpuCanvas);
    }

    private renderToTexture(commandEncoder: GPUCommandEncoder, webgpuCanvas: WebGPUCanvas, particlesBatches: RenderableParticlesBatch[]): void {
        this.renderer.particleColor = [1 / 255, 0, 0];
        this.renderer.particleOpacity = 1;
        this.renderer.enableAdditiveBlending = true;
        this.renderer.spriteSize = this.spriteSize;

        const textureRenderPassEncoder = this.composition.getRenderToTexturePassEncoder(commandEncoder, webgpuCanvas);
        this.renderer.drawInternal(textureRenderPassEncoder, webgpuCanvas.width, webgpuCanvas.height, particlesBatches);
        textureRenderPassEncoder.end();
    }

    private applyComposition(commandEncoder: GPUCommandEncoder, webgpuCanvas: WebGPUCanvas): void {
        this.composition.apply(commandEncoder, webgpuCanvas);
    }
}

export {
    RendererHighQuality,
};



================================================
FILE: src/ts/render/renderer-instanced-monocolor-high-quality.ts
================================================
/// <reference types="../webgpu-utils/wgsl-type" />

import { RendererHighQuality } from "./renderer-high-quality";
import { RendererInstancedMonocolor } from "./renderer-instanced-monocolor";

class RendererInstancedMonocolorHighQuality extends RendererHighQuality {
    protected readonly renderer: RendererInstancedMonocolor;

    public constructor(targetTextureFormat: GPUTextureFormat) {
        super(targetTextureFormat);
        this.renderer = new RendererInstancedMonocolor(this.composition.textureFormat);
    }
}

export {
    RendererInstancedMonocolorHighQuality,
};




================================================
FILE: src/ts/render/renderer-instanced-monocolor.ts
================================================
/// <reference types="../webgpu-utils/wgsl-type" />

import ShaderSource from "../../shaders/draw-instanced-monocolor.wgsl";
import * as WebGPU from "../webgpu-utils/webgpu-device";
import { RendererInstanced } from "./renderer-instanced";

type RenderableParticlesBatch = {
    gpuBuffer: GPUBuffer;
    particlesCount: number;
}

class RendererInstancedMonocolor extends RendererInstanced {
    public constructor(targetTextureFormat: GPUTextureFormat) {
        super(targetTextureFormat);

        const shaderModule = WebGPU.device!.createShaderModule({ code: ShaderSource });

        this.createRenderPipelines({
            vertex: {
                module: shaderModule,
                entryPoint: "main_vertex",
                buffers: [
                    {
                        attributes: [
                            {
                                shaderLocation: 0,
                                offset: 0,
                                format: "float32x2",
                            }
                        ],
                        arrayStride: Float32Array.BYTES_PER_ELEMENT * 4,
                        stepMode: "instance",
                    },
                    {
                        attributes: [
                            {
                                shaderLocation: 1,
                                offset: 0,
                                format: "float32x2",
                            }
                        ],
                        arrayStride: Float32Array.BYTES_PER_ELEMENT * 2,
                        stepMode: "vertex",
                    }
                ]
            },
            fragment: {
                module: shaderModule,
                entryPoint: "main_fragment",
                targets: [],
            },
            primitive: {
                cullMode: "none",
                topology: "triangle-list",
            },
            layout: "auto"
        });
    }

    public override drawInternal(renderPassEncoder: GPURenderPassEncoder, canvasWidth: number, canvasHeight: number, particleBatches: RenderableParticlesBatch[]): void {
        super.updateUniformsBuffer(canvasWidth, canvasHeight);

        renderPassEncoder.setPipeline(this.pipeline.renderPipeline);
        renderPassEncoder.setBindGroup(0, this.pipeline.uniformsBindgroup);
        renderPassEncoder.setVertexBuffer(1, this.quadBuffer);
        for (const particlesBatch of particleBatches) {
            renderPassEncoder.setVertexBuffer(0, particlesBatch.gpuBuffer);
            renderPassEncoder.draw(6, particlesBatch.particlesCount, 0, 0);
        }
    }
}

export {
    RendererInstancedMonocolor,
};




================================================
FILE: src/ts/render/renderer-instanced-multicolor-velocity.ts
================================================
/// <reference types="../webgpu-utils/wgsl-type" />

import ShaderSource from "../../shaders/draw-instanced-multicolor-velocity.wgsl";
import ColorShaderPartSource from "../../shaders/utils/color.part.wgsl";
import * as WebGPU from "../webgpu-utils/webgpu-device";
import { RendererInstanced } from "./renderer-instanced";

type RenderableParticlesBatch = {
    gpuBuffer: GPUBuffer;
    particlesCount: number;
}

class RendererInstancedMulticolorVelocity extends RendererInstanced {
    public constructor(targetTextureFormat: GPUTextureFormat) {
        super(targetTextureFormat);

        const shaderModule = WebGPU.device!.createShaderModule({ code: ColorShaderPartSource + ShaderSource });

        this.createRenderPipelines({
            vertex: {
                module: shaderModule,
                entryPoint: "main_vertex",
                buffers: [
                    {
                        attributes: [
                            {
                                shaderLocation: 0,
                                offset: 0,
                                format: "float32x2",
                            },
                            {
                                shaderLocation: 1,
                                offset: Float32Array.BYTES_PER_ELEMENT * 2,
                                format: "float32x2",
                            }
                        ],
                        arrayStride: Float32Array.BYTES_PER_ELEMENT * 4,
                        stepMode: "instance",
                    },
                    {
                        attributes: [
                            {
                                shaderLocation: 2,
                                offset: 0,
                                format: "float32x2",
                            }
                        ],
                        arrayStride: Float32Array.BYTES_PER_ELEMENT * 2,
                        stepMode: "vertex",
                    }
                ]
            },
            fragment: {
                module: shaderModule,
                entryPoint: "main_fragment",
                targets: [],
            },
            primitive: {
                cullMode: "none",
                topology: "triangle-list",
            },
            layout: "auto"
        });
    }

    public override drawInternal(renderPassEncoder: GPURenderPassEncoder, canvasWidth: number, canvasHeight: number, particleBatches: RenderableParticlesBatch[]): void {
        super.updateUniformsBuffer(canvasWidth, canvasHeight);

        renderPassEncoder.setPipeline(this.pipeline.renderPipeline);
        renderPassEncoder.setBindGroup(0, this.pipeline.uniformsBindgroup);
        renderPassEncoder.setVertexBuffer(1, this.quadBuffer);
        for (const particlesBatch of particleBatches) {
            renderPassEncoder.setVertexBuffer(0, particlesBatch.gpuBuffer);
            renderPassEncoder.draw(6, particlesBatch.particlesCount, 0, 0);
        }
    }
}

export {
    RendererInstancedMulticolorVelocity,
};



================================================
FILE: src/ts/render/renderer-instanced-multicolor.ts
================================================
/// <reference types="../webgpu-utils/wgsl-type" />

import ShaderSource from "../../shaders/draw-instanced-multicolor.wgsl";
import ColorShaderPartSource from "../../shaders/utils/color.part.wgsl";
import * as WebGPU from "../webgpu-utils/webgpu-device";
import { RendererInstanced } from "./renderer-instanced";

type RenderableParticlesBatch = {
    gpuBuffer: GPUBuffer;
    colorsBuffer: GPUBuffer;
    particlesCount: number;
}

class RendererInstancedMulticolor extends RendererInstanced {
    public constructor(targetTextureFormat: GPUTextureFormat) {
        super(targetTextureFormat);

        const shaderModule = WebGPU.device!.createShaderModule({ code: ColorShaderPartSource + ShaderSource });

        this.createRenderPipelines({
            vertex: {
                module: shaderModule,
                entryPoint: "main_vertex",
                buffers: [
                    {
                        attributes: [
                            {
                                shaderLocation: 0,
                                offset: 0,
                                format: "float32x2",
                            }
                        ],
                        arrayStride: Float32Array.BYTES_PER_ELEMENT * 4,
                        stepMode: "instance",
                    },
                    {
                        attributes: [
                            {
                                shaderLocation: 1,
                                offset: 0,
                                format: "float32x2",
                            }
                        ],
                        arrayStride: Float32Array.BYTES_PER_ELEMENT * 2,
                        stepMode: "vertex",
                    },
                    {
                        attributes: [
                            {
                                shaderLocation: 2,
                                offset: 0,
                                format: "uint32",
                            }
                        ],
                        arrayStride: Uint32Array.BYTES_PER_ELEMENT,
                        stepMode: "instance",
                    }
                ]
            },
            fragment: {
                module: shaderModule,
                entryPoint: "main_fragment",
                targets: [],
            },
            primitive: {
                cullMode: "none",
                topology: "triangle-list",
            },
            layout: "auto"
        });
    }

    public override drawInternal(renderPassEncoder: GPURenderPassEncoder, canvasWidth: number, canvasHeight: number, particleBatches: RenderableParticlesBatch[]): void {
        super.updateUniformsBuffer(canvasWidth, canvasHeight);

        renderPassEncoder.setPipeline(this.pipeline.renderPipeline);
        renderPassEncoder.setBindGroup(0, this.pipeline.uniformsBindgroup);
        renderPassEncoder.setVertexBuffer(1, this.quadBuffer);
        for (const particlesBatch of particleBatches) {
            renderPassEncoder.setVertexBuffer(0, particlesBatch.gpuBuffer);
            renderPassEncoder.setVertexBuffer(2, particlesBatch.colorsBuffer);
            renderPassEncoder.draw(6, particlesBatch.particlesCount, 0, 0);
        }
    }
}

export {
    RendererInstancedMulticolor,
};



================================================
FILE: src/ts/render/renderer-instanced.ts
================================================
/// <reference types="../webgpu-utils/wgsl-type" />

import * as WebGPU from "../webgpu-utils/webgpu-device";
import { Renderer } from "./renderer";

abstract class RendererInstanced extends Renderer {
    protected readonly quadBuffer: GPUBuffer;

    public constructor(targetTextureFormat: GPUTextureFormat) {
        super(targetTextureFormat);

        this.quadBuffer = WebGPU.device!.createBuffer({
            size: Float32Array.BYTES_PER_ELEMENT * 2 * 6,
            usage: GPUBufferUsage.VERTEX,
            mappedAtCreation: true,
        });
        new Float32Array(this.quadBuffer.getMappedRange()).set([
            -1, -1, +1, -1, +1, +1,
            -1, -1, +1, +1, -1, +1
        ]);
        this.quadBuffer.unmap();
    }
}

export {
    RendererInstanced,
};




================================================
FILE: src/ts/render/renderer-monocolor-high-quality.ts
================================================
/// <reference types="../webgpu-utils/wgsl-type" />

import { RendererHighQuality } from "./renderer-high-quality";
import { RendererMonocolor } from "./renderer-monocolor";

class RendererMonocolorHighQuality extends RendererHighQuality {
    protected readonly renderer: RendererMonocolor;

    public constructor(targetTextureFormat: GPUTextureFormat) {
        super(targetTextureFormat);
        this.renderer = new RendererMonocolor(this.composition.textureFormat);
    }
}

export {
    RendererMonocolorHighQuality,
};




================================================
FILE: src/ts/render/renderer-monocolor.ts
================================================
/// <reference types="../webgpu-utils/wgsl-type" />

import ShaderSource from "../../shaders/draw-monocolor.wgsl";
import * as WebGPU from "../webgpu-utils/webgpu-device";
import { Renderer } from "./renderer";

type RenderableParticlesBatch = {
    gpuBuffer: GPUBuffer;
    particlesCount: number;
}

class RendererMonocolor extends Renderer {
    public constructor(targetTextureFormat: GPUTextureFormat) {
        super(targetTextureFormat);

        const shaderModule = WebGPU.device!.createShaderModule({ code: ShaderSource });

        this.createRenderPipelines({
            vertex: {
                module: shaderModule,
                entryPoint: "main_vertex",
                buffers: [
                    {
                        attributes: [
                            {
                                shaderLocation: 0,
                                offset: 0,
                                format: "float32x2",
                            }
                        ],
                        arrayStride: Float32Array.BYTES_PER_ELEMENT * 4,
                        stepMode: "vertex",
                    }
                ]
            },
            fragment: {
                module: shaderModule,
                entryPoint: "main_fragment",
                targets: [],
            },
            primitive: {
                cullMode: "none",
                topology: "point-list",
            },
            layout: "auto"
        });
    }

    public override drawInternal(renderPassEncoder: GPURenderPassEncoder, canvasWidth: number, canvasHeight: number, particleBatches: RenderableParticlesBatch[]): void {
        super.updateUniformsBuffer(canvasWidth, canvasHeight);

        renderPassEncoder.setPipeline(this.pipeline.renderPipeline);
        renderPassEncoder.setBindGroup(0, this.pipeline.uniformsBindgroup);
        for (const particlesBatch of particleBatches) {
            renderPassEncoder.setVertexBuffer(0, particlesBatch.gpuBuffer);
            renderPassEncoder.draw(particlesBatch.particlesCount, 1, 0, 0);
        }
    }
}

export {
    RendererMonocolor,
};




================================================
FILE: src/ts/render/renderer-multicolor-velocity.ts
================================================
/// <reference types="../webgpu-utils/wgsl-type" />

import ShaderSource from "../../shaders/draw-multicolor-velocity.wgsl";
import ColorShaderPartSource from "../../shaders/utils/color.part.wgsl";
import * as WebGPU from "../webgpu-utils/webgpu-device";
import { Renderer } from "./renderer";

type RenderableParticlesBatch = {
    gpuBuffer: GPUBuffer;
    particlesCount: number;
}

class RendererMulticolorVelocity extends Renderer {
    public constructor(targetTextureFormat: GPUTextureFormat) {
        super(targetTextureFormat);

        const shaderModule = WebGPU.device!.createShaderModule({ code: ColorShaderPartSource + ShaderSource });

        this.createRenderPipelines({
            vertex: {
                module: shaderModule,
                entryPoint: "main_vertex",
                buffers: [
                    {
                        attributes: [
                            {
                                shaderLocation: 0,
                                offset: 0,
                                format: "float32x2",
                            },
                            {
                                shaderLocation: 1,
                                offset: Float32Array.BYTES_PER_ELEMENT * 2,
                                format: "float32x2",
                            }
                        ],
                        arrayStride: Float32Array.BYTES_PER_ELEMENT * 4,
                        stepMode: "vertex",
                    }
                ]
            },
            fragment: {
                module: shaderModule,
                entryPoint: "main_fragment",
                targets: [],
            },
            primitive: {
                cullMode: "none",
                topology: "point-list",
            },
            layout: "auto"
        });
    }

    public override drawInternal(renderPassEncoder: GPURenderPassEncoder, canvasWidth: number, canvasHeight: number, particleBatches: RenderableParticlesBatch[]): void {
        super.updateUniformsBuffer(canvasWidth, canvasHeight);

        renderPassEncoder.setPipeline(this.pipeline.renderPipeline);
        renderPassEncoder.setBindGroup(0, this.pipeline.uniformsBindgroup);
        for (const particlesBatch of particleBatches) {
            renderPassEncoder.setVertexBuffer(0, particlesBatch.gpuBuffer);
            renderPassEncoder.draw(particlesBatch.particlesCount, 1, 0, 0);
        }
    }
}

export {
    RendererMulticolorVelocity,
};




================================================
FILE: src/ts/render/renderer-multicolor.ts
================================================
/// <reference types="../webgpu-utils/wgsl-type" />

import ShaderSource from "../../shaders/draw-multicolor.wgsl";
import ColorShaderPartSource from "../../shaders/utils/color.part.wgsl";
import * as WebGPU from "../webgpu-utils/webgpu-device";
import { Renderer } from "./renderer";

type RenderableParticlesBatch = {
    gpuBuffer: GPUBuffer;
    colorsBuffer: GPUBuffer;
    particlesCount: number;
}

class RendererMulticolor extends Renderer {
    public constructor(targetTextureFormat: GPUTextureFormat) {
        super(targetTextureFormat);

        const shaderModule = WebGPU.device!.createShaderModule({ code: ColorShaderPartSource + ShaderSource });

        this.createRenderPipelines({
            vertex: {
                module: shaderModule,
                entryPoint: "main_vertex",
                buffers: [
                    {
                        attributes: [
                            {
                                shaderLocation: 0,
                                offset: 0,
                                format: "float32x2",
                            }
                        ],
                        arrayStride: Float32Array.BYTES_PER_ELEMENT * 4,
                        stepMode: "vertex",
                    },
                    {
                        attributes: [
                            {
                                shaderLocation: 1,
                                offset: 0,
                                format: "uint32",
                            }
                        ],
                        arrayStride: Uint32Array.BYTES_PER_ELEMENT,
                        stepMode: "vertex",
                    }
                ]
            },
            fragment: {
                module: shaderModule,
                entryPoint: "main_fragment",
                targets: [],
            },
            primitive: {
                cullMode: "none",
                topology: "point-list",
            },
            layout: "auto"
        });
    }

    public override drawInternal(renderPassEncoder: GPURenderPassEncoder, canvasWidth: number, canvasHeight: number, particleBatches: RenderableParticlesBatch[]): void {
        super.updateUniformsBuffer(canvasWidth, canvasHeight);

        renderPassEncoder.setPipeline(this.pipeline.renderPipeline);
        renderPassEncoder.setBindGroup(0, this.pipeline.uniformsBindgroup);
        for (const particlesBatch of particleBatches) {
            renderPassEncoder.setVertexBuffer(0, particlesBatch.gpuBuffer);
            renderPassEncoder.setVertexBuffer(1, particlesBatch.colorsBuffer);
            renderPassEncoder.draw(particlesBatch.particlesCount, 1, 0, 0);
        }
    }
}

export {
    RendererMulticolor,
};




================================================
FILE: src/ts/render/renderer.ts
================================================
import { WebGPUCanvas } from "../webgpu-utils/webgpu-canvas";
import * as WebGPU from "../webgpu-utils/webgpu-device";
import { IRenderer, RenderableParticlesBatch } from "./i-renderer";

type Pipeline = {
    renderPipeline: GPURenderPipeline;
    uniformsBindgroup: GPUBindGroup;
}

abstract class Renderer implements IRenderer {
    public particleColor: [number, number, number] = [0, 0, 0];
    public particleOpacity: number = 1;
    public enableAdditiveBlending: boolean = true;
    public spriteSize: number = 2;

    private readonly uniformsBuffer: GPUBuffer;

    private pipelineAdditiveBlending: Pipeline;
    private pipelineNoBlending: Pipeline;

    protected constructor(private readonly targetTextureFormat: GPUTextureFormat) {
        this.uniformsBuffer = WebGPU.device!.createBuffer({
            size: 32, // useful size: 24
            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM,
        });
    }

    public draw(commandEncoder: GPUCommandEncoder, webgpuCanvas: WebGPUCanvas, particleBatches: RenderableParticlesBatch[]): void {
        const renderPassEncoder = webgpuCanvas.beginRenderPass(commandEncoder);
        this.drawInternal(renderPassEncoder, webgpuCanvas.width, webgpuCanvas.height, particleBatches);
        renderPassEncoder.end();
    }

    public abstract drawInternal(renderPassEncoder: GPURenderPassEncoder, canvasWidth: number, canvasHeight: number, particleBatches: RenderableParticlesBatch[]): void;

    protected createRenderPipelines(descriptor: GPURenderPipelineDescriptor): void {
        if (!descriptor.fragment) {
            throw new Error("Missing property 'fragment' on descriptor.");
        }

        descriptor.fragment.targets = [{
            format: this.targetTextureFormat
        }];
        this.pipelineNoBlending = this.createPipeline(descriptor);

        descriptor.fragment.targets = [{
            format: this.targetTextureFormat,
            blend: {
                color: {
                    srcFactor: 'src-alpha',
                    dstFactor: 'one',
                    operation: 'add',
                },
                alpha: {
                    srcFactor: 'zero',
                    dstFactor: 'one',
                    operation: 'add',
                }
            }
        }];
        this.pipelineAdditiveBlending = this.createPipeline(descriptor);
    }

    protected updateUniformsBuffer(canvasWidth: number, canvasHeight: number): void {
        const uniformsData = [this.particleColor[0], this.particleColor[1], this.particleColor[2], this.particleOpacity, this.spriteSize / canvasWidth, this.spriteSize / canvasHeight];
        WebGPU.device!.queue.writeBuffer(this.uniformsBuffer, 0, new Float32Array(uniformsData).buffer);
    }

    protected get pipeline(): Pipeline {
        if (this.enableAdditiveBlending) {
            return this.pipelineAdditiveBlending;
        } else {
            return this.pipelineNoBlending;
        }
    }

    private createPipeline(descriptor: GPURenderPipelineDescriptor): Pipeline {
        const pipeline = WebGPU.device!.createRenderPipeline(descriptor);
        const uniformsBindgroup = WebGPU.device!.createBindGroup({
            layout: pipeline.getBindGroupLayout(0),
            entries: [
                {
                    binding: 0,
                    resource: {
                        buffer: this.uniformsBuffer,
                    }
                }
            ]
        });
        return { renderPipeline: pipeline, uniformsBindgroup };
    }
}

export {
    Renderer,
};



================================================
FILE: src/ts/webgpu-utils/image-type.d.ts
================================================
declare module "*.png" {
    const url: string;
    export default url;
}



================================================
FILE: src/ts/webgpu-utils/webgpu-canvas.ts
================================================
import * as WebGPU from "./webgpu-device";

class WebGPUCanvas {
    private readonly devicePixelRatio: number;
    private readonly context: GPUCanvasContext;
    private readonly canvasConfiguration: GPUCanvasConfiguration;

    public readonly textureFormat: GPUTextureFormat;
    public readonly clearColor: GPUColorDict;

    public constructor(private readonly canvas: HTMLCanvasElement) {
        this.devicePixelRatio = window.devicePixelRatio;

        {
            const contextName = "webgpu";
            const context = canvas.getContext(contextName);
            if (!context) {
                throw new Error(`Failed to get a '${contextName}' context from canvas.`);
            }
            this.context = context;
        }

        this.canvasConfiguration = {
            device: WebGPU.device!,
            format: navigator.gpu.getPreferredCanvasFormat(),
            usage: GPUTextureUsage.RENDER_ATTACHMENT,
            alphaMode: "opaque",
            // no "size" attribute to use the canvas' width and height
        };
        this.context.configure(this.canvasConfiguration);
        this.adjustSize();

        this.textureFormat = this.canvasConfiguration.format;
        this.clearColor = { r: 0, g: 0, b: 0, a: 1 };
    }

    public get width(): number {
        return this.canvas.width;
    }

    public get height(): number {
        return this.canvas.height;
    }

    public adjustSize(): void {
        const actualWidth = Math.floor(this.devicePixelRatio * this.canvas.clientWidth);
        const actualHeight = Math.floor(this.devicePixelRatio * this.canvas.clientHeight);

        if (this.canvas.width !== actualWidth || this.canvas.height !== actualHeight) {
            this.canvas.width = actualWidth;
            this.canvas.height = actualHeight;
        }
    }

    public beginRenderPass(commandEncoder: GPUCommandEncoder): GPURenderPassEncoder {
        const renderPassDescriptor = this.getRenderPassDescriptor();
        const renderPassEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
        renderPassEncoder.setViewport(0, 0, this.width, this.height, 0, 1);
        renderPassEncoder.setScissorRect(0, 0, this.width, this.height);
        return renderPassEncoder;
    }

    private getRenderPassDescriptor(): GPURenderPassDescriptor {
        const colorAttachment: GPURenderPassColorAttachment = {
            view: this.context.getCurrentTexture().createView(),
            loadOp: 'clear',
            clearValue: this.clearColor,
            storeOp: 'store'
        };

        const renderPassDesc: GPURenderPassDescriptor = {
            colorAttachments: [colorAttachment],
        };

        return renderPassDesc;
    }
}

export {
    WebGPUCanvas,
};



================================================
FILE: src/ts/webgpu-utils/webgpu-device.ts
================================================
/// <reference types="../page-interface-generated" />
/// <reference types="@webgpu/types" />

function throwAndDisplayException(id: string, message: string): void {
    Page.Demopage.setErrorMessage(id, message);
    Page.Canvas.toggleFullscreen(false);
    throw new Error(message);
}

const gpu: GPU = navigator.gpu;
if (!gpu) {
    throwAndDisplayException("webgpu-support", "Your browser does not seem to support WebGPU.");
}

let adapter: GPUAdapter | null = null;
let device: GPUDevice | null = null;

async function requestDevice(): Promise<void> {
    if (!device) {
        adapter = await gpu.requestAdapter({
            powerPreference: "high-performance"
        });

        if (adapter) {
            if (adapter.isFallbackAdapter) {
                Page.Demopage.setErrorMessage("webgpu-is-fallback", "The retrieved GPU adapter is fallback. The performance might be degraded.");
            }
            device = await adapter.requestDevice();
        } else {
            throwAndDisplayException("webgpu-adapter", "Request for GPU adapter failed.");
        }
    }
}

export {
    adapter,
    device,
    gpu,
    requestDevice as initialize,
};



================================================
FILE: src/ts/webgpu-utils/wgsl-type.d.ts
================================================
declare module "*.wgsl" {
    const content: string;
    export default content;
}


