Directory structure:
└── experiences/
    ├── BaseExperience.ts
    ├── CubeExperience.ts
    ├── _template/
    │   ├── TSLExperience.ts
    │   └── WebGLExperience.ts
    ├── cursor-trails/
    │   └── CursorTrailsExperience.ts
    ├── meta-shapes/
    │   ├── constants.ts
    │   ├── MetaShapesExperience.ts
    │   └── managers/
    │       ├── ColorManager.ts
    │       ├── FormationManager.ts
    │       ├── GeometryManager.ts
    │       ├── HandTrackingManager.ts
    │       ├── MouseInteractionManager.ts
    │       └── PostProcessingManager.ts
    ├── particles/
    │   ├── constants.ts
    │   ├── lights.ts
    │   ├── ParticlesExperience.ts
    │   ├── mls-mpm/
    │   │   ├── constants.ts
    │   │   ├── Simulation.ts
    │   │   └── StructuredArray.ts
    │   └── renderers/
    │       └── ParticleRenderer.ts
    ├── pixel-flow/
    │   ├── BehavioralPatterns.ts
    │   ├── EcosystemMovementPatterns.ts
    │   ├── EcosystemStates.ts
    │   ├── IdleMovementController.ts
    │   ├── NatureRhythmEngine.ts
    │   ├── ParameterOrchestra.ts
    │   └── PixelFlowExperience.ts
    ├── shaders/
    │   ├── README.md
    │   ├── ShaderGalleryExperience.ts
    │   └── gallery/
    │       ├── index.ts
    │       ├── artistic/
    │       │   └── aurora.ts
    │       ├── effects/
    │       │   ├── kaleidoscope.ts
    │       │   └── lava-lamp.ts
    │       ├── fractals/
    │       │   ├── julia-set.ts
    │       │   └── mandelbrot.ts
    │       └── noise/
    │           └── perlin-waves.ts
    └── tweakpane-integration/
        └── TweakpaneIntegrationExperience.ts

================================================
FILE: src/vanilla-three/experiences/BaseExperience.ts
================================================
import type { IExperience } from "../types";

export interface ExperienceOptions {
  controlsContainer?: HTMLElement | null;
}

/**
 * Abstract base class for Three.js experiences.
 * Defines the minimal contract required by the ThreeCanvas component.
 * Subclasses must implement their own scene setup, animation loops, and cleanup logic.
 */
export abstract class BaseExperience implements IExperience {
  protected readonly canvas: HTMLCanvasElement;
  protected readonly options: ExperienceOptions;
  protected sizes!: { width: number; height: number; pixelRatio: number };

  constructor(canvas: HTMLCanvasElement, options: ExperienceOptions = {}) {
    this.canvas = canvas;
    this.options = options;
    this.updateSizes();
  }

  public updateSizes(): void {
    const width =
      this.canvas.parentElement?.clientWidth || this.canvas.clientWidth;
    const height =
      this.canvas.parentElement?.clientHeight || this.canvas.clientHeight;
    this.sizes = {
      width,
      height,
      pixelRatio: Math.min(window.devicePixelRatio, 2),
    };
  }

  /**
   * Initialize the Three.js experience.
   * Should set up scene, camera, renderer, objects, animations, etc.
   */
  public abstract init(): Promise<void>;

  /**
   * Clean up all resources when the experience is destroyed.
   * Should cancel animation frames, dispose geometries/materials/renderer, remove event listeners, etc.
   */
  public abstract dispose(): void;
}



================================================
FILE: src/vanilla-three/experiences/CubeExperience.ts
================================================
import { Pane } from "tweakpane";
import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";
import { BaseExperience, type ExperienceOptions } from "./BaseExperience";
import vertexShader from "../shaders/cube-vertex.glsl";
import fragmentShader from "../shaders/cube-fragment.glsl";

export class CubeExperience extends BaseExperience {
  private scene!: THREE.Scene;
  private camera!: THREE.PerspectiveCamera;
  private renderer!: THREE.WebGLRenderer;
  private controls!: OrbitControls;
  private clock: THREE.Clock;
  private animationFrameId: number | null = null;
  private objects: THREE.Object3D[] = [];

  private shaderMaterial!: THREE.ShaderMaterial;
  private handleResize!: () => void;
  private pane!: Pane;

  // Settings object for Tweakpane bindings
  private settings = {
    backgroundColor: "#1a1a1a",
    rotationSpeed: 1.0,
    wireframe: false,
    scale: 1.0,
  };

  constructor(canvas: HTMLCanvasElement, options: ExperienceOptions = {}) {
    super(canvas, options);
    this.clock = new THREE.Clock();
  }

  private initScene(): void {
    this.scene = new THREE.Scene();
    this.scene.background = new THREE.Color(this.settings.backgroundColor);
  }

  private initCamera(): void {
    const aspect = this.sizes.width / this.sizes.height;
    this.camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
    this.camera.position.set(0, 2, 5);
  }

  private initRenderer(): void {
    this.renderer = new THREE.WebGLRenderer({
      canvas: this.canvas,
      antialias: true,
    });
    this.renderer.setSize(this.sizes.width, this.sizes.height);
    this.renderer.setPixelRatio(this.sizes.pixelRatio);
  }

  private initControls(): void {
    this.controls = new OrbitControls(this.camera, this.canvas);
    this.controls.enableDamping = true;
    this.controls.dampingFactor = 0.05;
  }

  private initLights(): void {
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(5, 5, 5);
    this.scene.add(directionalLight);
  }

  private setupResize(): void {
    this.handleResize = () => {
      this.updateSizes();
      this.camera.aspect = this.sizes.width / this.sizes.height;
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(this.sizes.width, this.sizes.height);
      this.renderer.setPixelRatio(this.sizes.pixelRatio);
    };

    window.addEventListener("resize", this.handleResize);
  }

  private initObjects(): void {
    const geometry = new THREE.BoxGeometry(1, 1, 1);
    this.shaderMaterial = new THREE.ShaderMaterial({
      vertexShader,
      fragmentShader,
      uniforms: {
        uTime: { value: 0 },
      },
      wireframe: this.settings.wireframe,
    });
    const cube = new THREE.Mesh(geometry, this.shaderMaterial);
    cube.scale.setScalar(this.settings.scale);
    this.scene.add(cube);
    this.objects.push(cube);
  }

  private initGUI(): void {
    const container = this.options.controlsContainer;

    this.pane = new Pane({
      title: "Rotating Cube",
      expanded: true,
      ...(container && { container }),
    });

    this.pane
      .addBinding(this.settings, "backgroundColor", {
        label: "Background Color",
      })
      .on("change", (ev) => {
        this.scene.background = new THREE.Color(ev.value);
      });

    this.pane.addBinding(this.settings, "rotationSpeed", {
      label: "Rotation Speed",
      min: 0,
      max: 5,
      step: 0.1,
    });

    this.pane
      .addBinding(this.settings, "wireframe", {
        label: "Wireframe",
      })
      .on("change", (ev) => {
        if (this.shaderMaterial) {
          this.shaderMaterial.wireframe = ev.value;
        }
      });

    this.pane
      .addBinding(this.settings, "scale", {
        label: "Scale",
        min: 0.1,
        max: 3,
        step: 0.1,
      })
      .on("change", (ev) => {
        this.objects.forEach((object) => {
          object.scale.setScalar(ev.value);
        });
      });

    this.pane
      .addButton({
        title: "Reset",
      })
      .on("click", () => {
        this.settings.backgroundColor = "#1a1a1a";
        this.settings.rotationSpeed = 1.0;
        this.settings.wireframe = false;
        this.settings.scale = 1.0;
        this.pane.refresh();

        this.scene.background = new THREE.Color(this.settings.backgroundColor);
        if (this.shaderMaterial) {
          this.shaderMaterial.wireframe = this.settings.wireframe;
        }
        this.objects.forEach((object) => {
          object.scale.setScalar(this.settings.scale);
          object.rotation.set(0, 0, 0);
        });
      });
  }

  private animate(): void {
    this.animationFrameId = requestAnimationFrame(this.animate.bind(this));

    const elapsedTime = this.clock.getElapsedTime();

    // Update shader uniform
    if (this.shaderMaterial) {
      this.shaderMaterial.uniforms.uTime.value = elapsedTime;
    }

    // Rotate objects based on settings
    this.objects.forEach((object) => {
      object.rotation.x += 0.01 * this.settings.rotationSpeed;
      object.rotation.y += 0.01 * this.settings.rotationSpeed;
    });

    // Update controls
    this.controls.update();

    // Render scene
    this.renderer.render(this.scene, this.camera);
  }

  public async init(): Promise<void> {
    try {
      if (this.options.controlsContainer) {
        this.initGUI();
      }
      this.initScene();
      this.initCamera();
      this.initRenderer();
      this.initControls();
      this.initLights();
      this.setupResize();
      this.initObjects();
      this.animate();
    } catch (error) {
      console.error("Failed to initialize CubeExperience:", error);
      throw error;
    }
  }

  public dispose(): void {
    // Cancel animation frame
    if (this.animationFrameId !== null) {
      cancelAnimationFrame(this.animationFrameId);
    }

    // Remove resize listener
    if (this.handleResize) {
      window.removeEventListener("resize", this.handleResize);
    }

    // Dispose of Tweakpane
    if (this.pane) {
      this.pane.dispose();
    }

    // Dispose of all objects
    this.objects.forEach((object) => {
      if (object instanceof THREE.Mesh) {
        object.geometry.dispose();
        if (Array.isArray(object.material)) {
          object.material.forEach((material) => material.dispose());
        } else {
          object.material.dispose();
        }
      }
    });

    // Clear objects array
    this.objects.length = 0;

    // Dispose of renderer
    if (this.renderer) {
      this.renderer.dispose();
    }
  }
}



================================================
FILE: src/vanilla-three/experiences/_template/TSLExperience.ts
================================================
import { Pane } from "tweakpane";
import * as THREE from "three/webgpu";
import {
  sin,
  positionLocal,
  time,
  vec2,
  vec3,
  vec4,
  uv,
  uniform,
  color,
  fog,
  rangeFogFactor,
  pass,
  renderOutput,
} from "three/tsl";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";
import { sobel } from "three/addons/tsl/display/SobelOperatorNode.js";
import { BaseExperience, type ExperienceOptions } from "../BaseExperience";

export class EXPERIMENT_CLASS_NAME extends BaseExperience {
  private scene!: THREE.Scene;
  private camera!: THREE.PerspectiveCamera;
  private renderer!: THREE.WebGPURenderer;
  private controls!: OrbitControls;
  private postProcessing!: THREE.PostProcessing;
  private animationFrameId: number | null = null;
  private handleResize!: () => void;
  private pane!: Pane;

  // TSL-specific properties
  private mesh!: THREE.Mesh;
  private material!: THREE.MeshBasicNodeMaterial;
  private fogColor = uniform(color("#ffffff"));
  private timeFrequency = uniform(0.5);
  private positionFrequency = uniform(2);
  private intensityFrequency = uniform(0.5);

  constructor(canvas: HTMLCanvasElement, options: ExperienceOptions = {}) {
    super(canvas, options);
  }

  private initScene(): void {
    this.scene = new THREE.Scene();
    this.scene.fogNode = fog(this.fogColor, rangeFogFactor(10, 15));
  }

  private initCamera(): void {
    const aspect = this.sizes.width / this.sizes.height;
    this.camera = new THREE.PerspectiveCamera(25, aspect, 0.1, 100);
    this.camera.position.set(6, 3, 10);
  }

  private initRenderer(): void {
    this.renderer = new THREE.WebGPURenderer({
      canvas: this.canvas,
      antialias: true,
      forceWebGL: false,
    });
    this.renderer.setSize(this.sizes.width, this.sizes.height);
    this.renderer.setPixelRatio(this.sizes.pixelRatio);
    this.renderer.setClearColor(this.fogColor.value);
  }

  private initControls(): void {
    this.controls = new OrbitControls(this.camera, this.canvas);
    this.controls.enableDamping = true;
  }

  private initPostProcessing(): void {
    this.postProcessing = new THREE.PostProcessing(this.renderer);
    this.postProcessing.outputColorTransform = false;

    const scenePass = pass(this.scene, this.camera);
    const outputPass = renderOutput(scenePass);

    this.postProcessing.outputNode = sobel(outputPass);
    // Alternative: this.postProcessing.outputNode = outputPass;
  }

  private setupResize(): void {
    this.handleResize = () => {
      this.updateSizes();
      this.camera.aspect = this.sizes.width / this.sizes.height;
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(this.sizes.width, this.sizes.height);
      this.renderer.setPixelRatio(this.sizes.pixelRatio);
    };

    window.addEventListener("resize", this.handleResize);
  }

  private initObjects(): void {
    // Create TSL material with node-based shading
    this.material = new THREE.MeshBasicNodeMaterial();

    // Position node with oscillation
    const oscillation = sin(
      time
        .mul(this.timeFrequency)
        .add(positionLocal.y.mul(this.positionFrequency))
    ).mul(this.intensityFrequency);

    this.material.positionNode = vec3(
      positionLocal.x.add(oscillation),
      positionLocal.y,
      positionLocal.z
    );

    // Color node using UV coordinates
    this.material.colorNode = vec4(uv().mul(vec2(32, 8)).fract(), 1, 1);

    // Create geometry - modify this to create your own 3D objects
    const geometry = new THREE.TorusKnotGeometry(1, 0.35, 128, 32);
    this.mesh = new THREE.Mesh(geometry, this.material);
    this.scene.add(this.mesh);
  }

  private initGUI(): void {
    const container = this.options.controlsContainer;

    this.pane = new Pane({
      title: "EXPERIMENT_COMPONENT_NAME",
      expanded: true,
      ...(container && { container }),
    });

    // Bind directly to uniform values - no onChange handlers needed!
    this.pane.addBinding(this.timeFrequency, "value", {
      min: 0,
      max: 5,
      step: 0.1,
      label: "Time Frequency",
    });

    this.pane.addBinding(this.positionFrequency, "value", {
      min: 0,
      max: 5,
      step: 0.1,
      label: "Position Frequency",
    });

    this.pane.addBinding(this.intensityFrequency, "value", {
      min: 0,
      max: 5,
      step: 0.1,
      label: "Intensity Frequency",
    });

    this.pane
      .addButton({
        title: "Reset Parameters",
      })
      .on("click", () => {
        this.timeFrequency.value = 0.5;
        this.positionFrequency.value = 2;
        this.intensityFrequency.value = 0.5;
        this.pane.refresh();
      });
  }

  private animate(): void {
    this.controls.update();

    // Use post-processing render instead of direct scene render
    this.postProcessing.renderAsync();
  }

  public async init(): Promise<void> {
    try {
      if (this.options.controlsContainer) {
        this.initGUI();
      }
      this.initScene();
      this.initCamera();
      this.initRenderer();
      this.initControls();
      this.initPostProcessing();
      this.setupResize();
      this.initObjects();

      // Start animation loop using WebGPU's setAnimationLoop
      this.renderer.setAnimationLoop(() => this.animate());
    } catch (error) {
      console.error("Failed to initialize EXPERIMENT_CLASS_NAME:", error);
      throw error;
    }
  }

  public dispose(): void {
    if (this.animationFrameId !== null) {
      cancelAnimationFrame(this.animationFrameId);
    }

    if (this.handleResize) {
      window.removeEventListener("resize", this.handleResize);
    }

    if (this.pane) {
      this.pane.dispose();
    }

    if (this.renderer) {
      this.renderer.setAnimationLoop(null);
      // Disposal is handled by base class or WebGPU renderer
    }

    if (this.mesh) {
      this.mesh.geometry.dispose();
      // TSL materials have different disposal patterns
    }
  }
}



================================================
FILE: src/vanilla-three/experiences/_template/WebGLExperience.ts
================================================
import { Pane } from "tweakpane";
import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";
import { BaseExperience, type ExperienceOptions } from "../BaseExperience";

export class EXPERIMENT_CLASS_NAME extends BaseExperience {
  private scene!: THREE.Scene;
  private camera!: THREE.PerspectiveCamera;
  private renderer!: THREE.WebGLRenderer;
  private controls!: OrbitControls;
  private animationFrameId: number | null = null;
  private handleResize!: () => void;
  private pane!: Pane;
  private cube!: THREE.Mesh;

  // Settings object for Tweakpane bindings
  private settings = {
    cubeColor: "#00ff00",
    rotationSpeed: 1.0,
    wireframe: false,
    scale: 1.0,
  };

  constructor(canvas: HTMLCanvasElement, options: ExperienceOptions = {}) {
    super(canvas, options);
  }

  private initScene(): void {
    this.scene = new THREE.Scene();
    this.scene.background = new THREE.Color(0x1a1a1a);
  }

  private initCamera(): void {
    const aspect = this.sizes.width / this.sizes.height;
    this.camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
    this.camera.position.set(0, 2, 5);
  }

  private initRenderer(): void {
    this.renderer = new THREE.WebGLRenderer({
      canvas: this.canvas,
      antialias: true,
    });
    this.renderer.setSize(this.sizes.width, this.sizes.height);
    this.renderer.setPixelRatio(this.sizes.pixelRatio);
  }

  private initControls(): void {
    this.controls = new OrbitControls(this.camera, this.canvas);
    this.controls.enableDamping = true;
    this.controls.dampingFactor = 0.05;
  }

  private setupResize(): void {
    this.handleResize = () => {
      this.updateSizes();
      this.camera.aspect = this.sizes.width / this.sizes.height;
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(this.sizes.width, this.sizes.height);
      this.renderer.setPixelRatio(this.sizes.pixelRatio);
    };

    window.addEventListener("resize", this.handleResize);
  }

  private initObjects(): void {
    // Create a cube with material that can be controlled by Tweakpane
    const geometry = new THREE.BoxGeometry(1, 1, 1);
    const material = new THREE.MeshBasicMaterial({
      color: this.settings.cubeColor,
      wireframe: this.settings.wireframe,
    });
    this.cube = new THREE.Mesh(geometry, material);
    this.scene.add(this.cube);
  }

  private initGUI(): void {
    const container = this.options.controlsContainer;

    this.pane = new Pane({
      title: "EXPERIMENT_COMPONENT_NAME",
      expanded: true,
      ...(container && { container }),
    });

    this.pane
      .addBinding(this.settings, "cubeColor", {
        label: "Cube Color",
      })
      .on("change", (ev) => {
        if (this.cube) {
          (this.cube.material as THREE.MeshBasicMaterial).color.set(ev.value);
        }
      });

    this.pane.addBinding(this.settings, "rotationSpeed", {
      label: "Rotation Speed",
      min: 0,
      max: 5,
      step: 0.1,
    });

    this.pane
      .addBinding(this.settings, "wireframe", {
        label: "Wireframe",
      })
      .on("change", (ev) => {
        if (this.cube) {
          (this.cube.material as THREE.MeshBasicMaterial).wireframe = ev.value;
        }
      });

    this.pane
      .addButton({
        title: "Reset Cube",
      })
      .on("click", () => {
        this.settings.cubeColor = "#00ff00";
        this.settings.rotationSpeed = 1.0;
        this.settings.wireframe = false;
        this.pane.refresh();

        if (this.cube) {
          (this.cube.material as THREE.MeshBasicMaterial).color.set(
            this.settings.cubeColor
          );
          (this.cube.material as THREE.MeshBasicMaterial).wireframe =
            this.settings.wireframe;
          this.cube.rotation.set(0, 0, 0);
        }
      });
  }

  private animate(): void {
    this.animationFrameId = requestAnimationFrame(this.animate.bind(this));

    // Rotate the cube based on settings
    if (this.cube) {
      this.cube.rotation.x += 0.01 * this.settings.rotationSpeed;
      this.cube.rotation.y += 0.01 * this.settings.rotationSpeed;
    }

    this.controls.update();
    this.renderer.render(this.scene, this.camera);
  }

  public async init(): Promise<void> {
    try {
      if (this.options.controlsContainer) {
        this.initGUI();
      }
      this.initScene();
      this.initCamera();
      this.initRenderer();
      this.initControls();
      this.setupResize();
      this.initObjects();
      this.animate();
    } catch (error) {
      console.error("Failed to initialize EXPERIMENT_CLASS_NAME:", error);
      throw error;
    }
  }

  public dispose(): void {
    if (this.animationFrameId !== null) {
      cancelAnimationFrame(this.animationFrameId);
    }

    if (this.handleResize) {
      window.removeEventListener("resize", this.handleResize);
    }

    if (this.pane) {
      this.pane.dispose();
    }

    if (this.renderer) {
      this.renderer.dispose();
    }

    if (this.cube) {
      this.cube.geometry.dispose();
      (this.cube.material as THREE.Material).dispose();
    }
  }
}



================================================
FILE: src/vanilla-three/experiences/cursor-trails/CursorTrailsExperience.ts
================================================
import { Pane } from "tweakpane";
import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";
import { BaseExperience, type ExperienceOptions } from "../BaseExperience";
import particlesVertexShader from "../../shaders/cursor-trails/vertex.glsl";
import particlesFragmentShader from "../../shaders/cursor-trails/fragment.glsl";

interface Displacement {
  canvas: HTMLCanvasElement;
  context: CanvasRenderingContext2D;
  glowImage: HTMLImageElement;
  glowSize: number;
  interactivePlane: THREE.Mesh;
  raycaster: THREE.Raycaster;
  screenCursor: THREE.Vector2;
  canvasCursor: THREE.Vector2;
  previousCanvasCursor: THREE.Vector2;
  canvasTexture: THREE.CanvasTexture;
}

export class CursorTrailsExperience extends BaseExperience {
  private scene!: THREE.Scene;
  private camera!: THREE.PerspectiveCamera;
  private renderer!: THREE.WebGLRenderer;
  private controls!: OrbitControls;
  private animationFrameId: number | null = null;
  private textureLoader!: THREE.TextureLoader;
  private displacement!: Displacement;
  private pane!: Pane;

  private handleResize!: () => void;

  // Settings object for Tweakpane bindings
  private settings = {
    backgroundImage: "clown.png",
    glowSize: 0.25,
    fadeSpeed: 0.02,
    cursorIntensity: 0.1,
  };

  constructor(canvas: HTMLCanvasElement, options: ExperienceOptions = {}) {
    super(canvas, options);
  }

  private initScene(): void {
    this.scene = new THREE.Scene();
    this.scene.background = new THREE.Color(0x1a1a1a);
  }

  private initCamera(): void {
    const aspect = this.sizes.width / this.sizes.height;
    this.camera = new THREE.PerspectiveCamera(35, aspect, 0.1, 100);
    this.camera.position.set(0, 0, 30);
  }

  private initRenderer(): void {
    this.renderer = new THREE.WebGLRenderer({
      canvas: this.canvas,
      antialias: true,
    });
    this.renderer.setClearColor("#181818");
    this.renderer.setSize(this.sizes.width, this.sizes.height);
    this.renderer.setPixelRatio(this.sizes.pixelRatio);
  }

  private initControls(): void {
    this.controls = new OrbitControls(this.camera, this.canvas);
    this.controls.enableDamping = true;
    // disable rotation on touch
    this.controls.touches.ONE = null;
  }

  private setupResize(): void {
    this.handleResize = () => {
      this.updateSizes();
      this.camera.aspect = this.sizes.width / this.sizes.height;
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(this.sizes.width, this.sizes.height);
      this.renderer.setPixelRatio(this.sizes.pixelRatio);
    };

    window.addEventListener("resize", this.handleResize);
  }

  private initDisplacement(): void {
    const displacementCanvas = document.getElementById(
      "displacement-canvas"
    ) as HTMLCanvasElement;
    if (displacementCanvas) {
      const glowImage = new Image();
      glowImage.src = "/cursor-trails/glow.png";
      const interactivePlane = new THREE.Mesh(
        new THREE.PlaneGeometry(10, 10),
        new THREE.MeshBasicMaterial({ side: THREE.DoubleSide })
      );
      interactivePlane.visible = false;
      const raycaster = new THREE.Raycaster();
      const screenCursor = new THREE.Vector2(9999, 9999);
      const canvasCursor = new THREE.Vector2(9999, 9999);
      const previousCanvasCursor = new THREE.Vector2(9999, 9999);
      const glowSize = displacementCanvas.width * this.settings.glowSize;

      window.addEventListener("pointermove", (e) => {
        this.displacement.screenCursor.x =
          (e.clientX / this.sizes.width) * 2 - 1;
        this.displacement.screenCursor.y =
          -(e.clientY / this.sizes.height) * 2 + 1;
      });

      const canvasTexture = new THREE.CanvasTexture(displacementCanvas);

      this.displacement = {
        canvas: displacementCanvas,
        context: displacementCanvas.getContext("2d")!,
        glowImage,
        glowSize,
        interactivePlane,
        raycaster,
        screenCursor,
        canvasCursor,
        previousCanvasCursor,
        canvasTexture,
      };
      this.displacement.context.fillRect(0, 0, 128, 128);
      this.scene.add(this.displacement.interactivePlane);
    }
  }

  private initObjects(): void {
    const particlesGeometry = new THREE.PlaneGeometry(10, 10, 128, 128);
    // clean up geometry for improved performance
    particlesGeometry.setIndex(null);
    particlesGeometry.deleteAttribute("normal");
    const intensitiesArray = new Float32Array(
      particlesGeometry.attributes.position.count
    );
    const anglesArray = new Float32Array(
      particlesGeometry.attributes.position.count
    );
    for (let i = 0; i < intensitiesArray.length; i++) {
      intensitiesArray[i] = Math.random();
      anglesArray[i] = Math.random() * Math.PI * 2;
    }
    particlesGeometry.setAttribute(
      "aDisplacementIntensity",
      new THREE.BufferAttribute(intensitiesArray, 1)
    );
    particlesGeometry.setAttribute(
      "aDisplacementAngle",
      new THREE.BufferAttribute(anglesArray, 1)
    );
    const particlesMaterial = new THREE.ShaderMaterial({
      vertexShader: particlesVertexShader,
      fragmentShader: particlesFragmentShader,
      uniforms: {
        uResolution: new THREE.Uniform(
          new THREE.Vector2(
            this.sizes.width * this.sizes.pixelRatio,
            this.sizes.height * this.sizes.pixelRatio
          )
        ),
        uPictureTexture: new THREE.Uniform(
          this.textureLoader.load(
            `/cursor-trails/${this.settings.backgroundImage}`
          )
        ),
        uDisplacementTexture: new THREE.Uniform(
          this.displacement.canvasTexture
        ),
      },
    });
    const particles = new THREE.Points(particlesGeometry, particlesMaterial);
    this.scene.add(particles);
  }

  private initGUI(): void {
    const container = this.options.controlsContainer;

    this.pane = new Pane({
      title: "Cursor Trails",
      expanded: true,
      ...(container && { container }),
    });

    const imageOptions = {
      Clown: "clown.png",
      Jelly: "jelly.jpeg",
      "Pixel Jellyfish": "pixel-jellyfish.png",
      Skull: "skull.png",
      Terra: "terra.png",
      Glow: "glow.png",
    };

    this.pane
      .addBinding(this.settings, "backgroundImage", {
        label: "Background Image",
        options: imageOptions,
      })
      .on("change", (ev) => {
        // This would require reloading the texture - for now just log
        console.log("Background image changed to:", ev.value);
      });

    this.pane.addBinding(this.settings, "glowSize", {
      label: "Glow Size",
      min: 0.1,
      max: 1.0,
      step: 0.05,
    });

    this.pane.addBinding(this.settings, "fadeSpeed", {
      label: "Fade Speed",
      min: 0.001,
      max: 0.1,
      step: 0.001,
    });

    this.pane.addBinding(this.settings, "cursorIntensity", {
      label: "Cursor Intensity",
      min: 0.01,
      max: 0.5,
      step: 0.01,
    });

    this.pane
      .addButton({
        title: "Reset Settings",
      })
      .on("click", () => {
        this.settings.backgroundImage = "clown.png";
        this.settings.glowSize = 0.25;
        this.settings.fadeSpeed = 0.02;
        this.settings.cursorIntensity = 0.1;
        this.pane.refresh();
      });
  }

  private animate(): void {
    this.animationFrameId = requestAnimationFrame(this.animate.bind(this));
    this.controls.update();
    this.displacement.raycaster.setFromCamera(
      this.displacement.screenCursor,
      this.camera
    );
    const intersections = this.displacement.raycaster.intersectObject(
      this.displacement.interactivePlane
    );
    if (intersections.length > 0) {
      const uv = intersections[0].uv;
      if (uv) {
        // convert uv to canvas coordinates
        this.displacement.canvasCursor.x =
          uv.x * this.displacement.canvas.width;
        this.displacement.canvasCursor.y =
          (1 - uv.y) * this.displacement.canvas.height;
      }
    }
    this.displacement.context.globalCompositeOperation = "source-over";
    this.displacement.context.globalAlpha = this.settings.fadeSpeed;
    this.displacement.context.fillRect(
      0,
      0,
      this.displacement.canvas.width,
      this.displacement.canvas.height
    );

    const cursorDelta = this.displacement.previousCanvasCursor.distanceTo(
      this.displacement.canvasCursor
    );
    const alpha = Math.min(cursorDelta * this.settings.cursorIntensity, 1);
    this.displacement.previousCanvasCursor.copy(this.displacement.canvasCursor);

    this.displacement.context.globalAlpha = alpha;
    this.displacement.context.globalCompositeOperation = "lighten";
    this.displacement.context.drawImage(
      this.displacement.glowImage,
      this.displacement.canvasCursor.x - this.displacement.glowSize / 2,
      this.displacement.canvasCursor.y - this.displacement.glowSize / 2,
      this.displacement.glowSize,
      this.displacement.glowSize
    );

    if (this.displacement.canvasTexture) {
      this.displacement.canvasTexture.needsUpdate = true;
    }

    this.renderer.render(this.scene, this.camera);
  }

  public async init(): Promise<void> {
    try {
      this.textureLoader = new THREE.TextureLoader();
      this.initScene();
      this.initCamera();
      this.initRenderer();
      this.initControls();
      this.setupResize();
      this.initDisplacement();
      this.initObjects();
      if (this.options.controlsContainer) {
        this.initGUI();
      }
      this.animate();
    } catch (error) {
      console.error("Failed to initialize CursorTrailsExperience:", error);
      throw error;
    }
  }

  public dispose(): void {
    // Cancel animation frame
    if (this.animationFrameId !== null) {
      cancelAnimationFrame(this.animationFrameId);
    }

    // Remove resize listener
    if (this.handleResize) {
      window.removeEventListener("resize", this.handleResize);
    }

    // Dispose of Tweakpane
    if (this.pane) {
      this.pane.dispose();
    }

    // TODO: Clean up Three scene

    // Dispose of renderer
    if (this.renderer) {
      this.renderer.dispose();
    }
  }
}



================================================
FILE: src/vanilla-three/experiences/meta-shapes/constants.ts
================================================
export type GeometryType =
  | "box"
  | "sphere"
  | "cylinder"
  | "cone"
  | "icosahedron"
  | "octahedron"
  | "tetrahedron"
  | "dodecahedron";

export type MaterialRenderMode = "solid" | "wireframe" | "edges" | "both";

export type ColorMode =
  | "original"
  | "palette"
  | "rainbow"
  | "distance"
  | "position";

export type MouseEffectType =
  | "attraction"
  | "repulsion"
  | "scale"
  | "colorWave"
  | "rotationInfluence"
  | "heightWave"
  | "combined";

export type FormationType =
  | "cube"
  | "sphere"
  | "cylinder"
  | "plane"
  | "helix"
  | "random"
  | "torus"
  | "wave"
  | "tesseract";

export interface ColorPalette {
  name: string;
  hues: number[]; // Array of hue values (0-1)
  saturations: number[]; // Array of saturation values (0-1)
  lightnesses: number[]; // Array of lightness values (0-1)
}

export interface ColorConfig {
  mode: ColorMode;
  paletteIndex: number;
  baseHue: number;
  hueRange: number;
  saturation: number;
  lightness: number;
  noiseInfluence: number;
  timeInfluence: number;
}

export interface RotationConfig {
  enabled: boolean;
  rotationSpeed: number;
  noiseInfluenceX: number;
  noiseInfluenceY: number;
  noiseInfluenceZ: number;
  timeInfluence: number;
  individualRotation: boolean;
}

export interface MaterialConfig {
  renderMode: MaterialRenderMode;
  wireframeColor: number;
  edgesColor: number;
  wireframeLinewidth: number;
  wireframeAlpha: number;
  edgesAlpha: number;
}

export interface GeometryConfig {
  type: GeometryType;
  size: number;
  detail?: number; // for polyhedron geometries
  height?: number; // for cylinder/cone
  radiusTop?: number; // for cylinder/cone
  radiusBottom?: number; // for cylinder/cone
  radialSegments?: number; // for sphere/cylinder/cone
  heightSegments?: number; // for sphere/cylinder/cone
  widthSegments?: number; // for sphere
  phiLength?: number; // for sphere
  thetaLength?: number; // for sphere
}

export interface FormationConfig {
  type: FormationType;
  density: number; // Controls how tightly packed instances are
  radius?: number; // For sphere, cylinder, torus
  height?: number; // For cylinder, helix
  turns?: number; // For helix, wave
  amplitude?: number; // For wave
  frequency?: number; // For wave
  randomSeed?: number; // For random formation
  // Tesseract-specific properties
  tesseractScale?: number; // Scale factor for tesseract
  projectionType?: "stereographic" | "orthographic"; // 4D to 3D projection method
  rotationW?: number; // Rotation angle in 4D W plane
  timeRotation?: boolean; // Enable time-based 4D rotation
}

export interface InstanceMeshConfig {
  countPerSide: number;
  spacing: number;
  geometry: GeometryConfig;
  material: MaterialConfig;
  formation: FormationConfig;
}

export interface CameraConfig {
  fov: number;
  position: [number, number, number];
  target: [number, number, number];
}

export interface LightConfig {
  ambientIntensity: number;
  directionalIntensity: number;
  directionalPosition: [number, number, number];
}

export interface MouseInteractionConfig {
  enabled: boolean;
  effectType: MouseEffectType;
  intensity: number;
  radius: number; // Base radius of mouse influence
  falloffPower: number; // How quickly the effect falls off with distance
  attractionStrength: number; // For attraction/repulsion effects
  scaleMultiplier: number; // For scale effects
  colorWaveSpeed: number; // For color wave effects
  rotationMultiplier: number; // For rotation influence
  heightWaveAmplitude: number; // For height wave effects
  smoothingFactor: number; // For smooth transitions
  // Trail settings
  trailEnabled: boolean; // Enable mouse trail effects
  trailLength: number; // Number of trail points to keep
  trailFadeTime: number; // How long trail points last (in seconds)
  trailInfluenceStrength: number; // How much trail points influence the effect
  // Dynamic radius settings
  radiusNoiseScale: number; // Scale for radius noise variation
  radiusNoiseAmplitude: number; // How much the radius can vary
  radiusSinFrequency: number; // Frequency of sine wave variation
  radiusSinAmplitude: number; // Amplitude of sine wave variation
  // Curl noise settings
  curlNoiseScale: number; // Scale for curl noise field
  curlNoiseStrength: number; // How much curl noise affects the influence area
}

export interface HandTrackingConfig {
  enabled: boolean;
  replaceMouseInteraction: boolean; // If true, hand tracking takes priority over mouse
  minDetectionConfidence: number; // Minimum confidence for hand detection
  minTrackingConfidence: number; // Minimum confidence for hand tracking
  maxNumHands: number; // Maximum number of hands to track
  modelComplexity: number; // 0 or 1, higher = more accurate but slower
  // Gesture settings
  pinchThreshold: number; // Distance threshold for pinch gesture
  gestureIntensityMultipliers: {
    pinch: number; // Multiplier when pinching
    point: number; // Multiplier when pointing
    fist: number; // Multiplier when making a fist
    open: number; // Multiplier for open hand
  };
  // Depth control settings
  depthSensitivity: number; // How much the Z depth from MediaPipe affects position
  depthSmoothing: number; // Smoothing factor for depth changes
  // Hand tracking specific effects
  enableGestureEffects: boolean; // Enable different effects for different gestures
  showHandFeedback: boolean; // Show visual feedback for hand tracking
}

export interface PostProcessingConfig {
  enabled: boolean;
  bloom: {
    enabled: boolean;
    strength: number;
    radius: number;
    threshold: number;
  };
  chromaticAberration: {
    enabled: boolean;
    strength: number;
  };
  filmGrain: {
    enabled: boolean;
    intensity: number;
  };
  afterimage: {
    enabled: boolean;
    damp: number;
  };
  mirror: {
    enabled: boolean;
    type:
      | "horizontal"
      | "vertical"
      | "kaleidoscope"
      | "radial"
      | "diagonal"
      | "quadrant"
      | "center";
    intensity: number;
    segments?: number; // For kaleidoscope and radial modes
    offset?: number; // For positioning the mirror line/center
  };
}

export interface MetaShapesConfig {
  instanceMesh: InstanceMeshConfig;
  camera: CameraConfig;
  light: LightConfig;
  color: ColorConfig;
  rotation: RotationConfig;
  mouseInteraction: MouseInteractionConfig;
  handTracking: HandTrackingConfig;
  postProcessing: PostProcessingConfig;
}

// Color palettes
export const colorPalettes: ColorPalette[] = [
  {
    name: "Original",
    hues: [0.95], // Purple/magenta
    saturations: [1.0],
    lightnesses: [0.2],
  },
  {
    name: "Mint Green",
    hues: [0.4, 0.45, 0.5], // Green to cyan range
    saturations: [0.6, 0.8, 1.0],
    lightnesses: [0.3, 0.5, 0.7],
  },
  {
    name: "Rubine Red",
    hues: [0.9, 0.95, 0.0], // Magenta to red range
    saturations: [0.8, 1.0, 0.9],
    lightnesses: [0.2, 0.4, 0.6],
  },
  {
    name: "Mint & Rubine",
    hues: [0.4, 0.45, 0.9, 0.95, 0.0], // Mix of mint greens and rubine reds
    saturations: [0.7, 0.9, 0.8, 1.0, 0.9],
    lightnesses: [0.3, 0.5, 0.3, 0.4, 0.5],
  },
  {
    name: "Ocean",
    hues: [0.5, 0.55, 0.6, 0.65], // Blue to cyan
    saturations: [0.7, 0.8, 0.9, 1.0],
    lightnesses: [0.2, 0.3, 0.4, 0.5],
  },
  {
    name: "Sunset",
    hues: [0.05, 0.1, 0.15, 0.9], // Orange to red
    saturations: [0.8, 0.9, 1.0, 0.8],
    lightnesses: [0.3, 0.4, 0.5, 0.4],
  },
];

export const metaShapesConf: MetaShapesConfig = {
  instanceMesh: {
    countPerSide: 20,
    spacing: 1.0,
    geometry: {
      type: "box",
      size: 0.5,
      detail: 0,
      height: 1.0,
      radiusTop: 0.5,
      radiusBottom: 0.5,
      radialSegments: 8,
      heightSegments: 1,
      widthSegments: 8,
      phiLength: Math.PI * 2,
      thetaLength: Math.PI,
    },
    material: {
      renderMode: "solid",
      wireframeColor: 0x00ff00,
      edgesColor: 0xffffff,
      wireframeLinewidth: 1,
      wireframeAlpha: 0.5,
      edgesAlpha: 0.5,
    },
    formation: {
      type: "cube",
      density: 1.0,
      radius: 8.0,
      height: 16.0,
      turns: 3,
      amplitude: 2.0,
      frequency: 0.5,
      randomSeed: 42,
    },
  },
  camera: {
    fov: 75,
    position: [0, 2, 15],
    target: [0, 0, 0],
  },
  light: {
    ambientIntensity: 0.5,
    directionalIntensity: 1,
    directionalPosition: [5, 5, 5],
  },
  color: {
    mode: "original",
    paletteIndex: 0,
    baseHue: 0.618,
    hueRange: 0.3,
    saturation: 1.0,
    lightness: 0.2,
    noiseInfluence: 0.1,
    timeInfluence: 0.05,
  },
  rotation: {
    enabled: true,
    rotationSpeed: 1.0,
    noiseInfluenceX: 0.5,
    noiseInfluenceY: 0.3,
    noiseInfluenceZ: 0.2,
    timeInfluence: 0.1,
    individualRotation: true,
  },
  mouseInteraction: {
    enabled: true,
    effectType: "combined",
    intensity: 0.8,
    radius: 8.0,
    falloffPower: 1.5,
    attractionStrength: 0.5,
    scaleMultiplier: 0.8,
    colorWaveSpeed: 1.6,
    rotationMultiplier: 1.2,
    heightWaveAmplitude: 1.2,
    smoothingFactor: 0.3,
    trailEnabled: true,
    trailLength: 10,
    trailFadeTime: 2.5,
    trailInfluenceStrength: 0.4,
    radiusNoiseScale: 0.05,
    radiusNoiseAmplitude: 0.3,
    radiusSinFrequency: 0.3,
    radiusSinAmplitude: 0.3,
    curlNoiseScale: 0.05,
    curlNoiseStrength: 0.3,
  },
  handTracking: {
    enabled: false,
    replaceMouseInteraction: true,
    minDetectionConfidence: 0.5,
    minTrackingConfidence: 0.3,
    maxNumHands: 1,
    modelComplexity: 1,
    pinchThreshold: 0.05,
    gestureIntensityMultipliers: {
      pinch: 2.0,
      point: 1.5,
      fist: 0.5,
      open: 1.0,
    },
    depthSensitivity: 20.0,
    depthSmoothing: 0.1,
    enableGestureEffects: true,
    showHandFeedback: true,
  },
  postProcessing: {
    enabled: true,
    bloom: {
      enabled: true,
      strength: 0.2,
      radius: 0.2,
      threshold: 0.1,
    },
    chromaticAberration: {
      enabled: true,
      strength: 1.0,
    },
    filmGrain: {
      enabled: true,
      intensity: 0.3,
    },
    afterimage: {
      enabled: false,
      damp: 0.5,
    },
    mirror: {
      enabled: false,
      type: "horizontal",
      intensity: 1.0,
      segments: 6,
      offset: 0.5,
    },
  },
};

// Note: Global state management for Leva controls has been removed
// All controls are now handled via Tweakpane in the experience classes



================================================
FILE: src/vanilla-three/experiences/meta-shapes/MetaShapesExperience.ts
================================================
import { Pane } from "tweakpane";
import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";
import { BaseExperience, type ExperienceOptions } from "../BaseExperience";
import { metaShapesConf } from "./constants";
import { ImprovedNoise } from "three/examples/jsm/math/ImprovedNoise.js";
import { PostProcessingManager } from "./managers/PostProcessingManager";
import { MouseInteractionManager } from "./managers/MouseInteractionManager";
import { ColorManager } from "./managers/ColorManager";
import { FormationManager } from "./managers/FormationManager";
import { HandTrackingManager } from "./managers/HandTrackingManager";

export class MetaShapesExperience extends BaseExperience {
  private scene!: THREE.Scene;
  private camera!: THREE.PerspectiveCamera;
  private renderer!: THREE.WebGLRenderer;
  private controls!: OrbitControls;
  private clock: THREE.Clock;
  private animationFrameId: number | null = null;
  private objects: THREE.Object3D[] = [];

  private instancedMesh!: THREE.InstancedMesh;
  private wireframeInstancedMesh!: THREE.InstancedMesh;
  private edgesGroup!: THREE.Group;
  private ambientLight!: THREE.AmbientLight;
  private directionalLight!: THREE.DirectionalLight;
  private noise!: ImprovedNoise;
  private dummyPos!: THREE.Object3D;
  private handleResize!: () => void;

  // Managers
  private postProcessingManager!: PostProcessingManager;
  private mouseInteractionManager!: MouseInteractionManager;
  private colorManager!: ColorManager;
  private formationManager!: FormationManager;
  private handTrackingManager!: HandTrackingManager;
  private pane!: Pane;

  constructor(canvas: HTMLCanvasElement, options: ExperienceOptions = {}) {
    super(canvas, options);
    this.clock = new THREE.Clock();
    this.noise = new ImprovedNoise();

    // Initialize managers
    this.colorManager = new ColorManager();
    this.formationManager = new FormationManager();
  }

  private initScene(): void {
    this.scene = new THREE.Scene();
    this.scene.background = new THREE.Color(0xa0a0a);
  }

  private initCamera(): void {
    const aspect = this.canvas.clientWidth / this.canvas.clientHeight;
    this.camera = new THREE.PerspectiveCamera(
      metaShapesConf.camera.fov,
      aspect,
      0.1,
      1000
    );
    const [x, y] = metaShapesConf.camera.position;
    this.camera.position.set(
      x,
      y,
      metaShapesConf.instanceMesh.countPerSide * 1.8
    );
  }

  private initRenderer(): void {
    this.renderer = new THREE.WebGLRenderer({
      canvas: this.canvas,
      antialias: true,
      powerPreference: "high-performance",
    });

    // Set initial size
    this.updateRendererSize();
  }

  private updateRendererSize(): void {
    const width = this.canvas.clientWidth;
    const height = this.canvas.clientHeight;

    this.renderer.setSize(width, height, false); // false prevents style changes
    this.renderer.setPixelRatio(window.devicePixelRatio);

    // Update post-processing composer size
    if (this.postProcessingManager) {
      this.postProcessingManager.setSize(width, height);
    }
  }

  private initControls(): void {
    this.controls = new OrbitControls(this.camera, this.canvas);
    const [tx, ty, tz] = metaShapesConf.camera.target;
    this.controls.target.set(tx, ty, tz);
    this.controls.enableDamping = true;
    this.controls.dampingFactor = 0.05;
  }

  private initLights(): void {
    // Ambient light
    this.ambientLight = new THREE.AmbientLight(
      0xffffff,
      metaShapesConf.light.ambientIntensity
    );
    this.scene.add(this.ambientLight);

    // Directional light
    this.directionalLight = new THREE.DirectionalLight(
      0xffffff,
      metaShapesConf.light.directionalIntensity
    );
    const [x, y, z] = metaShapesConf.light.directionalPosition;
    this.directionalLight.position.set(x, y, z);
    this.scene.add(this.directionalLight);
  }

  private setupResize(): void {
    this.handleResize = () => {
      const aspect = this.canvas.clientWidth / this.canvas.clientHeight;
      this.camera.aspect = aspect;
      this.camera.updateProjectionMatrix();
      this.updateRendererSize();
    };

    window.addEventListener("resize", this.handleResize);
  }

  private setupMouseInteraction(): void {
    this.mouseInteractionManager = new MouseInteractionManager(
      this.camera,
      this.canvas,
      this.noise
    );
    this.mouseInteractionManager.setupMouseInteraction();
  }

  private async setupHandTracking(): Promise<void> {
    if (!metaShapesConf.handTracking.enabled) {
      return;
    }

    this.handTrackingManager = new HandTrackingManager(
      this.camera,
      this.controls
    );

    const initialized = await this.handTrackingManager.init();
    if (initialized) {
      console.log("Hand tracking enabled successfully");
    } else {
      console.warn(
        "Hand tracking failed to initialize, falling back to mouse interaction only"
      );
    }
  }

  private initObjects(): void {
    this.createInstancedMesh();
  }

  private createGeometry(): THREE.BufferGeometry {
    const config = metaShapesConf.instanceMesh.geometry;
    const {
      type,
      size,
      detail,
      height,
      radiusTop,
      radiusBottom,
      radialSegments,
      heightSegments,
      widthSegments,
      phiLength,
      thetaLength,
    } = config;

    switch (type) {
      case "box":
        return new THREE.BoxGeometry(size, size, size);

      case "sphere":
        return new THREE.SphereGeometry(
          size / 2,
          widthSegments || 8,
          heightSegments || 6,
          0,
          phiLength || Math.PI * 2,
          0,
          thetaLength || Math.PI
        );

      case "cylinder":
        return new THREE.CylinderGeometry(
          radiusTop || size / 2,
          radiusBottom || size / 2,
          height || size,
          radialSegments || 8,
          heightSegments || 1
        );

      case "cone":
        return new THREE.ConeGeometry(
          radiusBottom || size / 2,
          height || size,
          radialSegments || 8,
          heightSegments || 1
        );

      case "icosahedron":
        return new THREE.IcosahedronGeometry(size / 2, detail || 0);

      case "octahedron":
        return new THREE.OctahedronGeometry(size / 2, detail || 0);

      case "tetrahedron":
        return new THREE.TetrahedronGeometry(size / 2, detail || 0);

      case "dodecahedron":
        return new THREE.DodecahedronGeometry(size / 2, detail || 0);

      default:
        return new THREE.BoxGeometry(size, size, size);
    }
  }

  private createInstancedMesh(): void {
    const geometry = this.createGeometry();
    const materialConfig = metaShapesConf.instanceMesh.material;
    const countPerSide = metaShapesConf.instanceMesh.countPerSide;
    const totalCount = countPerSide ** 3;

    // remove old meshes if they exist
    if (this.instancedMesh) {
      this.scene.remove(this.instancedMesh);
      this.instancedMesh.dispose();
    }
    if (this.wireframeInstancedMesh) {
      this.scene.remove(this.wireframeInstancedMesh);
      this.wireframeInstancedMesh.dispose();
    }
    if (this.edgesGroup) {
      this.scene.remove(this.edgesGroup);
      this.edgesGroup.clear();
    }

    this.dummyPos = new THREE.Object3D();

    const noiseAmplitude = 0.1;
    const noiseScale = 3;

    // Create solid mesh if needed
    if (
      materialConfig.renderMode === "solid" ||
      materialConfig.renderMode === "both"
    ) {
      const solidMaterial = new THREE.MeshBasicMaterial();
      this.instancedMesh = new THREE.InstancedMesh(
        geometry,
        solidMaterial,
        totalCount
      );
      this.instancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
      this.scene.add(this.instancedMesh);
    }

    // Create wireframe mesh if needed
    if (
      materialConfig.renderMode === "wireframe" ||
      materialConfig.renderMode === "both"
    ) {
      const wireframeMaterial = new THREE.MeshBasicMaterial({
        color: materialConfig.wireframeColor,
        wireframe: true,
        wireframeLinewidth: materialConfig.wireframeLinewidth,
        transparent: true,
        opacity: materialConfig.wireframeAlpha,
      });
      this.wireframeInstancedMesh = new THREE.InstancedMesh(
        geometry,
        wireframeMaterial,
        totalCount
      );
      this.wireframeInstancedMesh.instanceMatrix.setUsage(
        THREE.DynamicDrawUsage
      );
      this.scene.add(this.wireframeInstancedMesh);
    }

    // Create edges if needed
    if (
      materialConfig.renderMode === "edges" ||
      materialConfig.renderMode === "both"
    ) {
      const edgesGeometry = new THREE.EdgesGeometry(geometry);
      const edgesMaterial = new THREE.LineBasicMaterial({
        color: materialConfig.edgesColor,
        linewidth: materialConfig.wireframeLinewidth,
        transparent: true,
        opacity: materialConfig.edgesAlpha,
      });

      this.edgesGroup = new THREE.Group();

      // Create individual LineSegments for each instance since we can't use InstancedMesh with LineSegments
      for (let i = 0; i < totalCount; i++) {
        const edgesMesh = new THREE.LineSegments(edgesGeometry, edgesMaterial);
        this.edgesGroup.add(edgesMesh);
      }

      this.scene.add(this.edgesGroup);
    }

    this.dummyPos.userData = {
      update: (props: {
        i: number;
        x: number;
        y: number;
        z: number;
        time: number;
      }) => {
        const { i, x, y, z, time } = props;
        const countPerSide = metaShapesConf.instanceMesh.countPerSide;
        const totalCount = countPerSide ** 3;

        // Use formation-based positioning instead of simple cube grid
        const basePosition = this.formationManager.calculateFormationPosition(
          i,
          x,
          y,
          z,
          totalCount,
          countPerSide
        );

        this.dummyPos.position.copy(basePosition);

        const nz =
          this.noise.noise(
            time + x * noiseAmplitude,
            time + y * noiseAmplitude,
            time + z * noiseAmplitude
          ) * noiseScale;

        let finalScale = nz;
        let totalColorInfluence = 0;
        let totalRotationInfluence = { x: 0, y: 0, z: 0 };
        const totalPositionOffset = new THREE.Vector3();

        // Calculate mouse effects if enabled
        if (
          metaShapesConf.mouseInteraction.enabled &&
          this.mouseInteractionManager
        ) {
          const mouseEffects =
            this.mouseInteractionManager.calculateMouseEffects(
              basePosition,
              time
            );

          finalScale += mouseEffects.scaleInfluence;
          totalColorInfluence += mouseEffects.colorInfluence;
          totalRotationInfluence.x += mouseEffects.rotationInfluence.x;
          totalRotationInfluence.y += mouseEffects.rotationInfluence.y;
          totalRotationInfluence.z += mouseEffects.rotationInfluence.z;
          totalPositionOffset.add(mouseEffects.positionOffset);
        }

        // Calculate hand tracking effects if enabled
        if (
          metaShapesConf.handTracking.enabled &&
          this.handTrackingManager &&
          this.handTrackingManager.isHandActive()
        ) {
          const handEffects = this.handTrackingManager.calculateHandEffects(
            basePosition,
            time
          );

          // If hand tracking should replace mouse interaction, use hand effects only
          // Otherwise, combine both effects
          if (metaShapesConf.handTracking.replaceMouseInteraction) {
            finalScale = nz + handEffects.scaleInfluence;
            totalColorInfluence = handEffects.colorInfluence;
            totalRotationInfluence = handEffects.rotationInfluence;
            totalPositionOffset.copy(handEffects.positionOffset);
          } else {
            // Combine hand and mouse effects
            finalScale += handEffects.scaleInfluence;
            totalColorInfluence += handEffects.colorInfluence;
            totalRotationInfluence.x += handEffects.rotationInfluence.x;
            totalRotationInfluence.y += handEffects.rotationInfluence.y;
            totalRotationInfluence.z += handEffects.rotationInfluence.z;
            totalPositionOffset.add(handEffects.positionOffset);
          }
        }

        this.dummyPos.scale.setScalar(finalScale);

        // Apply position displacement
        this.dummyPos.position.add(totalPositionOffset);

        // Update color for solid mesh using new color system
        if (this.instancedMesh) {
          const color = this.colorManager.calculateColor(
            x,
            y,
            z,
            nz,
            time,
            countPerSide,
            totalColorInfluence
          );
          this.instancedMesh.setColorAt(i, color);
          if (this.instancedMesh.instanceColor) {
            this.instancedMesh.instanceColor.needsUpdate = true;
          }
        }

        // Update rotation if enabled
        if (
          metaShapesConf.rotation.enabled &&
          metaShapesConf.rotation.individualRotation
        ) {
          this.calculateInstanceRotation(x, y, z, time, totalRotationInfluence);
        } else {
          // Reset individual rotation when disabled
          this.dummyPos.rotation.set(0, 0, 0);
        }
      },
    };
  }

  public updateInstancedMesh(): void {
    this.createInstancedMesh();

    // Auto-adjust camera Z position based on grid size
    const [x, y] = metaShapesConf.camera.position;
    const z = metaShapesConf.instanceMesh.countPerSide * 1.8;

    // Update both the camera and the config to stay in sync
    metaShapesConf.camera.position[2] = z;
    this.camera.position.set(x, y, z);
    this.controls.update();
  }

  public updateColors(): void {
    // Update colors when settings change
    if (this.instancedMesh) {
      const countPerSide = metaShapesConf.instanceMesh.countPerSide;
      const time = performance.now() * 0.0003;
      let i = 0;

      for (let x = 0; x < countPerSide; x += 1) {
        for (let y = 0; y < countPerSide; y += 1) {
          for (let z = 0; z < countPerSide; z += 1) {
            const noiseAmplitude = 0.1;
            const noiseScale = 3;
            const nz =
              this.noise.noise(
                time + x * noiseAmplitude,
                time + y * noiseAmplitude,
                time + z * noiseAmplitude
              ) * noiseScale;

            const color = this.colorManager.calculateColor(
              x,
              y,
              z,
              nz,
              time,
              countPerSide,
              0
            );
            this.instancedMesh.setColorAt(i, color);
            i += 1;
          }
        }
      }

      if (this.instancedMesh.instanceColor) {
        this.instancedMesh.instanceColor.needsUpdate = true;
      }
    }
  }

  public updateRotation(): void {
    // Reset global rotations when switching modes
    if (
      metaShapesConf.rotation.individualRotation ||
      !metaShapesConf.rotation.enabled
    ) {
      if (this.instancedMesh) {
        this.instancedMesh.rotation.set(0, 0, 0);
      }
      if (this.wireframeInstancedMesh) {
        this.wireframeInstancedMesh.rotation.set(0, 0, 0);
      }
      if (this.edgesGroup) {
        this.edgesGroup.rotation.set(0, 0, 0);
      }
    }
  }

  private calculateInstanceRotation(
    x: number,
    y: number,
    z: number,
    time: number,
    mouseInfluence?: { x: number; y: number; z: number }
  ): void {
    const rotConfig = metaShapesConf.rotation;

    // Use different noise sampling for each axis with better spacing
    const noiseScale = 0.2; // Scale down for smoother noise
    const timeScale = rotConfig.timeInfluence * 5; // Scale up time influence

    // Calculate noise-based rotation for each axis with different offsets
    const noiseX = this.noise.noise(
      x * noiseScale + time * timeScale,
      y * noiseScale,
      z * noiseScale + 1000 // Offset for X axis
    );

    const noiseY = this.noise.noise(
      x * noiseScale + 2000, // Offset for Y axis
      y * noiseScale + time * timeScale,
      z * noiseScale
    );

    const noiseZ = this.noise.noise(
      x * noiseScale,
      y * noiseScale + 3000, // Offset for Z axis
      z * noiseScale + time * timeScale
    );

    // Apply rotation combining base rotation speed with noise variation and mouse influence
    this.dummyPos.rotation.x =
      time * rotConfig.rotationSpeed * 0.5 +
      noiseX * rotConfig.noiseInfluenceX * Math.PI * 2 +
      (mouseInfluence?.x || 0);

    this.dummyPos.rotation.y =
      time * rotConfig.rotationSpeed * 0.3 +
      noiseY * rotConfig.noiseInfluenceY * Math.PI * 2 +
      (mouseInfluence?.y || 0);

    this.dummyPos.rotation.z =
      time * rotConfig.rotationSpeed * 0.2 +
      noiseZ * rotConfig.noiseInfluenceZ * Math.PI * 2 +
      (mouseInfluence?.z || 0);
  }

  private initPostProcessing(): void {
    this.postProcessingManager = new PostProcessingManager(
      this.renderer,
      this.scene,
      this.camera,
      this.canvas
    );
    this.postProcessingManager.init();
  }

  public updatePostProcessing(): void {
    if (this.postProcessingManager) {
      this.postProcessingManager.updatePostProcessing();
    }
  }

  private animate(time: number = 0): void {
    this.animationFrameId = requestAnimationFrame(this.animate.bind(this));

    // Calculate delta time for smooth interpolation
    const deltaTime = this.clock.getDelta();

    // Update smooth mouse position
    if (this.mouseInteractionManager) {
      this.mouseInteractionManager.updateSmoothMousePosition(deltaTime);
    }

    // Update smooth hand position
    if (this.handTrackingManager) {
      this.handTrackingManager.updateSmoothHandPosition(deltaTime);
    }

    // Update controls
    this.controls.update();

    time *= 0.0003;

    // Rotate all mesh types
    if (this.instancedMesh) {
      this.instancedMesh.rotation.x = Math.sin(time * 0.25);
      this.instancedMesh.rotation.y = Math.sin(time * 0.2);
    }
    if (this.wireframeInstancedMesh) {
      this.wireframeInstancedMesh.rotation.x = Math.sin(time * 0.25);
      this.wireframeInstancedMesh.rotation.y = Math.sin(time * 0.2);
    }
    if (this.edgesGroup) {
      this.edgesGroup.rotation.x = Math.sin(time * 0.25);
      this.edgesGroup.rotation.y = Math.sin(time * 0.2);
    }

    let i = 0;
    const countPerSide = metaShapesConf.instanceMesh.countPerSide;
    for (let x = 0; x < countPerSide; x += 1) {
      for (let y = 0; y < countPerSide; y += 1) {
        for (let z = 0; z < countPerSide; z += 1) {
          this.dummyPos.userData.update({ i, x, y, z, time });
          this.dummyPos.updateMatrix();

          // Update solid mesh matrix
          if (this.instancedMesh) {
            this.instancedMesh.setMatrixAt(i, this.dummyPos.matrix);
          }

          // Update wireframe mesh matrix
          if (this.wireframeInstancedMesh) {
            this.wireframeInstancedMesh.setMatrixAt(i, this.dummyPos.matrix);
          }

          // Update edges mesh matrix
          if (this.edgesGroup && this.edgesGroup.children[i]) {
            const edgesMesh = this.edgesGroup.children[i] as THREE.LineSegments;
            edgesMesh.position.copy(this.dummyPos.position);
            edgesMesh.scale.copy(this.dummyPos.scale);
            edgesMesh.rotation.copy(this.dummyPos.rotation);
          }

          i += 1;
        }
      }
    }

    // Mark instance matrices for update
    if (this.instancedMesh) {
      this.instancedMesh.instanceMatrix.needsUpdate = true;
    }
    if (this.wireframeInstancedMesh) {
      this.wireframeInstancedMesh.instanceMatrix.needsUpdate = true;
    }

    // Render scene using post-processing composer or direct renderer
    if (metaShapesConf.postProcessing.enabled && this.postProcessingManager) {
      this.postProcessingManager.render();
    } else {
      this.renderer.render(this.scene, this.camera);
    }
  }

  public async init(): Promise<void> {
    try {
      if (this.options.controlsContainer) {
        this.initGUI();
      }

      this.initScene();
      this.initCamera();
      this.initRenderer();
      this.initControls();
      this.initLights();
      this.setupResize();
      this.setupMouseInteraction();
      await this.setupHandTracking();
      this.initObjects();
      this.initPostProcessing();

      this.animate(0);

      // Initialization complete
    } catch (error) {
      console.error("Failed to initialize MetaShapesExperience:", error);
      throw error;
    }
  }

  public async updateHandTracking(): Promise<void> {
    if (metaShapesConf.handTracking.enabled) {
      // If hand tracking is enabled but doesn't exist, create it
      if (!this.handTrackingManager) {
        await this.setupHandTracking();
      } else {
        // If it exists, resume it (now async)
        await this.handTrackingManager.resume();
      }
    } else {
      // If hand tracking should be disabled, pause it completely
      if (this.handTrackingManager) {
        this.handTrackingManager.pause();
      }
    }
  }

  public dispose(): void {
    // Cancel animation frame
    if (this.animationFrameId !== null) {
      cancelAnimationFrame(this.animationFrameId);
    }

    // Remove resize listener
    if (this.handleResize) {
      window.removeEventListener("resize", this.handleResize);
    }

    // Dispose mouse interaction manager
    if (this.mouseInteractionManager) {
      this.mouseInteractionManager.dispose();
    }

    // Dispose hand tracking manager
    if (this.handTrackingManager) {
      this.handTrackingManager.dispose();
    }

    // Dispose of Tweakpane
    if (this.pane) {
      this.pane.dispose();
    }

    // Dispose of post-processing resources
    if (this.postProcessingManager) {
      this.postProcessingManager.dispose();
    }

    // Dispose of all objects
    this.objects.forEach((object) => {
      if (object instanceof THREE.Mesh) {
        object.geometry.dispose();
        if (Array.isArray(object.material)) {
          object.material.forEach((material) => material.dispose());
        } else {
          object.material.dispose();
        }
      }
    });

    // Dispose instanced meshes
    if (this.instancedMesh) {
      this.instancedMesh.dispose();
    }
    if (this.wireframeInstancedMesh) {
      this.wireframeInstancedMesh.dispose();
    }

    // Dispose edges group
    if (this.edgesGroup) {
      this.edgesGroup.children.forEach((child) => {
        if (child instanceof THREE.LineSegments) {
          child.geometry.dispose();
          if (Array.isArray(child.material)) {
            child.material.forEach((material) => material.dispose());
          } else {
            child.material.dispose();
          }
        }
      });
      this.edgesGroup.clear();
    }

    // Clear objects array
    this.objects.length = 0;

    // Dispose of renderer
    if (this.renderer) {
      this.renderer.dispose();
    }

    // Disposal complete
  }

  private initGUI(): void {
    const container = this.options.controlsContainer;

    this.pane = new Pane({
      title: "Meta Shapes",
      expanded: true,
      ...(container && { container }),
    });

    // Formation Settings
    const formationFolder = this.pane.addFolder({
      title: "Formation",
      expanded: false,
    });

    formationFolder
      .addBinding(metaShapesConf.instanceMesh.formation, "type", {
        label: "Formation Type",
        options: {
          Cube: "cube",
          Sphere: "sphere",
          Cylinder: "cylinder",
          Plane: "plane",
          Helix: "helix",
          Random: "random",
          Torus: "torus",
          Wave: "wave",
        },
      })
      .on("change", () => this.updateFormation());

    formationFolder
      .addBinding(metaShapesConf.instanceMesh.formation, "density", {
        label: "Density",
        min: 0.1,
        max: 3,
        step: 0.1,
      })
      .on("change", () => this.updateFormation());

    // Instance Mesh Settings
    const instanceFolder = this.pane.addFolder({
      title: "Instance Mesh",
      expanded: false,
    });

    instanceFolder
      .addBinding(metaShapesConf.instanceMesh, "countPerSide", {
        label: "Count Per Side",
        min: 1,
        max: 30,
        step: 1,
      })
      .on("change", () => this.updateInstancedMesh());

    instanceFolder
      .addBinding(metaShapesConf.instanceMesh, "spacing", {
        label: "Spacing",
        min: 0.1,
        max: 3,
        step: 0.1,
      })
      .on("change", () => this.updateInstancedMesh());

    // Color Settings
    const colorFolder = this.pane.addFolder({
      title: "Colors",
      expanded: false,
    });

    colorFolder
      .addBinding(metaShapesConf.color, "mode", {
        label: "Color Mode",
        options: {
          Original: "original",
          Palette: "palette",
          Rainbow: "rainbow",
          Distance: "distance",
          Position: "position",
        },
      })
      .on("change", () => this.updateColors());

    colorFolder
      .addBinding(metaShapesConf.color, "baseHue", {
        label: "Base Hue",
        min: 0,
        max: 1,
        step: 0.01,
      })
      .on("change", () => this.updateColors());

    colorFolder
      .addBinding(metaShapesConf.color, "saturation", {
        label: "Saturation",
        min: 0,
        max: 1,
        step: 0.01,
      })
      .on("change", () => this.updateColors());

    colorFolder
      .addBinding(metaShapesConf.color, "lightness", {
        label: "Lightness",
        min: 0,
        max: 1,
        step: 0.01,
      })
      .on("change", () => this.updateColors());

    // Material Settings
    const materialFolder = this.pane.addFolder({
      title: "Material",
      expanded: false,
    });

    materialFolder
      .addBinding(metaShapesConf.instanceMesh.material, "renderMode", {
        label: "Render Mode",
        options: {
          Solid: "solid",
          Wireframe: "wireframe",
          Edges: "edges",
          Both: "both",
        },
      })
      .on("change", () => this.updateInstancedMesh());

    // Geometry Settings
    const geometryFolder = this.pane.addFolder({
      title: "Geometry",
      expanded: false,
    });

    geometryFolder
      .addBinding(metaShapesConf.instanceMesh.geometry, "type", {
        label: "Geometry Type",
        options: {
          Box: "box",
          Sphere: "sphere",
          Cylinder: "cylinder",
          Cone: "cone",
          Icosahedron: "icosahedron",
          Octahedron: "octahedron",
          Tetrahedron: "tetrahedron",
          Dodecahedron: "dodecahedron",
        },
      })
      .on("change", () => this.updateInstancedMesh());

    geometryFolder
      .addBinding(metaShapesConf.instanceMesh.geometry, "size", {
        label: "Size",
        min: 0.1,
        max: 2,
        step: 0.1,
      })
      .on("change", () => this.updateInstancedMesh());

    // Rotation Settings
    const rotationFolder = this.pane.addFolder({
      title: "Rotation",
      expanded: false,
    });

    rotationFolder
      .addBinding(metaShapesConf.rotation, "enabled", {
        label: "Enabled",
      })
      .on("change", () => this.updateRotation());

    rotationFolder.addBinding(metaShapesConf.rotation, "rotationSpeed", {
      label: "Speed",
      min: 0,
      max: 5,
      step: 0.1,
    });

    rotationFolder
      .addBinding(metaShapesConf.rotation, "individualRotation", {
        label: "Individual",
      })
      .on("change", () => this.updateRotation());

    // Mouse Interaction Settings
    const mouseFolder = this.pane.addFolder({
      title: "Mouse Interaction",
      expanded: false,
    });

    mouseFolder.addBinding(metaShapesConf.mouseInteraction, "enabled", {
      label: "Enabled",
    });

    mouseFolder.addBinding(metaShapesConf.mouseInteraction, "effectType", {
      label: "Effect Type",
      options: {
        Attraction: "attraction",
        Repulsion: "repulsion",
        Scale: "scale",
        "Color Wave": "colorWave",
        "Rotation Influence": "rotationInfluence",
        "Height Wave": "heightWave",
        Combined: "combined",
      },
    });

    mouseFolder.addBinding(metaShapesConf.mouseInteraction, "intensity", {
      label: "Intensity",
      min: 0,
      max: 3,
      step: 0.1,
    });

    mouseFolder.addBinding(metaShapesConf.mouseInteraction, "radius", {
      label: "Radius",
      min: 1,
      max: 20,
      step: 0.5,
    });

    // Post-processing Settings
    const postProcessingFolder = this.pane.addFolder({
      title: "Post-processing",
      expanded: false,
    });

    postProcessingFolder
      .addBinding(metaShapesConf.postProcessing, "enabled", {
        label: "Enabled",
      })
      .on("change", () => this.updatePostProcessing());

    postProcessingFolder
      .addBinding(metaShapesConf.postProcessing.bloom, "enabled", {
        label: "Bloom",
      })
      .on("change", () => this.updatePostProcessing());

    postProcessingFolder
      .addBinding(metaShapesConf.postProcessing.bloom, "strength", {
        label: "Bloom Strength",
        min: 0,
        max: 3,
        step: 0.1,
      })
      .on("change", () => this.updatePostProcessing());

    // Hand Tracking Settings
    const handTrackingFolder = this.pane.addFolder({
      title: "Hand Tracking",
      expanded: false,
    });

    handTrackingFolder
      .addBinding(metaShapesConf.handTracking, "enabled", {
        label: "Enabled",
      })
      .on("change", async () => {
        await this.updateHandTracking();
      });

    handTrackingFolder
      .addBinding(metaShapesConf.handTracking, "minDetectionConfidence", {
        label: "Detection Confidence",
        min: 0.1,
        max: 1.0,
        step: 0.1,
      })
      .on("change", async () => {
        await this.updateHandTracking();
      });

    // Reset button
    this.pane
      .addButton({
        title: "Reset All Settings",
      })
      .on("click", () => {
        // Reset key settings to defaults
        metaShapesConf.instanceMesh.formation.type = "cube";
        metaShapesConf.instanceMesh.formation.density = 1.0;
        metaShapesConf.instanceMesh.countPerSide = 10;
        metaShapesConf.color.mode = "rainbow";
        metaShapesConf.rotation.enabled = true;
        metaShapesConf.mouseInteraction.enabled = true;

        this.pane.refresh();
        this.updateFormation();
        this.updateColors();
        this.updateRotation();
      });
  }

  public updateFormation(): void {
    // Recreate the instanced mesh with new formation
    this.createInstancedMesh();

    // Auto-adjust camera based on formation type
    this.formationManager.adjustCameraForFormation(this.camera, this.controls);
  }
}



================================================
FILE: src/vanilla-three/experiences/meta-shapes/managers/ColorManager.ts
================================================
import * as THREE from "three";
import { metaShapesConf, colorPalettes } from "../constants";

export class ColorManager {
  public calculateColor(
    x: number,
    y: number,
    z: number,
    nz: number,
    time: number,
    countPerSide: number,
    mouseColorInfluence: number
  ): THREE.Color {
    const colorConfig = metaShapesConf.color;
    const color = new THREE.Color();

    switch (colorConfig.mode) {
      case "original":
        return this.calculateOriginalColor(
          nz,
          time,
          color,
          mouseColorInfluence
        );

      case "palette":
        return this.calculatePaletteColor(
          x,
          y,
          z,
          nz,
          time,
          countPerSide,
          color,
          mouseColorInfluence
        );

      case "rainbow":
        return this.calculateRainbowColor(
          x,
          y,
          z,
          nz,
          time,
          countPerSide,
          color,
          mouseColorInfluence
        );

      case "distance":
        return this.calculateDistanceColor(
          x,
          y,
          z,
          nz,
          time,
          countPerSide,
          color,
          mouseColorInfluence
        );

      case "position":
        return this.calculatePositionColor(
          x,
          y,
          z,
          nz,
          time,
          countPerSide,
          color,
          mouseColorInfluence
        );

      default:
        return this.calculateOriginalColor(
          nz,
          time,
          color,
          mouseColorInfluence
        );
    }
  }

  private calculateOriginalColor(
    nz: number,
    time: number,
    color: THREE.Color,
    mouseColorInfluence: number
  ): THREE.Color {
    const config = metaShapesConf.color;
    const hue =
      config.baseHue +
      nz * config.noiseInfluence +
      time * config.timeInfluence +
      mouseColorInfluence * 0.3;
    color.setHSL(
      hue,
      config.saturation + mouseColorInfluence * 0.2,
      config.lightness + nz * 0.1 + mouseColorInfluence * 0.3
    );
    return color;
  }

  private calculatePaletteColor(
    x: number,
    y: number,
    z: number,
    nz: number,
    time: number,
    countPerSide: number,
    color: THREE.Color,
    mouseColorInfluence: number
  ): THREE.Color {
    const config = metaShapesConf.color;
    const palette = colorPalettes[config.paletteIndex];

    // Use noise and position to select from palette
    const factor = (nz + 3) / 6; // Normalize noise from -3,3 to 0,1
    const timeFactor = Math.sin(time * config.timeInfluence * 10) * 0.5 + 0.5;
    const positionFactor = (x + y + z) / (countPerSide * 3);

    const combinedFactor =
      (factor * 0.6 +
        timeFactor * 0.2 +
        positionFactor * 0.2 +
        mouseColorInfluence * 0.4) %
      1;
    const paletteIndex = combinedFactor * (palette.hues.length - 1);
    const index = Math.floor(paletteIndex);
    const t = paletteIndex - index;

    // Interpolate between two palette colors
    const hue1 = palette.hues[index];
    const sat1 = palette.saturations[index];
    const light1 = palette.lightnesses[index];

    const nextIndex = Math.min(index + 1, palette.hues.length - 1);
    const hue2 = palette.hues[nextIndex];
    const sat2 = palette.saturations[nextIndex];
    const light2 = palette.lightnesses[nextIndex];

    const finalHue = hue1 + (hue2 - hue1) * t;
    const finalSat = sat1 + (sat2 - sat1) * t + mouseColorInfluence * 0.3;
    const finalLight =
      light1 + (light2 - light1) * t + nz * 0.05 + mouseColorInfluence * 0.4;

    color.setHSL(
      finalHue % 1,
      Math.max(0.1, Math.min(1.0, finalSat)),
      Math.max(0.1, Math.min(0.9, finalLight))
    );
    return color;
  }

  private calculateRainbowColor(
    x: number,
    y: number,
    z: number,
    nz: number,
    time: number,
    countPerSide: number,
    color: THREE.Color,
    mouseColorInfluence: number
  ): THREE.Color {
    const config = metaShapesConf.color;
    const normalizedX = x / (countPerSide - 1);
    const normalizedY = y / (countPerSide - 1);
    const normalizedZ = z / (countPerSide - 1);

    const hue =
      (normalizedX +
        normalizedY * 0.5 +
        normalizedZ * 0.3 +
        time * config.timeInfluence +
        mouseColorInfluence * 0.5) %
      1;
    const saturation = config.saturation + mouseColorInfluence * 0.2;
    const lightness =
      config.lightness +
      nz * config.noiseInfluence +
      Math.sin(time * 2 + x * 0.1) * 0.1 +
      mouseColorInfluence * 0.3;

    color.setHSL(
      hue,
      Math.max(0.1, Math.min(1.0, saturation)),
      Math.max(0.1, Math.min(0.9, lightness))
    );
    return color;
  }

  private calculateDistanceColor(
    x: number,
    y: number,
    z: number,
    nz: number,
    time: number,
    countPerSide: number,
    color: THREE.Color,
    mouseColorInfluence: number
  ): THREE.Color {
    const config = metaShapesConf.color;
    const centerX = (countPerSide - 1) / 2;
    const centerY = (countPerSide - 1) / 2;
    const centerZ = (countPerSide - 1) / 2;

    const distance = Math.sqrt(
      Math.pow(x - centerX, 2) +
        Math.pow(y - centerY, 2) +
        Math.pow(z - centerZ, 2)
    );
    const maxDistance = Math.sqrt(3 * Math.pow(centerX, 2));
    const normalizedDistance = distance / maxDistance;

    const hue =
      (config.baseHue +
        normalizedDistance * config.hueRange +
        time * config.timeInfluence +
        mouseColorInfluence * 0.4) %
      1;
    const saturation = config.saturation + mouseColorInfluence * 0.2;
    const lightness =
      config.lightness +
      nz * config.noiseInfluence +
      normalizedDistance * 0.3 +
      mouseColorInfluence * 0.3;

    color.setHSL(
      hue,
      Math.max(0.1, Math.min(1.0, saturation)),
      Math.max(0.1, Math.min(0.9, lightness))
    );
    return color;
  }

  private calculatePositionColor(
    x: number,
    y: number,
    z: number,
    nz: number,
    time: number,
    countPerSide: number,
    color: THREE.Color,
    mouseColorInfluence: number
  ): THREE.Color {
    const config = metaShapesConf.color;
    const normalizedX = x / (countPerSide - 1);
    const normalizedY = y / (countPerSide - 1);
    const normalizedZ = z / (countPerSide - 1);

    const hue =
      (config.baseHue +
        normalizedX * config.hueRange +
        time * config.timeInfluence +
        mouseColorInfluence * 0.4) %
      1;
    const saturation =
      config.saturation - normalizedY * 0.3 + mouseColorInfluence * 0.2;
    const lightness =
      config.lightness +
      normalizedZ * 0.4 +
      nz * config.noiseInfluence +
      mouseColorInfluence * 0.3;

    color.setHSL(
      hue,
      Math.max(0.2, Math.min(1.0, saturation)),
      Math.max(0.1, Math.min(0.9, lightness))
    );
    return color;
  }
}



================================================
FILE: src/vanilla-three/experiences/meta-shapes/managers/FormationManager.ts
================================================
import * as THREE from "three";
import { metaShapesConf, type FormationConfig } from "../constants";

export class FormationManager {
  public calculateFormationPosition(
    index: number,
    x: number,
    y: number,
    z: number,
    totalCount: number,
    countPerSide: number
  ): THREE.Vector3 {
    const formation = metaShapesConf.instanceMesh.formation;
    const spacing = metaShapesConf.instanceMesh.spacing;

    switch (formation.type) {
      case "cube":
        return this.calculateCubePosition(x, y, z, countPerSide, spacing);

      case "sphere":
        return this.calculateSpherePosition(index, totalCount, formation);

      case "cylinder":
        return this.calculateCylinderPosition(index, totalCount, formation);

      case "plane":
        return this.calculatePlanePosition(x, z, countPerSide, spacing);

      case "helix":
        return this.calculateHelixPosition(index, totalCount, formation);

      case "random":
        return this.calculateRandomPosition(index, formation);

      case "torus":
        return this.calculateTorusPosition(index, totalCount, formation);

      case "wave":
        return this.calculateWavePosition(
          x,
          z,
          countPerSide,
          spacing,
          formation
        );

      case "tesseract":
        return this.calculateTesseractPosition(index, totalCount, formation);

      default:
        return this.calculateCubePosition(x, y, z, countPerSide, spacing);
    }
  }

  private calculateCubePosition(
    x: number,
    y: number,
    z: number,
    countPerSide: number,
    spacing: number
  ): THREE.Vector3 {
    const offset = (countPerSide - 1) / 2;
    return new THREE.Vector3(
      (x - offset) * spacing,
      (y - offset) * spacing,
      (z - offset) * spacing
    );
  }

  private calculateSpherePosition(
    index: number,
    totalCount: number,
    formation: FormationConfig
  ): THREE.Vector3 {
    const radius = formation.radius || 8.0;

    // Use golden ratio spiral for even distribution
    const goldenRatio = (1 + Math.sqrt(5)) / 2;
    const theta = (2 * Math.PI * index) / goldenRatio;
    const phi = Math.acos(1 - (2 * index) / totalCount);

    return new THREE.Vector3(
      radius * Math.sin(phi) * Math.cos(theta),
      radius * Math.sin(phi) * Math.sin(theta),
      radius * Math.cos(phi)
    );
  }

  private calculateCylinderPosition(
    index: number,
    totalCount: number,
    formation: FormationConfig
  ): THREE.Vector3 {
    const radius = formation.radius || 8.0;
    const height = formation.height || 16.0;

    const layerCount = Math.ceil(Math.sqrt(totalCount));
    const instancesPerLayer = Math.ceil(totalCount / layerCount);

    const layer = Math.floor(index / instancesPerLayer);
    const indexInLayer = index % instancesPerLayer;

    const angle = (indexInLayer / instancesPerLayer) * Math.PI * 2;
    const y = (layer / (layerCount - 1)) * height - height / 2;

    return new THREE.Vector3(
      radius * Math.cos(angle),
      y,
      radius * Math.sin(angle)
    );
  }

  private calculatePlanePosition(
    x: number,
    z: number,
    countPerSide: number,
    spacing: number
  ): THREE.Vector3 {
    const offset = (countPerSide - 1) / 2;
    return new THREE.Vector3((x - offset) * spacing, 0, (z - offset) * spacing);
  }

  private calculateHelixPosition(
    index: number,
    totalCount: number,
    formation: FormationConfig
  ): THREE.Vector3 {
    const radius = formation.radius || 8.0;
    const height = formation.height || 16.0;
    const turns = formation.turns || 3;

    const t = index / totalCount;
    const angle = t * turns * Math.PI * 2;
    const y = t * height - height / 2;

    return new THREE.Vector3(
      radius * Math.cos(angle),
      y,
      radius * Math.sin(angle)
    );
  }

  private calculateRandomPosition(
    index: number,
    formation: FormationConfig
  ): THREE.Vector3 {
    const radius = formation.radius || 8.0;
    const seed = formation.randomSeed || 42;

    // Simple seeded random using index
    const seedValue = (seed + index) * 9301 + 49297;
    const random1 = (seedValue % 233280) / 233280;
    const random2 = ((seedValue * 1.1) % 233280) / 233280;
    const random3 = ((seedValue * 1.3) % 233280) / 233280;

    return new THREE.Vector3(
      (random1 - 0.5) * radius * 2,
      (random2 - 0.5) * radius * 2,
      (random3 - 0.5) * radius * 2
    );
  }

  private calculateTorusPosition(
    index: number,
    totalCount: number,
    formation: FormationConfig
  ): THREE.Vector3 {
    const majorRadius = formation.radius || 8.0;
    const minorRadius = majorRadius * 0.3;

    const ringCount = Math.ceil(Math.sqrt(totalCount / 4));
    const instancesPerRing = Math.ceil(totalCount / ringCount);

    const ring = Math.floor(index / instancesPerRing);
    const indexInRing = index % instancesPerRing;

    const u = (ring / ringCount) * Math.PI * 2;
    const v = (indexInRing / instancesPerRing) * Math.PI * 2;

    return new THREE.Vector3(
      (majorRadius + minorRadius * Math.cos(v)) * Math.cos(u),
      minorRadius * Math.sin(v),
      (majorRadius + minorRadius * Math.cos(v)) * Math.sin(u)
    );
  }

  private calculateWavePosition(
    x: number,
    z: number,
    countPerSide: number,
    spacing: number,
    formation: FormationConfig
  ): THREE.Vector3 {
    const offset = (countPerSide - 1) / 2;
    const amplitude = formation.amplitude || 2.0;
    const frequency = formation.frequency || 0.5;

    const xPos = (x - offset) * spacing;
    const zPos = (z - offset) * spacing;

    const y =
      amplitude * Math.sin(xPos * frequency) * Math.cos(zPos * frequency);

    return new THREE.Vector3(xPos, y, zPos);
  }

  private calculateTesseractPosition(
    index: number,
    totalCount: number,
    formation: FormationConfig
  ): THREE.Vector3 {
    const scale = formation.tesseractScale || 8.0;
    const projectionType = formation.projectionType || "stereographic";
    const rotationW = formation.rotationW || 0;
    const timeRotation = formation.timeRotation || false;

    // Generate 4D hypercube vertices (tesseract has 16 vertices)
    const verticesPerDimension = Math.ceil(Math.pow(totalCount, 1 / 4));
    const spacing4D = 2 / (verticesPerDimension - 1);

    // Convert linear index to 4D coordinates
    const w =
      Math.floor(index / Math.pow(verticesPerDimension, 3)) %
      verticesPerDimension;
    const z =
      Math.floor(index / Math.pow(verticesPerDimension, 2)) %
      verticesPerDimension;
    const y = Math.floor(index / verticesPerDimension) % verticesPerDimension;
    const x = index % verticesPerDimension;

    // Create 4D point in hypercube [-1, 1]^4
    const point4D = {
      x: x * spacing4D - 1,
      y: y * spacing4D - 1,
      z: z * spacing4D - 1,
      w: w * spacing4D - 1,
    };

    // Apply 4D rotation if enabled
    let rotatedPoint = point4D;
    if (timeRotation) {
      const time = performance.now() * 0.001;
      const angle = rotationW + time * 0.1;
      rotatedPoint = this.rotate4D(point4D, angle);
    }

    // Project from 4D to 3D
    let projected3D: THREE.Vector3;
    if (projectionType === "stereographic") {
      projected3D = this.stereographicProjection(rotatedPoint, scale);
    } else {
      projected3D = this.orthographicProjection(rotatedPoint, scale);
    }

    return projected3D;
  }

  private rotate4D(
    point: { x: number; y: number; z: number; w: number },
    angle: number
  ) {
    // Simple 4D rotation in XW plane
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);

    return {
      x: point.x * cos - point.w * sin,
      y: point.y,
      z: point.z,
      w: point.x * sin + point.w * cos,
    };
  }

  private stereographicProjection(
    point4D: { x: number; y: number; z: number; w: number },
    scale: number
  ): THREE.Vector3 {
    // Stereographic projection from 4D to 3D
    const denominator = 1 - point4D.w;
    const factor = denominator !== 0 ? 1 / denominator : 1;

    return new THREE.Vector3(
      point4D.x * factor * scale,
      point4D.y * factor * scale,
      point4D.z * factor * scale
    );
  }

  private orthographicProjection(
    point4D: { x: number; y: number; z: number; w: number },
    scale: number
  ): THREE.Vector3 {
    // Simple orthographic projection (drop W coordinate)
    return new THREE.Vector3(
      point4D.x * scale,
      point4D.y * scale,
      point4D.z * scale
    );
  }

  public adjustCameraForFormation(
    camera: THREE.PerspectiveCamera,
    controls: any
  ): void {
    const formation = metaShapesConf.instanceMesh.formation;
    const [x, y] = metaShapesConf.camera.position;
    let z = 15;

    switch (formation.type) {
      case "sphere":
        z = (formation.radius || 8) * 2.5;
        break;
      case "cylinder":
        z = Math.max(
          (formation.radius || 8) * 2.5,
          (formation.height || 16) * 1.2
        );
        break;
      case "helix":
        z = Math.max(
          (formation.radius || 8) * 2.5,
          (formation.height || 16) * 1.2
        );
        break;
      case "torus":
        z = (formation.radius || 8) * 3;
        break;
      case "tesseract":
        z = (formation.tesseractScale || 8) * 3;
        break;
      default:
        z = metaShapesConf.instanceMesh.countPerSide * 1.8;
    }

    camera.position.set(x, y, z);
    controls.update();
  }
}



================================================
FILE: src/vanilla-three/experiences/meta-shapes/managers/GeometryManager.ts
================================================
import * as THREE from "three";
import { metaShapesConf } from "../constants";

export class GeometryManager {
  public createGeometry(): THREE.BufferGeometry {
    const config = metaShapesConf.instanceMesh.geometry;
    const {
      type,
      size,
      detail,
      height,
      radiusTop,
      radiusBottom,
      radialSegments,
      heightSegments,
      widthSegments,
      phiLength,
      thetaLength,
    } = config;

    switch (type) {
      case "box":
        return new THREE.BoxGeometry(size, size, size);

      case "sphere":
        return new THREE.SphereGeometry(
          size / 2,
          widthSegments || 8,
          heightSegments || 6,
          0,
          phiLength || Math.PI * 2,
          0,
          thetaLength || Math.PI
        );

      case "cylinder":
        return new THREE.CylinderGeometry(
          radiusTop || size / 2,
          radiusBottom || size / 2,
          height || size,
          radialSegments || 8,
          heightSegments || 1
        );

      case "cone":
        return new THREE.ConeGeometry(
          radiusBottom || size / 2,
          height || size,
          radialSegments || 8,
          heightSegments || 1
        );

      case "icosahedron":
        return new THREE.IcosahedronGeometry(size / 2, detail || 0);

      case "octahedron":
        return new THREE.OctahedronGeometry(size / 2, detail || 0);

      case "tetrahedron":
        return new THREE.TetrahedronGeometry(size / 2, detail || 0);

      case "dodecahedron":
        return new THREE.DodecahedronGeometry(size / 2, detail || 0);

      default:
        return new THREE.BoxGeometry(size, size, size);
    }
  }
}



================================================
FILE: src/vanilla-three/experiences/meta-shapes/managers/HandTrackingManager.ts
================================================
import * as THREE from "three";
import { metaShapesConf } from "../constants";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";
// import { FilesetResolver, HandLandmarker } from "@mediapipe/tasks-vision";

// MediaPipe Tasks Vision types
interface HandLandmarkerResult {
  landmarks: Array<Array<{ x: number; y: number; z: number }>>;
  worldLandmarks: Array<Array<{ x: number; y: number; z: number }>>;
  handednesses: Array<
    Array<{
      index: number;
      score: number;
      categoryName: string;
      displayName: string;
    }>
  >;
}

// Moving average filter for smoothing
class MovingAverageFilter {
  private values: THREE.Vector3[] = [];
  private maxSamples: number;

  constructor(maxSamples: number = 5) {
    this.maxSamples = maxSamples;
  }

  update(value: THREE.Vector3): THREE.Vector3 {
    this.values.push(value.clone());
    if (this.values.length > this.maxSamples) {
      this.values.shift();
    }

    const sum = new THREE.Vector3();
    this.values.forEach((v) => sum.add(v));
    return sum.divideScalar(this.values.length);
  }

  reset(): void {
    this.values = [];
  }
}

// Gesture debouncer to prevent flickering
// DISABLED: GestureDebouncer class - not used in dual hand tracking
// class GestureDebouncer {
//   private gestureHistory: { [key: string]: boolean[] } = {};
//   private historyLength: number;
//   private threshold: number;
//   ... implementation commented out
// }

export class HandTrackingManager {
  private camera: THREE.PerspectiveCamera;
  // private canvas: HTMLCanvasElement; // Removed as not used in dual hand tracking
  private controls: OrbitControls | null = null;
  private videoElement: HTMLVideoElement | null = null;
  private mediaStream: MediaStream | null = null;

  // Canvas overlay for drawing hand landmarks
  private canvasElement: HTMLCanvasElement | null = null;
  private canvasContext: CanvasRenderingContext2D | null = null;

  // Hand tracking state - now supporting dual hands
  private handLandmarker: any | null = null;
  private handPosition = new THREE.Vector3();
  private smoothedHandPosition = new THREE.Vector3();
  private targetHandPosition = new THREE.Vector3();
  private isHandDetected = false;
  private handedness: "Left" | "Right" | null = null;
  private handConfidence = 0;

  // Dual hand tracking - separate hands for different functions
  private leftHand = {
    detected: false,
    confidence: 0,
    position: new THREE.Vector3(),
    smoothedPosition: new THREE.Vector3(),
    targetPosition: new THREE.Vector3(),
    landmarks: null as Array<{ x: number; y: number; z: number }> | null,
    lastValidPosition: new THREE.Vector3(),
    isPinching: false,
    handSpread: 0.5,
  };

  private rightHand = {
    detected: false,
    confidence: 0,
    position: new THREE.Vector3(),
    smoothedPosition: new THREE.Vector3(),
    targetPosition: new THREE.Vector3(),
    landmarks: null as Array<{ x: number; y: number; z: number }> | null,
    lastValidPosition: new THREE.Vector3(),
    isPinching: false,
    handSpread: 0.5,
  };

  // Hand role assignment - can be swapped
  private cameraControlHand: "left" | "right" = "left"; // Left hand for camera control
  private effectsHand: "left" | "right" = "right"; // Right hand for cube effects

  // Individual finger tracking for frequency effects
  private fingerPositions = {
    thumb: new THREE.Vector3(),
    index: new THREE.Vector3(),
    middle: new THREE.Vector3(),
    ring: new THREE.Vector3(),
    pinky: new THREE.Vector3(),
  };
  private fingerActive = {
    thumb: false,
    index: false,
    middle: false,
    ring: false,
    pinky: false,
  };
  private fingerFrequencies = {
    thumb: 0.5, // Low frequency - deep bass-like effects
    index: 1.0, // Medium-low frequency
    middle: 1.5, // Medium frequency
    ring: 2.0, // Medium-high frequency
    pinky: 3.0, // High frequency - treble-like effects
  };
  private fingerColors = {
    thumb: "#ff4444", // Red
    index: "#44ff44", // Green
    middle: "#4444ff", // Blue
    ring: "#ffff44", // Yellow
    pinky: "#ff44ff", // Magenta
  };

  // Hand spread for radius control
  private handSpread = 0.5; // 0 = closed, 1 = fully open
  private handSpreadFilter = new MovingAverageFilter(2); // Reduce from 3 for more responsiveness

  // Improved smoothing and stability - make more responsive like mouse
  private positionFilter = new MovingAverageFilter(2); // Reduce from 3 for more responsiveness
  private lastValidPosition = new THREE.Vector3();
  private positionStabilityThreshold = 0.8; // Increase from 0.2 for less strict stability
  private handLostTimer = 0;
  private handLostThreshold = 300; // Reduce from 500ms for quicker hand loss detection

  // Gesture detection with hysteresis - enable pinch for camera rotation
  private isPinching = false;
  private isPointing = false;
  private isFist = false;
  private isTwisting = false;

  // Pinch detection settings
  private pinchThreshold = 0.06; // Distance threshold for pinch detection
  private pinchHysteresis = 0.02; // Hysteresis to prevent flickering

  // Camera rotation state for pinch control
  private lastPinchPosition = new THREE.Vector2();
  private pinchStartPosition = new THREE.Vector2();
  private cameraControlEnabled = false;

  // Trail tracking with improved timing
  private handTrail: Array<{
    position: THREE.Vector3;
    timestamp: number;
    influence: number;
  }> = [];
  private lastTrailUpdate = 0;
  private trailUpdateInterval = 33; // ~30 FPS for trails

  // Raycasting for 3D position calculation
  private raycaster = new THREE.Raycaster();

  // Animation frame ID for cleanup
  private animationFrameId: number | null = null;
  private lastUpdateTime = 0;
  private detectionInterval = 66; // ~15 FPS instead of 30+ FPS for better performance

  // Performance and state management
  private isPaused = false;
  private isInitialized = false;
  private performanceMode = false; // Skip some expensive calculations when true

  // Performance monitoring
  private lastPerformanceCheck = 0;
  private frameCount = 0;
  private actualFPS = 0;

  // Callbacks
  private onHandResults?: (
    position: THREE.Vector3,
    gestures: {
      isPinching: boolean;
      isPointing: boolean;
      isFist: boolean;
      isTwisting: boolean;
    }
  ) => void;

  constructor(camera: THREE.PerspectiveCamera, controls?: OrbitControls) {
    this.camera = camera;
    this.controls = controls || null;

    // Initialize hand positions
    this.smoothedHandPosition.set(0, 0, 0);
    this.targetHandPosition.set(0, 0, 0);
    this.handPosition.set(0, 0, 0);
    this.lastValidPosition.set(0, 0, 0);

    // Store initial camera distance for zoom reference - DISABLED
    // if (this.controls) {
    //   this.initialCameraDistance = this.camera.position.distanceTo(
    //     this.controls.target
    //   );
    // }
  }

  public async init(): Promise<boolean> {
    // Prevent double initialization
    if (this.isInitialized || this.handLandmarker) {
      console.log("HandTrackingManager: Already initialized, skipping...");
      return true;
    }

    try {
      console.log("HandTrackingManager: Attempting to initialize...");

      // Try dynamic import instead
      const { FilesetResolver, HandLandmarker } = await import(
        "@mediapipe/tasks-vision"
      );
      console.log("HandTrackingManager: MediaPipe import successful");

      // Initialize MediaPipe Tasks Vision
      const vision = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm"
      );
      console.log("HandTrackingManager: FilesetResolver initialized");

      // Create Hand Landmarker with optimized settings for dual hand tracking
      this.handLandmarker = await HandLandmarker.createFromOptions(vision, {
        baseOptions: {
          modelAssetPath:
            "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
        },
        runningMode: "VIDEO",
        numHands: 2, // Enable dual hand tracking
        minHandDetectionConfidence: 0.7, // Slightly lower for dual hands
        minHandPresenceConfidence: 0.6, // Slightly lower for dual hands
        minTrackingConfidence: 0.5, // Lower for better continuity with two hands
      });
      console.log("HandTrackingManager: HandLandmarker created");

      // Create video element for camera feed - move to left side with shadcn styling
      this.videoElement = document.createElement("video");
      this.videoElement.autoplay = true;
      this.videoElement.muted = true;
      this.videoElement.playsInline = true;
      this.videoElement.style.position = "fixed";
      this.videoElement.style.top = "20px";
      this.videoElement.style.left = "20px"; // Move to left side
      this.videoElement.style.width = "280px"; // Slightly larger
      this.videoElement.style.height = "210px";
      this.videoElement.style.zIndex = "1000";
      this.videoElement.style.border = "1px solid hsl(var(--border))"; // shadcn border
      this.videoElement.style.borderRadius = "12px"; // shadcn rounded-xl
      this.videoElement.style.boxShadow =
        "0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)"; // shadcn shadow-lg
      this.videoElement.style.transform = "scaleX(-1)"; // Mirror the video
      this.videoElement.style.backgroundColor = "hsl(var(--background))"; // shadcn background
      document.body.appendChild(this.videoElement);

      // Create canvas overlay for drawing hand landmarks - match video position
      this.canvasElement = document.createElement("canvas");
      this.canvasElement.width = 280;
      this.canvasElement.height = 210;
      this.canvasElement.style.position = "fixed";
      this.canvasElement.style.top = "20px";
      this.canvasElement.style.left = "20px"; // Move to left side
      this.canvasElement.style.width = "280px";
      this.canvasElement.style.height = "210px";
      this.canvasElement.style.zIndex = "1001"; // Above video
      this.canvasElement.style.pointerEvents = "none"; // Don't block video clicks
      this.canvasElement.style.transform = "scaleX(-1)"; // Mirror to match video
      this.canvasElement.style.borderRadius = "12px"; // Match video border radius
      document.body.appendChild(this.canvasElement);

      this.canvasContext = this.canvasElement.getContext("2d");

      // Create gesture status overlay with shadcn styling
      const gestureOverlay = document.createElement("div");
      gestureOverlay.id = "gesture-status-overlay";
      gestureOverlay.style.position = "fixed";
      gestureOverlay.style.top = "240px"; // Below the video (20px + 210px + 10px spacing)
      gestureOverlay.style.left = "20px"; // Match video left position
      gestureOverlay.style.width = "280px"; // Match video width
      gestureOverlay.style.padding = "12px"; // shadcn p-3
      gestureOverlay.style.background = "hsl(var(--background) / 0.95)"; // shadcn semi-transparent background
      gestureOverlay.style.backdropFilter = "blur(8px)"; // shadcn backdrop-blur-sm
      gestureOverlay.style.color = "hsl(var(--foreground))"; // shadcn text color
      gestureOverlay.style.fontSize = "12px"; // shadcn text-xs
      gestureOverlay.style.borderRadius = "12px"; // shadcn rounded-xl
      gestureOverlay.style.border = "1px solid hsl(var(--border))"; // shadcn border
      gestureOverlay.style.fontFamily =
        "ui-monospace, SFMono-Regular, 'SF Mono', monospace"; // monospace font
      gestureOverlay.style.zIndex = "1001";
      gestureOverlay.style.boxShadow =
        "0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)"; // shadcn shadow-lg
      gestureOverlay.innerHTML =
        '<div style="color: hsl(var(--muted-foreground));">No hand detected</div>';
      document.body.appendChild(gestureOverlay);

      // Get camera stream with optimized settings
      this.mediaStream = await navigator.mediaDevices.getUserMedia({
        video: {
          width: { ideal: 640, max: 1280 }, // Lower resolution for better performance
          height: { ideal: 480, max: 720 },
          frameRate: { ideal: 30 },
          facingMode: "user",
        },
      });

      this.videoElement.srcObject = this.mediaStream;
      await this.videoElement.play();
      console.log("HandTrackingManager: Video stream started");

      // Start hand detection loop
      this.startDetection();

      console.log("Hand tracking initialized successfully");
      return true;
    } catch (error) {
      console.error("Failed to initialize hand tracking:", error);
      return false;
    }
  }

  private startDetection(): void {
    const detectHands = (currentTime: number) => {
      if (this.isPaused || !this.isInitialized) {
        this.animationFrameId = requestAnimationFrame(detectHands);
        return;
      }

      if (
        this.handLandmarker &&
        this.videoElement &&
        this.videoElement.readyState >= 2
      ) {
        // Throttle detection to ~15 FPS for better performance (was ~30 FPS)
        if (currentTime - this.lastUpdateTime > this.detectionInterval) {
          const results = this.handLandmarker.detectForVideo(
            this.videoElement,
            currentTime
          );
          this.processHandResults(results, currentTime);
          this.lastUpdateTime = currentTime;

          // Update FPS counter
          this.frameCount++;
          if (currentTime - this.lastPerformanceCheck > 1000) {
            // Every second
            this.actualFPS = this.frameCount;
            this.frameCount = 0;
            this.lastPerformanceCheck = currentTime;
          }
        }
      }

      this.animationFrameId = requestAnimationFrame(detectHands);
    };

    this.isInitialized = true;
    detectHands(performance.now());
  }

  private processHandResults(
    results: HandLandmarkerResult,
    currentTime: number
  ): void {
    // Early exit if paused
    if (this.isPaused) {
      return;
    }

    // Reset both hands
    this.leftHand.detected = false;
    this.rightHand.detected = false;

    if (
      results.landmarks &&
      results.landmarks.length > 0 &&
      results.handednesses &&
      results.handednesses.length > 0
    ) {
      // Process each detected hand
      for (let i = 0; i < results.landmarks.length && i < 2; i++) {
        const landmarks = results.landmarks[i];
        const handedness = results.handednesses[i][0];
        const confidence = handedness.score;

        // Only process if confidence is high enough
        if (confidence > metaShapesConf.handTracking.minTrackingConfidence) {
          const isLeftHand = handedness.categoryName === "Left";
          const hand = isLeftHand ? this.leftHand : this.rightHand;

          // Update hand state
          hand.detected = true;
          hand.confidence = confidence;
          hand.landmarks = landmarks;

          // Use index finger tip (landmark 8) as the primary control point
          this.calculateHandPositionForHand(landmarks[8], hand);

          // Calculate hand spread for this hand
          this.calculateHandSpreadForHand(landmarks, hand);

          // Apply position filtering for this hand
          this.applyPositionFilteringForHand(hand);

          // Process based on hand role
          if (
            (isLeftHand && this.cameraControlHand === "left") ||
            (!isLeftHand && this.cameraControlHand === "right")
          ) {
            // This hand is assigned to camera control
            this.processCameraControlHand(landmarks, hand);
          }

          if (
            (isLeftHand && this.effectsHand === "left") ||
            (!isLeftHand && this.effectsHand === "right")
          ) {
            // This hand is assigned to cube effects
            this.processEffectsHand(landmarks, hand, currentTime);
          }
        }
      }

      // Update legacy single-hand properties for backward compatibility
      this.updateLegacyHandProperties();

      // Draw all detected hands
      this.drawAllHandLandmarks();

      // Update gesture overlay
      this.updateGestureOverlay();

      // Trigger callback with combined hand data
      if (this.onHandResults) {
        this.onHandResults(this.handPosition, {
          isPinching: this.isPinching,
          isPointing: this.isPointing,
          isFist: this.isFist,
          isTwisting: this.isTwisting,
        });
      }
    } else {
      // No hands detected - handle loss
      this.handleNoHandsDetected(currentTime);
    }
  }

  private handleNoHandsDetected(currentTime: number): void {
    // Similar to old handleLowConfidenceOrLoss but for dual hands
    this.handLostTimer += 16;

    if (this.handLostTimer > this.handLostThreshold) {
      // Reset all hand states
      this.leftHand.detected = false;
      this.leftHand.confidence = 0;
      this.rightHand.detected = false;
      this.rightHand.confidence = 0;

      this.isHandDetected = false;
      this.handConfidence = 0;
      this.positionFilter.reset();

      // End camera control if active
      if (this.isPinching) {
        this.isPinching = false;
        this.leftHand.isPinching = false;
        this.rightHand.isPinching = false;
        this.endCameraControl();
      }
      this.cameraControlEnabled = false;

      // Clear canvas overlay
      if (this.canvasContext && this.canvasElement) {
        this.canvasContext.clearRect(
          0,
          0,
          this.canvasElement.width,
          this.canvasElement.height
        );
      }

      // Re-enable orbit controls
      if (this.controls) {
        this.controls.enableRotate = true;
      }

      // Update overlay
      this.updateGestureOverlay();

      // Log the time when hands were lost for debugging
      console.log(`Hands lost at time: ${currentTime}`);
    }
  }

  private calculateHandPositionForHand(
    indexFingerTip: { x: number; y: number; z: number },
    hand: typeof this.leftHand
  ): void {
    // Convert normalized coordinates to normalized device coordinates
    const x = (indexFingerTip.x - 0.5) * 2; // Center around 0, range -1 to 1
    const y = -((indexFingerTip.y - 0.5) * 2); // Flip Y and center, range -1 to 1

    // Calculate 3D position for this specific hand
    this.calculateHandPositionInCubeForHand(x, y, indexFingerTip.z, hand);
  }

  private calculateHandPositionInCubeForHand(
    x: number,
    y: number,
    z: number,
    hand: typeof this.leftHand
  ): void {
    const countPerSide = metaShapesConf.instanceMesh.countPerSide;
    const spacing = metaShapesConf.instanceMesh.spacing;
    const gridExtent = (countPerSide - 1) * spacing * 0.5;

    // Direct mapping from hand coordinates to 3D space
    const handX = x * gridExtent * 1.2;
    const handY = y * gridExtent * 1.2;

    // Use depth from MediaPipe more directly
    const depthRange = gridExtent * 0.8;
    const handZ =
      (z - 0.5) *
      depthRange *
      metaShapesConf.handTracking.depthSensitivity *
      0.1;

    // Clamp to cube bounds
    hand.targetPosition.set(
      Math.max(-gridExtent, Math.min(gridExtent, handX)),
      Math.max(-gridExtent, Math.min(gridExtent, handY)),
      Math.max(-gridExtent, Math.min(gridExtent, handZ))
    );
  }

  private calculateHandSpreadForHand(
    landmarks: Array<{ x: number; y: number; z: number }>,
    hand: typeof this.leftHand
  ): void {
    // Calculate distance between thumb tip and pinky tip for hand spread
    const thumbTip = landmarks[4];
    const pinkyTip = landmarks[20];

    const spreadDistance = Math.sqrt(
      Math.pow(thumbTip.x - pinkyTip.x, 2) +
        Math.pow(thumbTip.y - pinkyTip.y, 2) +
        Math.pow(thumbTip.z - pinkyTip.z, 2)
    );

    // Normalize spread distance
    const normalizedSpread = Math.max(0, Math.min(1, spreadDistance / 0.15));
    hand.handSpread = normalizedSpread;
  }

  private applyPositionFilteringForHand(hand: typeof this.leftHand): void {
    // Simple position filtering for each hand
    const positionDelta = hand.targetPosition.distanceTo(
      hand.lastValidPosition
    );

    if (
      positionDelta < this.positionStabilityThreshold ||
      hand.lastValidPosition.length() === 0
    ) {
      hand.lastValidPosition.copy(hand.targetPosition);
    } else {
      // For very large jumps, use interpolation
      hand.targetPosition.lerpVectors(
        hand.lastValidPosition,
        hand.targetPosition,
        0.7
      );
      hand.lastValidPosition.copy(hand.targetPosition);
    }
  }

  private processCameraControlHand(
    landmarks: Array<{ x: number; y: number; z: number }>,
    hand: typeof this.leftHand
  ): void {
    // Detect pinch gesture for camera rotation
    this.detectPinchGestureForHand(landmarks, hand);
  }

  private processEffectsHand(
    landmarks: Array<{ x: number; y: number; z: number }>,
    hand: typeof this.leftHand,
    currentTime: number
  ): void {
    // Calculate individual finger positions and activity for effects
    this.calculateFingerPositions(landmarks);

    // Update trail with better timing for effects hand
    this.updateHandTrail(hand.targetPosition, currentTime);
  }

  private detectPinchGestureForHand(
    landmarks: Array<{ x: number; y: number; z: number }>,
    hand: typeof this.leftHand
  ): void {
    // Calculate distance between thumb tip and index finger tip for pinch detection
    const thumbTip = landmarks[4];
    const indexTip = landmarks[8];

    const pinchDistance = Math.sqrt(
      Math.pow(thumbTip.x - indexTip.x, 2) +
        Math.pow(thumbTip.y - indexTip.y, 2) +
        Math.pow(thumbTip.z - indexTip.z, 2)
    );

    // Apply hysteresis to prevent flickering
    const currentThreshold = hand.isPinching
      ? this.pinchThreshold + this.pinchHysteresis
      : this.pinchThreshold;

    const wasPinching = hand.isPinching;
    hand.isPinching = pinchDistance < currentThreshold;

    // Handle pinch state changes for camera control
    if (hand.isPinching && !wasPinching) {
      this.startCameraControl(landmarks);
    } else if (!hand.isPinching && wasPinching) {
      this.endCameraControl();
    } else if (hand.isPinching) {
      this.updateCameraRotation(landmarks);
    }
  }

  private updateLegacyHandProperties(): void {
    // Update legacy properties for backward compatibility
    // Prioritize effects hand for cube interactions
    const effectsHandData =
      this.effectsHand === "left" ? this.leftHand : this.rightHand;
    const cameraHandData =
      this.cameraControlHand === "left" ? this.leftHand : this.rightHand;

    if (effectsHandData.detected) {
      this.handPosition.copy(effectsHandData.targetPosition);
      this.targetHandPosition.copy(effectsHandData.targetPosition);
      this.handConfidence = effectsHandData.confidence;
      this.handedness = this.effectsHand === "left" ? "Left" : "Right";
      this.handSpread = effectsHandData.handSpread;
      this.isHandDetected = true;
    } else if (cameraHandData.detected) {
      this.handPosition.copy(cameraHandData.targetPosition);
      this.targetHandPosition.copy(cameraHandData.targetPosition);
      this.handConfidence = cameraHandData.confidence;
      this.handedness = this.cameraControlHand === "left" ? "Left" : "Right";
      this.handSpread = cameraHandData.handSpread;
      this.isHandDetected = true;
    } else {
      this.isHandDetected = false;
      this.handConfidence = 0;
    }

    // Update pinch state based on camera control hand
    this.isPinching = cameraHandData.isPinching;
  }

  private drawAllHandLandmarks(): void {
    if (!this.canvasContext || !this.canvasElement) return;

    const canvasWidth = this.canvasElement.width;
    const canvasHeight = this.canvasElement.height;

    // Clear the canvas
    this.canvasContext.clearRect(0, 0, canvasWidth, canvasHeight);

    // Draw left hand if detected
    if (this.leftHand.detected && this.leftHand.landmarks) {
      this.drawSingleHandLandmarks(
        this.leftHand.landmarks,
        "#00ff88",
        this.leftHand.isPinching
      );
    }

    // Draw right hand if detected
    if (this.rightHand.detected && this.rightHand.landmarks) {
      this.drawSingleHandLandmarks(
        this.rightHand.landmarks,
        "#88ff00",
        this.rightHand.isPinching
      );
    }
  }

  private drawSingleHandLandmarks(
    landmarks: Array<{ x: number; y: number; z: number }>,
    color: string,
    isPinching: boolean
  ): void {
    if (!this.canvasContext || !this.canvasElement) return;

    const canvasWidth = this.canvasElement.width;
    const canvasHeight = this.canvasElement.height;

    // Hand landmark connections
    const connections = [
      [0, 1],
      [1, 2],
      [2, 3],
      [3, 4], // Thumb
      [0, 5],
      [5, 6],
      [6, 7],
      [7, 8], // Index finger
      [0, 9],
      [9, 10],
      [10, 11],
      [11, 12], // Middle finger
      [0, 13],
      [13, 14],
      [14, 15],
      [15, 16], // Ring finger
      [0, 17],
      [17, 18],
      [18, 19],
      [19, 20], // Pinky
      [5, 9],
      [9, 13],
      [13, 17], // Palm connections
    ];

    // Draw connections
    this.canvasContext.strokeStyle = color;
    this.canvasContext.lineWidth = 2;
    this.canvasContext.lineCap = "round";

    for (const [start, end] of connections) {
      if (landmarks[start] && landmarks[end]) {
        this.canvasContext.beginPath();
        this.canvasContext.moveTo(
          landmarks[start].x * canvasWidth,
          landmarks[start].y * canvasHeight
        );
        this.canvasContext.lineTo(
          landmarks[end].x * canvasWidth,
          landmarks[end].y * canvasHeight
        );
        this.canvasContext.stroke();
      }
    }

    // Draw landmark points
    this.canvasContext.fillStyle = color;
    for (let i = 0; i < landmarks.length; i++) {
      const landmark = landmarks[i];

      // Highlight thumb tip (4) and index tip (8) when pinching
      if (isPinching && (i === 4 || i === 8)) {
        this.canvasContext.fillStyle = "#ff0000";
        this.canvasContext.beginPath();
        this.canvasContext.arc(
          landmark.x * canvasWidth,
          landmark.y * canvasHeight,
          6,
          0,
          2 * Math.PI
        );
        this.canvasContext.fill();

        // Add pulsing ring for pinch landmarks
        this.canvasContext.strokeStyle = "#ff0000";
        this.canvasContext.lineWidth = 3;
        this.canvasContext.beginPath();
        this.canvasContext.arc(
          landmark.x * canvasWidth,
          landmark.y * canvasHeight,
          8 + Math.sin(performance.now() * 0.01) * 2,
          0,
          2 * Math.PI
        );
        this.canvasContext.stroke();

        this.canvasContext.fillStyle = color;
      } else {
        this.canvasContext.beginPath();
        this.canvasContext.arc(
          landmark.x * canvasWidth,
          landmark.y * canvasHeight,
          3,
          0,
          2 * Math.PI
        );
        this.canvasContext.fill();
      }
    }
  }

  private updateHandTrail(position: THREE.Vector3, currentTime: number): void {
    const config = metaShapesConf.mouseInteraction; // Reuse mouse interaction config

    // Add new trail point with improved timing
    if (currentTime - this.lastTrailUpdate > this.trailUpdateInterval) {
      this.handTrail.push({
        position: position.clone(),
        timestamp: currentTime,
        influence: 1.0,
      });

      this.lastTrailUpdate = currentTime;
    }

    // Remove old trail points
    const trailDuration = config.trailFadeTime * 1000;
    this.handTrail = this.handTrail.filter(
      (point) => currentTime - point.timestamp < trailDuration
    );

    // Update influence based on age with smoother curve
    this.handTrail.forEach((point) => {
      const age = currentTime - point.timestamp;
      const normalizedAge = age / trailDuration;
      // Use smoothstep for more natural fade
      point.influence =
        1 - normalizedAge * normalizedAge * (3 - 2 * normalizedAge);
    });
  }

  public calculateHandEffects(
    basePosition: THREE.Vector3,
    time: number
  ): {
    scaleInfluence: number;
    positionInfluence: number;
    colorInfluence: number;
    rotationInfluence: { x: number; y: number; z: number };
    positionOffset: THREE.Vector3;
  } {
    // Early exit if paused or not properly initialized
    if (
      this.isPaused ||
      !this.isInitialized ||
      !this.isHandDetected ||
      this.handConfidence < metaShapesConf.handTracking.minTrackingConfidence
    ) {
      return {
        scaleInfluence: 0,
        positionInfluence: 0,
        colorInfluence: 0,
        rotationInfluence: { x: 0, y: 0, z: 0 },
        positionOffset: new THREE.Vector3(),
      };
    }

    // Use mouse interaction settings but with dynamic radius based on hand spread
    const mouseConfig = metaShapesConf.mouseInteraction;
    let totalIntensity = 0;
    let scaleInfluence = 0;
    let colorInfluence = 0;
    const rotationInfluence = { x: 0, y: 0, z: 0 };
    const positionOffset = new THREE.Vector3();

    // Calculate dynamic radius based on hand spread
    // Range from 20% to 200% of the configured radius - more reasonable range
    const minRadiusMultiplier = 0.2; // Increase from 0.1 to 0.2
    const maxRadiusMultiplier = 2.0; // Reduce from 3.0 to 2.0
    const radiusMultiplier =
      minRadiusMultiplier +
      this.handSpread * (maxRadiusMultiplier - minRadiusMultiplier);
    const dynamicRadius = mouseConfig.radius * radiusMultiplier;

    // Calculate influence from current hand position
    const distance = basePosition.distanceTo(this.handPosition);

    if (distance < dynamicRadius) {
      const normalizedDistance = distance / dynamicRadius;
      const falloff = Math.pow(
        1 - normalizedDistance,
        mouseConfig.falloffPower
      );
      let intensity = falloff * mouseConfig.intensity;

      // Apply confidence scaling for smoother transitions
      intensity *= Math.min(1, this.handConfidence * 1.5);

      const finalIntensity = intensity;
      const effectType = mouseConfig.effectType;
      const handDirection = basePosition
        .clone()
        .sub(this.handPosition)
        .normalize();

      // Apply the same effects as mouse interaction
      if (effectType === "attraction" || effectType === "combined") {
        positionOffset.add(
          handDirection
            .clone()
            .multiplyScalar(-finalIntensity * mouseConfig.attractionStrength)
        );
      }

      if (effectType === "repulsion" || effectType === "combined") {
        positionOffset.add(
          handDirection
            .clone()
            .multiplyScalar(finalIntensity * mouseConfig.attractionStrength)
        );
      }

      if (effectType === "scale" || effectType === "combined") {
        scaleInfluence += finalIntensity * mouseConfig.scaleMultiplier;
      }

      if (effectType === "colorWave" || effectType === "combined") {
        const waveValue = Math.sin(
          time * mouseConfig.colorWaveSpeed + distance * 0.1
        );
        colorInfluence += finalIntensity * waveValue;
      }

      if (effectType === "rotationInfluence" || effectType === "combined") {
        rotationInfluence.x +=
          finalIntensity * mouseConfig.rotationMultiplier * handDirection.x;
        rotationInfluence.y +=
          finalIntensity * mouseConfig.rotationMultiplier * handDirection.y;
        rotationInfluence.z +=
          finalIntensity * mouseConfig.rotationMultiplier * handDirection.z;
      }

      totalIntensity += finalIntensity;
    }

    // Add trail effects if enabled (same as mouse)
    if (mouseConfig.trailEnabled && this.handTrail.length > 0) {
      this.handTrail.forEach((trailPoint) => {
        const trailDistance = basePosition.distanceTo(trailPoint.position);
        if (trailDistance < dynamicRadius) {
          const normalizedDistance = trailDistance / dynamicRadius;
          const falloff = Math.pow(
            1 - normalizedDistance,
            mouseConfig.falloffPower
          );
          const trailIntensity =
            falloff * mouseConfig.trailInfluenceStrength * trailPoint.influence;

          scaleInfluence += trailIntensity * 0.5;
          colorInfluence += trailIntensity;
        }
      });
    }

    // Add frequency-based effects from individual fingers
    if (!this.performanceMode) {
      // Skip expensive finger calculations in performance mode
      Object.keys(this.fingerPositions).forEach((fingerName) => {
        const finger = fingerName as keyof typeof this.fingerPositions;
        if (this.fingerActive[finger]) {
          const fingerPos = this.fingerPositions[finger];
          const fingerDistance = basePosition.distanceTo(fingerPos);
          const fingerRadius = dynamicRadius * 0.4; // Fingers have smaller radius than overall hand

          if (fingerDistance < fingerRadius) {
            const frequency = this.fingerFrequencies[finger];
            const normalizedDistance = fingerDistance / fingerRadius;
            const falloff = Math.pow(
              1 - normalizedDistance,
              mouseConfig.falloffPower
            );

            // Create frequency-based wave effects
            const waveValue = Math.sin(
              time * frequency * 2 + fingerDistance * frequency * 0.5
            );
            const pulseValue = Math.sin(time * frequency * 4) * 0.5 + 0.5;

            // Each finger adds its own frequency signature
            const fingerIntensity = falloff * mouseConfig.intensity * 0.3; // Reduce individual finger intensity

            // Frequency-based color waves
            colorInfluence += fingerIntensity * waveValue * frequency * 0.2;

            // Frequency-based scale pulsing
            scaleInfluence += fingerIntensity * pulseValue * 0.15;

            // Frequency-based position ripples
            const rippleDirection = basePosition
              .clone()
              .sub(fingerPos)
              .normalize();
            const rippleStrength =
              fingerIntensity *
              Math.sin(time * frequency * 3 + fingerDistance * 0.8) *
              0.1;
            positionOffset.add(rippleDirection.multiplyScalar(rippleStrength));

            // Frequency-based rotation
            rotationInfluence.x +=
              fingerIntensity *
              Math.sin(time * frequency + fingerDistance) *
              0.5;
            rotationInfluence.y +=
              fingerIntensity *
              Math.cos(time * frequency * 1.3 + fingerDistance) *
              0.5;
            rotationInfluence.z +=
              fingerIntensity *
              Math.sin(time * frequency * 0.7 + fingerDistance) *
              0.5;
          }
        }
      });
    }

    return {
      scaleInfluence,
      positionInfluence: totalIntensity,
      colorInfluence,
      rotationInfluence,
      positionOffset,
    };
  }

  public updateSmoothHandPosition(deltaTime: number): void {
    if (this.isHandDetected) {
      // Make hand movement much more responsive, like mouse interaction
      const confidenceMultiplier = Math.min(1, this.handConfidence * 1.5);

      // Much more responsive lerp factor - almost direct movement like mouse
      const lerpFactor = Math.min(
        1,
        deltaTime * 60 * confidenceMultiplier // Increase from 30 to 60 for much faster response
      );

      this.smoothedHandPosition.lerp(this.targetHandPosition, lerpFactor);
      this.handPosition.copy(this.smoothedHandPosition);
    }
  }

  public setResultCallback(
    callback: (
      position: THREE.Vector3,
      gestures: {
        isPinching: boolean;
        isPointing: boolean;
        isFist: boolean;
        isTwisting: boolean;
      }
    ) => void
  ): void {
    this.onHandResults = callback;
  }

  public getHandPosition(): THREE.Vector3 {
    return this.handPosition.clone();
  }

  public getHandTrail(): Array<{
    position: THREE.Vector3;
    timestamp: number;
    influence: number;
  }> {
    return [...this.handTrail];
  }

  public isHandActive(): boolean {
    return (
      this.isHandDetected &&
      this.handConfidence > metaShapesConf.handTracking.minTrackingConfidence
    );
  }

  public getGestures(): {
    isPinching: boolean;
    isPointing: boolean;
    isFist: boolean;
    isTwisting: boolean;
  } {
    return {
      isPinching: this.isPinching,
      isPointing: this.isPointing,
      isFist: this.isFist,
      isTwisting: this.isTwisting,
    };
  }

  public getHandedness(): "Left" | "Right" | null {
    return this.handedness;
  }

  public getHandConfidence(): number {
    return this.handConfidence;
  }

  public getHandSpread(): number {
    return this.handSpread;
  }

  public getDynamicRadius(): number {
    const mouseConfig = metaShapesConf.mouseInteraction;
    const minRadiusMultiplier = 0.2;
    const maxRadiusMultiplier = 2.0;
    const radiusMultiplier =
      minRadiusMultiplier +
      this.handSpread * (maxRadiusMultiplier - minRadiusMultiplier);
    return mouseConfig.radius * radiusMultiplier;
  }

  public getFingerPositions(): typeof this.fingerPositions {
    return { ...this.fingerPositions };
  }

  public getActiveFingers(): typeof this.fingerActive {
    return { ...this.fingerActive };
  }

  public getFingerFrequencies(): typeof this.fingerFrequencies {
    return { ...this.fingerFrequencies };
  }

  public getVideoElement(): HTMLVideoElement | null {
    return this.videoElement;
  }

  public pause(): void {
    this.isPaused = true;

    // Completely stop camera stream to free up resources
    if (this.mediaStream) {
      this.mediaStream.getTracks().forEach((track) => {
        track.stop(); // Stop completely instead of just disabling
      });
      this.mediaStream = null; // Clear reference
    }

    // Remove UI elements completely for better performance
    if (this.videoElement) {
      this.videoElement.remove();
      this.videoElement = null;
    }
    if (this.canvasElement) {
      this.canvasElement.remove();
      this.canvasElement = null;
      this.canvasContext = null;
    }
    const overlay = document.getElementById("gesture-status-overlay");
    if (overlay) {
      overlay.remove();
    }

    // Reset hand tracking state
    this.isHandDetected = false;
    this.handConfidence = 0;
    this.positionFilter.reset();
    this.handSpreadFilter.reset();
    this.handTrail.length = 0;

    // Clear MediaPipe instance to free memory
    if (this.handLandmarker) {
      this.handLandmarker.close();
      this.handLandmarker = null;
    }

    // Cancel animation frame to stop processing completely
    if (this.animationFrameId !== null) {
      cancelAnimationFrame(this.animationFrameId);
      this.animationFrameId = null;
    }

    this.isInitialized = false;
  }

  public async resume(): Promise<void> {
    if (!this.isPaused) return;

    this.isPaused = false;

    // Reinitialize hand tracking completely since pause cleaned everything up
    try {
      await this.init();
    } catch (error) {
      console.error("Failed to resume hand tracking:", error);
      this.isPaused = true; // Set back to paused if initialization fails
    }
  }

  public async setPaused(paused: boolean): Promise<void> {
    if (paused) {
      this.pause();
    } else {
      await this.resume();
    }
  }

  public setPerformanceMode(enabled: boolean): void {
    this.performanceMode = enabled;
    if (enabled) {
      // Increase detection interval for even better performance
      this.detectionInterval = 100; // ~10 FPS
    } else {
      // Reset to default
      this.detectionInterval = 66; // ~15 FPS
    }
  }

  public getPerformanceMode(): boolean {
    return this.performanceMode;
  }

  public setCameraControlsEnabled(enabled: boolean): void {
    if (!enabled && this.controls) {
      this.controls.enableRotate = true; // Re-enable mouse rotation
      this.cameraControlEnabled = false;
    }
  }

  public dispose(): void {
    // Re-enable orbit controls
    if (this.controls) {
      this.controls.enableRotate = true;
    }

    // Cancel animation frame
    if (this.animationFrameId !== null) {
      cancelAnimationFrame(this.animationFrameId);
      this.animationFrameId = null;
    }

    // Stop camera stream
    if (this.mediaStream) {
      this.mediaStream.getTracks().forEach((track) => track.stop());
      this.mediaStream = null;
    }

    // Remove video element
    if (this.videoElement) {
      this.videoElement.remove();
      this.videoElement = null;
    }

    // Remove canvas overlay
    if (this.canvasElement) {
      this.canvasElement.remove();
      this.canvasElement = null;
      this.canvasContext = null;
    }

    // Remove gesture overlay
    const overlay = document.getElementById("gesture-status-overlay");
    if (overlay) {
      overlay.remove();
    }

    // Clean up MediaPipe
    if (this.handLandmarker) {
      this.handLandmarker.close();
      this.handLandmarker = null;
    }

    // Clear trail and filters
    this.handTrail.length = 0;
    this.positionFilter.reset();
    this.handSpreadFilter.reset();
    // this.gestureDebouncer.reset(); // DISABLED - not using gesture detection
    // this.handRotationFilter.reset(); // DISABLED - not using camera controls
  }

  private updateGestureOverlay(): void {
    const overlay = document.getElementById("gesture-status-overlay");
    if (!overlay) return;

    if (this.isPaused) {
      overlay.innerHTML =
        '<div style="color: hsl(var(--muted-foreground));">Hand tracking paused</div>';
      return;
    }

    // Check if any hands are detected
    const anyHandDetected = this.leftHand.detected || this.rightHand.detected;

    if (!anyHandDetected) {
      overlay.innerHTML =
        '<div style="color: hsl(var(--muted-foreground));">No hands detected</div>';
      return;
    }

    // Show dual hand status
    const leftHandStatus = this.leftHand.detected
      ? `<span style="color: #00ff88; font-weight: 500;">LEFT</span> <span style="color: hsl(var(--muted-foreground));">(${Math.round(
          this.leftHand.confidence * 100
        )}%)</span>`
      : '<span style="color: hsl(var(--muted-foreground));">LEFT</span>';

    const rightHandStatus = this.rightHand.detected
      ? `<span style="color: #88ff00; font-weight: 500;">RIGHT</span> <span style="color: hsl(var(--muted-foreground));">(${Math.round(
          this.rightHand.confidence * 100
        )}%)</span>`
      : '<span style="color: hsl(var(--muted-foreground));">RIGHT</span>';

    // Determine which hand is doing what
    const cameraHand =
      this.cameraControlHand === "left" ? this.leftHand : this.rightHand;
    const effectsHand =
      this.effectsHand === "left" ? this.leftHand : this.rightHand;

    const cameraHandName = this.cameraControlHand.toUpperCase();
    const effectsHandName = this.effectsHand.toUpperCase();

    // Show active fingers for effects hand only
    const activeFingers: string[] = [];
    if (effectsHand.detected) {
      Object.keys(this.fingerActive).forEach((fingerName) => {
        const finger = fingerName as keyof typeof this.fingerActive;
        if (this.fingerActive[finger]) {
          const freq = this.fingerFrequencies[finger];
          const color = this.fingerColors[finger];
          activeFingers.push(
            `<span style="color: ${color}; font-weight: 500;">${fingerName.toUpperCase()}</span> <span style="color: hsl(var(--muted-foreground)); font-size: 10px;">(${freq}Hz)</span>`
          );
        }
      });
    }

    const baseRadius = metaShapesConf.mouseInteraction.radius;
    const currentRadius = effectsHand.detected
      ? baseRadius * (0.2 + effectsHand.handSpread * 1.8)
      : baseRadius;

    overlay.innerHTML = `
      <div style="color: hsl(var(--foreground)); font-weight: 600; margin-bottom: 6px;">
        ${leftHandStatus} • ${rightHandStatus}
      </div>
      <div style="color: hsl(var(--muted-foreground)); font-size: 11px; margin-bottom: 6px; line-height: 1.3;">
        🎥 Camera: <span style="color: ${
          cameraHand.detected ? "#00ff88" : "hsl(var(--muted-foreground))"
        };">${cameraHandName}</span>
        ${
          cameraHand.isPinching
            ? ' <span style="color: #ff0000; font-weight: 600;">📌 PINCHING</span>'
            : ""
        }
        <br>
        🎵 Effects: <span style="color: ${
          effectsHand.detected ? "#88ff00" : "hsl(var(--muted-foreground))"
        };">${effectsHandName}</span>
      </div>
      ${
        this.cameraControlEnabled
          ? '<div style="color: #ff6600; font-weight: 500; margin-bottom: 6px; font-size: 11px;">🎥 Camera Rotation Active</div>'
          : ""
      }
      <div style="color: hsl(var(--muted-foreground)); font-size: 10px; margin-bottom: 4px;">
        Spread: <span style="color: hsl(var(--foreground)); font-weight: 500;">${Math.round(
          (effectsHand.handSpread || 0) * 100
        )}%</span> | 
        Radius: <span style="color: hsl(var(--foreground)); font-weight: 500;">${currentRadius.toFixed(
          1
        )}</span> |
        FPS: <span style="color: hsl(var(--foreground)); font-weight: 500;">${
          this.actualFPS
        }</span>
      </div>
      ${
        effectsHand.detected
          ? `
        <div style="font-size: 10px; margin-bottom: 4px; line-height: 1.3;">
          ${
            activeFingers.length > 0
              ? activeFingers.join(" • ")
              : '<span style="color: hsl(var(--muted-foreground));">No fingers extended</span>'
          }
        </div>
      `
          : ""
      }
      <div style="color: hsl(var(--muted-foreground)); font-size: 9px; line-height: 1.2;">
        ${
          cameraHand.isPinching
            ? "Pinch camera hand to rotate view"
            : effectsHand.detected
            ? "Extend fingers on effects hand for frequencies"
            : "Show both hands for full control"
        }
      </div>
    `;
  }

  private calculateFingerPositions(
    landmarks: Array<{ x: number; y: number; z: number }>
  ): void {
    // Finger tip landmark indices: thumb=4, index=8, middle=12, ring=16, pinky=20
    // Finger MCP (base) landmarks: thumb=2, index=5, middle=9, ring=13, pinky=17

    const fingerTips = {
      thumb: landmarks[4],
      index: landmarks[8],
      middle: landmarks[12],
      ring: landmarks[16],
      pinky: landmarks[20],
    };

    const fingerMCPs = {
      thumb: landmarks[2],
      index: landmarks[5],
      middle: landmarks[9],
      ring: landmarks[13],
      pinky: landmarks[17],
    };

    // Calculate 3D positions for each finger tip
    Object.keys(fingerTips).forEach((fingerName) => {
      const tip = fingerTips[fingerName as keyof typeof fingerTips];
      const x = tip.x * 2 - 1;
      const y = -(tip.y * 2 - 1);

      // Calculate 3D position similar to main hand position
      this.calculateFingerPositionInCube(
        x,
        y,
        tip.z,
        fingerName as keyof typeof this.fingerPositions
      );
    });

    // Determine which fingers are "active" (extended)
    Object.keys(fingerTips).forEach((fingerName) => {
      const tip = fingerTips[fingerName as keyof typeof fingerTips];
      const mcp = fingerMCPs[fingerName as keyof typeof fingerMCPs];

      // Calculate if finger is extended (tip is higher than base for most fingers)
      // Thumb has different logic since it moves sideways
      let isExtended = false;
      if (fingerName === "thumb") {
        // For thumb, check if it's extended outward (distance from wrist)
        const wrist = landmarks[0];
        const thumbDistance = Math.sqrt(
          Math.pow(tip.x - wrist.x, 2) +
            Math.pow(tip.y - wrist.y, 2) +
            Math.pow(tip.z - wrist.z, 2)
        );
        isExtended = thumbDistance > 0.1; // Threshold for thumb extension
      } else {
        // For other fingers, check if tip is above MCP joint
        isExtended = tip.y < mcp.y - 0.02; // Negative because Y is flipped
      }

      this.fingerActive[fingerName as keyof typeof this.fingerActive] =
        isExtended;
    });
  }

  private calculateFingerPositionInCube(
    x: number,
    y: number,
    z: number,
    fingerName: keyof typeof this.fingerPositions
  ): void {
    // Set up raycaster from finger position
    const mouse = new THREE.Vector2(x, y);
    this.camera.updateMatrixWorld(true);
    this.raycaster.setFromCamera(mouse, this.camera);

    const countPerSide = metaShapesConf.instanceMesh.countPerSide;
    const spacing = metaShapesConf.instanceMesh.spacing;

    // Create bounding box for the cube grid
    const gridExtent = (countPerSide - 1) * spacing * 0.5;
    const boxMin = new THREE.Vector3(-gridExtent, -gridExtent, -gridExtent);
    const boxMax = new THREE.Vector3(gridExtent, gridExtent, gridExtent);
    const box = new THREE.Box3(boxMin, boxMax);

    // Try to intersect the ray with the bounding box
    const intersectPoint = new THREE.Vector3();
    const hasIntersection = this.raycaster.ray.intersectBox(
      box,
      intersectPoint
    );

    if (hasIntersection) {
      // Use depth information from MediaPipe to adjust Z position
      const depthScale = metaShapesConf.handTracking.depthSensitivity;
      const adjustedZ = intersectPoint.z + (z - 0.5) * depthScale * 0.5;

      this.fingerPositions[fingerName as keyof typeof this.fingerPositions].set(
        intersectPoint.x,
        intersectPoint.y,
        Math.max(boxMin.z, Math.min(boxMax.z, adjustedZ))
      );
    } else {
      // Fallback positioning
      const fallbackDistance = gridExtent * 0.8;
      const rayDirection = this.raycaster.ray.direction.clone().normalize();
      const fallbackPoint = this.raycaster.ray.origin
        .clone()
        .add(rayDirection.multiplyScalar(fallbackDistance));

      this.fingerPositions[
        fingerName as keyof typeof this.fingerPositions
      ].copy(fallbackPoint);
      this.fingerPositions[
        fingerName as keyof typeof this.fingerPositions
      ].clamp(boxMin, boxMax);
    }
  }

  private startCameraControl(
    landmarks: Array<{ x: number; y: number; z: number }>
  ): void {
    if (!this.controls) return;

    console.log("Starting pinch camera control");
    this.cameraControlEnabled = true;

    // Store initial pinch position (midpoint between thumb and index)
    const thumbTip = landmarks[4];
    const indexTip = landmarks[8];

    this.pinchStartPosition.set(
      (thumbTip.x + indexTip.x) / 2,
      (thumbTip.y + indexTip.y) / 2
    );
    this.lastPinchPosition.copy(this.pinchStartPosition);

    // Don't disable orbit controls completely, we'll work with them
    this.controls.enableRotate = true;
  }

  private endCameraControl(): void {
    if (!this.controls) return;

    console.log("Ending pinch camera control");
    this.cameraControlEnabled = false;

    // Re-enable normal orbit controls
    this.controls.enableRotate = true;
  }

  private updateCameraRotation(
    landmarks: Array<{ x: number; y: number; z: number }>
  ): void {
    if (!this.controls || !this.cameraControlEnabled) return;

    // Calculate current pinch position (midpoint between thumb and index)
    const thumbTip = landmarks[4];
    const indexTip = landmarks[8];

    const currentPinchPosition = new THREE.Vector2(
      (thumbTip.x + indexTip.x) / 2,
      (thumbTip.y + indexTip.y) / 2
    );

    // Calculate movement delta
    const deltaX = (currentPinchPosition.x - this.lastPinchPosition.x) * 4; // Sensitivity multiplier
    const deltaY = (currentPinchPosition.y - this.lastPinchPosition.y) * 4;

    // Apply rotation using spherical coordinates (similar to orbit controls)
    const spherical = new THREE.Spherical();
    spherical.setFromVector3(
      this.camera.position.clone().sub(this.controls.target)
    );

    // Update spherical coordinates based on hand movement
    spherical.theta -= deltaX * Math.PI; // Horizontal rotation
    spherical.phi += deltaY * Math.PI; // Vertical rotation

    // Clamp vertical rotation to prevent flipping
    spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));

    // Apply the new position
    const newPosition = new THREE.Vector3();
    newPosition.setFromSpherical(spherical).add(this.controls.target);
    this.camera.position.copy(newPosition);
    this.camera.lookAt(this.controls.target);

    // Update controls
    this.controls.update();

    // Store current position for next frame
    this.lastPinchPosition.copy(currentPinchPosition);
  }
}



================================================
FILE: src/vanilla-three/experiences/meta-shapes/managers/MouseInteractionManager.ts
================================================
import * as THREE from "three";
import { ImprovedNoise } from "three/examples/jsm/math/ImprovedNoise.js";
import { metaShapesConf } from "../constants";

export class MouseInteractionManager {
  private mouse = new THREE.Vector2();
  private mouseWorldPosition = new THREE.Vector3();
  private smoothedMousePosition = new THREE.Vector3();
  private targetMousePosition = new THREE.Vector3();
  private raycaster = new THREE.Raycaster();
  private handleMouseMove!: (event: MouseEvent) => void;

  // Trail tracking
  private mouseTrail: Array<{
    position: THREE.Vector3;
    timestamp: number;
    influence: number;
  }> = [];
  private lastTrailUpdate = 0;

  private camera: THREE.PerspectiveCamera;
  private canvas: HTMLCanvasElement;
  private noise: ImprovedNoise;

  constructor(
    camera: THREE.PerspectiveCamera,
    canvas: HTMLCanvasElement,
    noise: ImprovedNoise
  ) {
    this.camera = camera;
    this.canvas = canvas;
    this.noise = noise;

    // Initialize mouse positions
    this.smoothedMousePosition.set(0, 0, 0);
    this.targetMousePosition.set(0, 0, 0);
    this.mouseWorldPosition.set(0, 0, 0);
  }

  public setupMouseInteraction(): void {
    this.handleMouseMove = (event: MouseEvent) => {
      // Convert mouse coordinates to normalized device coordinates (-1 to +1)
      const rect = this.canvas.getBoundingClientRect();
      this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

      // Ensure camera matrix is up to date before raycasting
      this.camera.updateMatrixWorld(true);

      // Update raycaster with current camera state
      this.raycaster.setFromCamera(this.mouse, this.camera);

      // Calculate the 3D mouse position using cube bounds intersection
      const intersectPoint = this.calculateMousePositionInCube();

      if (intersectPoint) {
        // Set target position for smooth interpolation
        this.targetMousePosition.copy(intersectPoint);
      }
    };

    this.canvas.addEventListener("mousemove", this.handleMouseMove);
  }

  private calculateMousePositionInCube(): THREE.Vector3 | null {
    const countPerSide = metaShapesConf.instanceMesh.countPerSide;
    const spacing = metaShapesConf.instanceMesh.spacing;

    // Create a bounding box that encompasses the entire cube grid
    // Use consistent spacing calculation
    const gridExtent = (countPerSide - 1) * spacing * 0.5;
    const boxMin = new THREE.Vector3(-gridExtent, -gridExtent, -gridExtent);
    const boxMax = new THREE.Vector3(gridExtent, gridExtent, gridExtent);
    const box = new THREE.Box3(boxMin, boxMax);

    // Try to intersect the ray with the bounding box
    const intersectPoint = new THREE.Vector3();
    const hasIntersection = this.raycaster.ray.intersectBox(
      box,
      intersectPoint
    );

    if (hasIntersection) {
      // Ensure the intersection point is within bounds (safety check)
      intersectPoint.clamp(boxMin, boxMax);
      return intersectPoint;
    }

    // Enhanced fallback for when camera is rotated or ray doesn't intersect
    const rayDirection = this.raycaster.ray.direction.clone().normalize();
    const rayOrigin = this.raycaster.ray.origin.clone();

    // Method 1: Try intersecting with individual faces of the cube
    const faces = [
      {
        normal: new THREE.Vector3(1, 0, 0),
        point: new THREE.Vector3(gridExtent, 0, 0),
      }, // Right face
      {
        normal: new THREE.Vector3(-1, 0, 0),
        point: new THREE.Vector3(-gridExtent, 0, 0),
      }, // Left face
      {
        normal: new THREE.Vector3(0, 1, 0),
        point: new THREE.Vector3(0, gridExtent, 0),
      }, // Top face
      {
        normal: new THREE.Vector3(0, -1, 0),
        point: new THREE.Vector3(0, -gridExtent, 0),
      }, // Bottom face
      {
        normal: new THREE.Vector3(0, 0, 1),
        point: new THREE.Vector3(0, 0, gridExtent),
      }, // Front face
      {
        normal: new THREE.Vector3(0, 0, -1),
        point: new THREE.Vector3(0, 0, -gridExtent),
      }, // Back face
    ];

    let closestIntersection: THREE.Vector3 | null = null;
    let closestDistance = Infinity;

    for (const face of faces) {
      const plane = new THREE.Plane(face.normal, -face.point.dot(face.normal));
      const intersection = new THREE.Vector3();

      if (this.raycaster.ray.intersectPlane(plane, intersection)) {
        // Check if intersection is within the cube bounds
        if (
          intersection.x >= boxMin.x &&
          intersection.x <= boxMax.x &&
          intersection.y >= boxMin.y &&
          intersection.y <= boxMax.y &&
          intersection.z >= boxMin.z &&
          intersection.z <= boxMax.z
        ) {
          const distance = rayOrigin.distanceTo(intersection);
          if (distance < closestDistance) {
            closestDistance = distance;
            closestIntersection = intersection.clone();
          }
        }
      }
    }

    if (closestIntersection) {
      return closestIntersection;
    }

    // Method 2: Project to closest point on cube surface
    const cubeCenter = new THREE.Vector3(0, 0, 0);
    const toCube = cubeCenter.clone().sub(rayOrigin);
    const projectionLength = Math.max(0, toCube.dot(rayDirection));

    const projectedPoint = rayOrigin
      .clone()
      .add(rayDirection.multiplyScalar(projectionLength));

    // Find the closest point on the cube surface
    const clampedPoint = projectedPoint.clone();
    clampedPoint.clamp(boxMin, boxMax);

    return clampedPoint;
  }

  public calculateMouseEffects(
    basePosition: THREE.Vector3,
    time: number
  ): {
    scaleInfluence: number;
    positionInfluence: number;
    colorInfluence: number;
    rotationInfluence: { x: number; y: number; z: number };
    positionOffset: THREE.Vector3;
  } {
    const config = metaShapesConf.mouseInteraction;

    // Initialize results
    let totalIntensity = 0;
    let scaleInfluence = 0;
    const positionInfluence = 0;
    let colorInfluence = 0;
    let rotationInfluence = { x: 0, y: 0, z: 0 };
    const positionOffset = new THREE.Vector3();

    // Calculate influence from current mouse position
    const currentInfluence = this.calculateOrganicInfluence(
      basePosition,
      this.mouseWorldPosition,
      time
    );
    totalIntensity += currentInfluence;

    // Calculate influence from trail if enabled
    if (config.trailEnabled && this.mouseTrail.length > 0) {
      const currentTime = Date.now();
      const trailDuration = config.trailFadeTime * 1000;

      for (const trailPoint of this.mouseTrail) {
        const age = currentTime - trailPoint.timestamp;
        const ageFactor = Math.max(0, 1 - age / trailDuration); // Linear fade
        const smoothFade = ageFactor * ageFactor; // Smooth fade curve

        const trailInfluence = this.calculateOrganicInfluence(
          basePosition,
          trailPoint.position,
          time
        );

        totalIntensity +=
          trailInfluence * smoothFade * config.trailInfluenceStrength;
      }
    }

    // Apply effects if there's meaningful influence
    if (totalIntensity > 0.01) {
      // Use the current mouse position as primary direction for directional effects
      const mouseDirection = new THREE.Vector3()
        .subVectors(basePosition, this.mouseWorldPosition)
        .normalize();

      // Add organic curl-based offset to the direction
      const curlOffset = this.calculateCurlNoise(basePosition, time);
      curlOffset.multiplyScalar(config.curlNoiseStrength * 0.3);
      mouseDirection.add(curlOffset).normalize();

      switch (config.effectType) {
        case "attraction":
          this.applyAttractionEffect(
            mouseDirection,
            totalIntensity,
            config,
            positionOffset
          );
          break;

        case "repulsion":
          this.applyRepulsionEffect(
            mouseDirection,
            totalIntensity,
            config,
            positionOffset
          );
          break;

        case "scale":
          scaleInfluence = this.applyScaleEffect(totalIntensity, config);
          break;

        case "colorWave":
          colorInfluence = this.applyColorWaveEffect(
            basePosition.distanceTo(this.mouseWorldPosition),
            time,
            config
          );
          // Add trail color influences
          if (config.trailEnabled) {
            for (const trailPoint of this.mouseTrail) {
              const age = Date.now() - trailPoint.timestamp;
              const ageFactor = Math.max(
                0,
                1 - age / (config.trailFadeTime * 1000)
              );
              const trailColorInfluence = this.applyColorWaveEffect(
                basePosition.distanceTo(trailPoint.position),
                time,
                config
              );
              colorInfluence +=
                trailColorInfluence * ageFactor * config.trailInfluenceStrength;
            }
          }
          break;

        case "rotationInfluence":
          rotationInfluence = this.applyRotationInfluenceEffect(
            mouseDirection,
            totalIntensity,
            config
          );
          break;

        case "heightWave":
          positionOffset.y = this.applyHeightWaveEffect(
            basePosition.distanceTo(this.mouseWorldPosition),
            time,
            config
          );
          break;

        case "combined": {
          // Apply multiple effects with organic blending
          const combinedIntensity = totalIntensity * 0.6;

          // Gentle attraction with curl noise
          this.applyAttractionEffect(
            mouseDirection,
            combinedIntensity * 0.3,
            config,
            positionOffset
          );

          // Scale effect
          scaleInfluence =
            this.applyScaleEffect(combinedIntensity, config) * 0.5;

          // Color wave with trail
          colorInfluence =
            this.applyColorWaveEffect(
              basePosition.distanceTo(this.mouseWorldPosition),
              time,
              config
            ) * 0.8;

          // Add trail color influences
          if (config.trailEnabled) {
            for (const trailPoint of this.mouseTrail) {
              const age = Date.now() - trailPoint.timestamp;
              const ageFactor = Math.max(
                0,
                1 - age / (config.trailFadeTime * 1000)
              );
              const trailColorInfluence = this.applyColorWaveEffect(
                basePosition.distanceTo(trailPoint.position),
                time,
                config
              );
              colorInfluence +=
                trailColorInfluence *
                ageFactor *
                config.trailInfluenceStrength *
                0.4;
            }
          }

          // Rotation influence with organic variation
          const rotInfluence = this.applyRotationInfluenceEffect(
            mouseDirection,
            combinedIntensity * 0.4,
            config
          );
          rotationInfluence.x = rotInfluence.x * 0.3;
          rotationInfluence.y = rotInfluence.y * 0.3;
          rotationInfluence.z = rotInfluence.z * 0.3;

          // Height wave with organic variations
          positionOffset.y +=
            this.applyHeightWaveEffect(
              basePosition.distanceTo(this.mouseWorldPosition),
              time,
              config
            ) * 0.4;

          // Add organic curl displacement
          const organicDisplacement = this.calculateCurlNoise(
            basePosition,
            time
          );
          organicDisplacement.multiplyScalar(combinedIntensity * 0.1);
          positionOffset.add(organicDisplacement);
          break;
        }
      }
    }

    return {
      scaleInfluence,
      positionInfluence,
      colorInfluence,
      rotationInfluence,
      positionOffset,
    };
  }

  private applyAttractionEffect(
    mouseDirection: THREE.Vector3,
    intensity: number,
    config: typeof metaShapesConf.mouseInteraction,
    positionOffset: THREE.Vector3
  ): void {
    const attractionForce = mouseDirection
      .clone()
      .multiplyScalar(-config.attractionStrength * intensity);
    positionOffset.add(attractionForce);
  }

  private applyRepulsionEffect(
    mouseDirection: THREE.Vector3,
    intensity: number,
    config: typeof metaShapesConf.mouseInteraction,
    positionOffset: THREE.Vector3
  ): void {
    const repulsionForce = mouseDirection
      .clone()
      .multiplyScalar(config.attractionStrength * intensity);
    positionOffset.add(repulsionForce);
  }

  private applyScaleEffect(
    intensity: number,
    config: typeof metaShapesConf.mouseInteraction
  ): number {
    return intensity * config.scaleMultiplier;
  }

  private applyColorWaveEffect(
    distance: number,
    time: number,
    config: typeof metaShapesConf.mouseInteraction
  ): number {
    const wavePhase = distance * 0.5 - time * config.colorWaveSpeed;
    return Math.sin(wavePhase) * 0.5 + 0.5; // Normalize to 0-1
  }

  private applyRotationInfluenceEffect(
    mouseDirection: THREE.Vector3,
    intensity: number,
    config: typeof metaShapesConf.mouseInteraction
  ): { x: number; y: number; z: number } {
    const rotationSpeed = config.rotationMultiplier * intensity;
    return {
      x: mouseDirection.y * rotationSpeed,
      y: mouseDirection.x * rotationSpeed,
      z: (mouseDirection.x + mouseDirection.y) * rotationSpeed * 0.5,
    };
  }

  private applyHeightWaveEffect(
    distance: number,
    time: number,
    config: typeof metaShapesConf.mouseInteraction
  ): number {
    const wavePhase = distance * 0.3 - time * 2;
    return Math.sin(wavePhase) * config.heightWaveAmplitude;
  }

  private updateMouseTrail(intersectPoint: THREE.Vector3): void {
    const currentTime = Date.now();
    const config = metaShapesConf.mouseInteraction;
    const trailDuration = config.trailFadeTime * 1000; // Convert to milliseconds

    // Remove old trail points
    this.mouseTrail = this.mouseTrail.filter(
      (point) => currentTime - point.timestamp < trailDuration
    );

    // Add new trail point if enough time has passed (avoid too many points)
    const timeSinceLastUpdate = currentTime - this.lastTrailUpdate;
    if (timeSinceLastUpdate > 50) {
      // Update every 50ms max
      this.mouseTrail.push({
        position: intersectPoint.clone(),
        timestamp: currentTime,
        influence: 1.0,
      });
      this.lastTrailUpdate = currentTime;

      // Limit trail length
      if (this.mouseTrail.length > config.trailLength) {
        this.mouseTrail.shift();
      }
    }
  }

  private calculateCurlNoise(
    position: THREE.Vector3,
    time: number
  ): THREE.Vector3 {
    const scale = metaShapesConf.mouseInteraction.curlNoiseScale;
    const eps = 0.05; // Reduced offset for smoother derivatives

    // Use slower time progression for smoother animation
    const smoothTime = time * 0.3;

    // Sample noise at different positions to calculate curl
    const px = this.noise.noise(
      position.x * scale,
      position.y * scale,
      smoothTime
    );

    // Calculate partial derivatives for curl with reduced sensitivity
    const dx =
      (this.noise.noise(
        (position.x + eps) * scale,
        position.y * scale,
        smoothTime
      ) -
        px) *
      0.5;
    const dy =
      (this.noise.noise(
        position.x * scale,
        (position.y + eps) * scale,
        smoothTime
      ) -
        px) *
      0.5;
    const dz =
      (this.noise.noise(position.x * scale, position.y * scale, smoothTime) -
        px) *
      0.5;

    return new THREE.Vector3(dy - dz, dz - dx, dx - dy);
  }

  private calculateDynamicRadius(
    basePosition: THREE.Vector3,
    time: number
  ): number {
    const config = metaShapesConf.mouseInteraction;
    const baseRadius = config.radius;

    // Use slower time progression for smoother variations
    const smoothTime = time * 0.2;

    // Add noise variation with reduced intensity
    const noiseValue = this.noise.noise(
      basePosition.x * config.radiusNoiseScale,
      basePosition.y * config.radiusNoiseScale,
      smoothTime
    );
    const noiseVariation = noiseValue * config.radiusNoiseAmplitude * 0.5; // Reduce intensity

    // Add sine wave variation with smoother frequency
    const sinVariation =
      Math.sin(smoothTime * config.radiusSinFrequency) *
      config.radiusSinAmplitude *
      0.5;

    return Math.max(0.5, baseRadius + noiseVariation + sinVariation);
  }

  private calculateOrganicInfluence(
    basePosition: THREE.Vector3,
    influencePoint: THREE.Vector3,
    time: number
  ): number {
    const config = metaShapesConf.mouseInteraction;

    // Calculate dynamic radius for this influence point
    const dynamicRadius = this.calculateDynamicRadius(basePosition, time);

    // Base distance
    const distance = basePosition.distanceTo(influencePoint);

    // Apply curl noise to create organic influence boundaries (reduced influence)
    const curlOffset = this.calculateCurlNoise(basePosition, time);
    curlOffset.multiplyScalar(config.curlNoiseStrength * 0.3); // Reduced multiplier

    // Modify the effective distance with curl noise (clamped to prevent extreme values)
    const curlInfluence = Math.max(
      -dynamicRadius * 0.3,
      Math.min(dynamicRadius * 0.3, curlOffset.length())
    );
    const organicDistance = Math.max(0, distance + curlInfluence);

    // Calculate falloff
    const normalizedDistance = Math.min(organicDistance / dynamicRadius, 1.0);
    const easeOutQuart = (x: number) => 1 - Math.pow(1 - x, 4);
    const naturalIntensity = easeOutQuart(1.0 - normalizedDistance);

    return naturalIntensity * config.intensity;
  }

  public updateSmoothMousePosition(deltaTime: number): void {
    const config = metaShapesConf.mouseInteraction;

    // If smoothing is very low, use direct position to prevent drift
    if (config.smoothingFactor < 0.1) {
      this.smoothedMousePosition.copy(this.targetMousePosition);
      this.mouseWorldPosition.copy(this.smoothedMousePosition);
    } else {
      // Use smoothing factor to interpolate between current and target position
      const smoothingSpeed = Math.max(0.01, 1 - config.smoothingFactor) * 8; // Reduced multiplier for better control
      const lerpFactor = Math.min(1, smoothingSpeed * deltaTime);

      // Smoothly interpolate to target position
      this.smoothedMousePosition.lerp(this.targetMousePosition, lerpFactor);

      // Update the main mouse position with smoothed version
      this.mouseWorldPosition.copy(this.smoothedMousePosition);
    }

    // Update trail with the actual mouse world position
    if (config.trailEnabled) {
      this.updateMouseTrail(this.mouseWorldPosition);
    }
  }

  public dispose(): void {
    // Remove mouse listener
    if (this.handleMouseMove) {
      this.canvas.removeEventListener("mousemove", this.handleMouseMove);
    }

    // Clear mouse trail
    this.mouseTrail.length = 0;
  }

  // Getters for accessing mouse data if needed
  public getMouseWorldPosition(): THREE.Vector3 {
    return this.mouseWorldPosition;
  }

  public getSmoothedMousePosition(): THREE.Vector3 {
    return this.smoothedMousePosition;
  }

  public getMouseTrail(): Array<{
    position: THREE.Vector3;
    timestamp: number;
    influence: number;
  }> {
    return this.mouseTrail;
  }
}



================================================
FILE: src/vanilla-three/experiences/meta-shapes/managers/PostProcessingManager.ts
================================================
import * as THREE from "three";
import { EffectComposer } from "three/examples/jsm/postprocessing/EffectComposer.js";
import { RenderPass } from "three/examples/jsm/postprocessing/RenderPass.js";
import { UnrealBloomPass } from "three/examples/jsm/postprocessing/UnrealBloomPass.js";
import { ShaderPass } from "three/examples/jsm/postprocessing/ShaderPass.js";
import { FilmPass } from "three/examples/jsm/postprocessing/FilmPass.js";
import { AfterimagePass } from "three/examples/jsm/postprocessing/AfterimagePass.js";
import { OutputPass } from "three/examples/jsm/postprocessing/OutputPass.js";
import { MirrorShader } from "@/vanilla-three/shaders";
import { metaShapesConf } from "../constants";

// Define a more robust chromatic aberration shader
const ChromaticAberrationShader = {
  uniforms: {
    tDiffuse: { value: null },
    amount: { value: 0.005 },
  },
  vertexShader: `
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform sampler2D tDiffuse;
    uniform float amount;
    varying vec2 vUv;
    
    void main() {
      vec2 offset = amount * (vUv - 0.5);
      
      float r = texture2D(tDiffuse, vUv + offset).r;
      float g = texture2D(tDiffuse, vUv).g;
      float b = texture2D(tDiffuse, vUv - offset).b;
      
      gl_FragColor = vec4(r, g, b, 1.0);
    }
  `,
};

export class PostProcessingManager {
  private composer!: EffectComposer;
  private renderPass!: RenderPass;
  private bloomPass!: UnrealBloomPass;
  private chromaticAberrationPass!: ShaderPass;
  private filmPass!: FilmPass;
  private afterimagePass!: AfterimagePass;
  private outputPass!: OutputPass;
  private mirrorPass!: ShaderPass;

  private renderer: THREE.WebGLRenderer;
  private scene: THREE.Scene;
  private camera: THREE.PerspectiveCamera;
  private canvas: HTMLCanvasElement;

  constructor(
    renderer: THREE.WebGLRenderer,
    scene: THREE.Scene,
    camera: THREE.PerspectiveCamera,
    canvas: HTMLCanvasElement
  ) {
    this.renderer = renderer;
    this.scene = scene;
    this.camera = camera;
    this.canvas = canvas;
  }

  public init(): void {
    this.initPostProcessing();
  }

  private initPostProcessing(): void {
    // Create effect composer
    this.composer = new EffectComposer(this.renderer);

    // Render pass - renders the scene
    this.renderPass = new RenderPass(this.scene, this.camera);
    this.composer.addPass(this.renderPass);

    // Bloom pass
    const bloomConfig = metaShapesConf.postProcessing.bloom;
    this.bloomPass = new UnrealBloomPass(
      new THREE.Vector2(this.canvas.clientWidth, this.canvas.clientHeight),
      bloomConfig.strength,
      bloomConfig.radius,
      bloomConfig.threshold
    );
    this.composer.addPass(this.bloomPass);

    // Chromatic aberration pass
    this.chromaticAberrationPass = new ShaderPass(ChromaticAberrationShader);
    this.chromaticAberrationPass.uniforms.amount.value =
      metaShapesConf.postProcessing.chromaticAberration.strength * 0.005;
    this.composer.addPass(this.chromaticAberrationPass);

    // Mirror pass
    this.mirrorPass = new ShaderPass(MirrorShader);
    this.mirrorPass.uniforms.uResolution.value.set(
      this.canvas.clientWidth,
      this.canvas.clientHeight
    );
    this.composer.addPass(this.mirrorPass);

    // Film grain pass
    this.filmPass = new FilmPass(
      metaShapesConf.postProcessing.filmGrain.intensity
    );
    this.composer.addPass(this.filmPass);

    // Afterimage pass
    this.afterimagePass = new AfterimagePass();
    this.composer.addPass(this.afterimagePass);

    // Output pass (always last)
    this.outputPass = new OutputPass();
    this.composer.addPass(this.outputPass);

    // Set initial enabled states
    this.updatePostProcessing();
  }

  public updatePostProcessing(): void {
    if (!this.composer) return;

    const config = metaShapesConf.postProcessing;

    // Update bloom
    if (this.bloomPass) {
      this.bloomPass.enabled = config.enabled && config.bloom.enabled;
      this.bloomPass.strength = config.bloom.strength;
      this.bloomPass.radius = config.bloom.radius;
      this.bloomPass.threshold = config.bloom.threshold;
    }

    // Update chromatic aberration
    if (this.chromaticAberrationPass) {
      this.chromaticAberrationPass.enabled =
        config.enabled && config.chromaticAberration.enabled;
      this.chromaticAberrationPass.uniforms.amount.value =
        config.chromaticAberration.strength * 0.005;
    }

    // Update mirror
    if (this.mirrorPass) {
      this.mirrorPass.enabled = config.enabled && config.mirror.enabled;

      // Map mirror type to number
      const typeMap = {
        horizontal: 0,
        vertical: 1,
        kaleidoscope: 2,
        radial: 3,
        diagonal: 4,
        quadrant: 5,
        center: 6,
      };

      this.mirrorPass.uniforms.uMirrorType.value =
        typeMap[config.mirror.type] || 0;
      this.mirrorPass.uniforms.uIntensity.value = config.mirror.intensity;
      this.mirrorPass.uniforms.uSegments.value = config.mirror.segments || 6;
      this.mirrorPass.uniforms.uOffset.value = config.mirror.offset || 0.5;
    }

    // Update film grain
    if (this.filmPass) {
      this.filmPass.enabled = config.enabled && config.filmGrain.enabled;
      (this.filmPass as any).uniforms.intensity.value =
        config.filmGrain.intensity;
    }

    // Update afterimage
    if (this.afterimagePass) {
      this.afterimagePass.enabled = config.enabled && config.afterimage.enabled;
      this.afterimagePass.uniforms.damp.value = config.afterimage.damp;
    }
  }

  public render(): void {
    if (metaShapesConf.postProcessing.enabled && this.composer) {
      this.composer.render();
    } else {
      this.renderer.render(this.scene, this.camera);
    }
  }

  public setSize(width: number, height: number): void {
    if (this.composer) {
      this.composer.setSize(width, height);
    }

    // Update mirror resolution
    if (this.mirrorPass) {
      this.mirrorPass.uniforms.uResolution.value.set(width, height);
    }
  }

  public dispose(): void {
    if (this.composer) {
      this.composer.dispose();
    }
  }

  // Getters for accessing passes if needed
  public getComposer(): EffectComposer {
    return this.composer;
  }

  public getBloomPass(): UnrealBloomPass {
    return this.bloomPass;
  }

  public getChromaticAberrationPass(): ShaderPass {
    return this.chromaticAberrationPass;
  }

  public getMirrorPass(): ShaderPass {
    return this.mirrorPass;
  }

  public getFilmPass(): FilmPass {
    return this.filmPass;
  }

  public getAfterimagePass(): AfterimagePass {
    return this.afterimagePass;
  }
}



================================================
FILE: src/vanilla-three/experiences/particles/constants.ts
================================================
import * as THREE from "three/webgpu";

// Reusable type definitions
export interface CameraConfig {
  position: readonly [number, number, number];
  target: readonly [number, number, number];
  fov: number;
}

export interface LightConfig {
  position: readonly [number, number, number];
  target: readonly [number, number, number];
  intensity: number;
  angle: number;
  penumbra: number;
}

export interface WorldConfig {
  size: number;
  rendererOffset: number;
}

export interface ParticleSettings {
  maxParticles: number;
  particles: number;
  actualSize: number;
  size: number;
  points: boolean;
}

export interface SimulationSettings {
  noise: number;
  speed: number;
  stiffness: number;
  restDensity: number;
  density: number;
  dynamicViscosity: number;
  gravity: number;
  gravitySensorReading: THREE.Vector3;
  accelerometerReading: THREE.Vector3;
}

export interface RenderSettings {
  bloom: boolean;
  gui: null;
  run: boolean;
}

// Main config with clear nested structure
export interface ExperienceConfig {
  particles: ParticleSettings;
  simulation: SimulationSettings;
  rendering: RenderSettings;
  camera: CameraConfig;
  light: LightConfig;
  world: WorldConfig;
}

export const conf: ExperienceConfig = {
  particles: {
    maxParticles: 8192 * 16,
    particles: 8192 * 4,
    actualSize: 1,
    size: 1,
    points: true,
  },

  simulation: {
    noise: 1.0,
    speed: 1,
    stiffness: 3.0,
    restDensity: 1.0,
    density: 1,
    dynamicViscosity: 0.1,
    gravity: 0,
    gravitySensorReading: new THREE.Vector3(),
    accelerometerReading: new THREE.Vector3(),
  },

  rendering: {
    bloom: true,
    gui: null,
    run: true,
  },

  camera: {
    position: [0.008, 0.867, -0.874],
    target: [0.008, 0.611, 0.153],
    fov: 60,
  },

  light: {
    position: [0, 1.2, -0.8],
    target: [0, 0.7, 0],
    intensity: 5,
    angle: Math.PI * 0.18,
    penumbra: 1,
  },

  world: {
    size: 64,
    rendererOffset: -32,
  },
};



================================================
FILE: src/vanilla-three/experiences/particles/lights.ts
================================================
import * as THREE from "three/webgpu";
import { conf } from "./constants";

export class Lights {
  public object: THREE.Object3D;

  constructor() {
    this.object = new THREE.Object3D();
    const spotLight = new THREE.SpotLight(
      0xffd28c,
      conf.light.intensity,
      25,
      conf.light.angle,
      conf.light.penumbra,
      2
    );
    const lightTarget = new THREE.Object3D();
    const [lx, ly, lz] = conf.light.position;
    const [tx, ty, tz] = conf.light.target;
    spotLight.position.set(lx, ly, lz);
    lightTarget.position.set(tx, ty, tz);
    spotLight.target = lightTarget;
    spotLight.castShadow = true;

    spotLight.shadow.camera.near = 500;
    spotLight.shadow.camera.far = 4000;
    spotLight.shadow.camera.fov = 30;

    this.object.add(spotLight);
    this.object.add(lightTarget);
  }
}



================================================
FILE: src/vanilla-three/experiences/particles/ParticlesExperience.ts
================================================
import { Pane } from "tweakpane";
import * as THREE from "three/webgpu";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";
import { BaseExperience, type ExperienceOptions } from "../BaseExperience";
import { Simulation } from "./mls-mpm/Simulation";
import { ParticleRenderer } from "./renderers/ParticleRenderer";
import { conf } from "./constants";
import { Fn, mrt, output, pass, vec4, type ShaderNodeObject } from "three/tsl";
import BloomNode, { bloom } from "three/examples/jsm/tsl/display/BloomNode.js";
import { Lights } from "./lights";

export class ParticlesExperience extends BaseExperience {
  private scene!: THREE.Scene;
  private camera!: THREE.PerspectiveCamera;
  private renderer!: THREE.WebGPURenderer;
  private controls!: OrbitControls;
  private clock: THREE.Clock;
  private animationFrameId: number | null = null;
  private objects: THREE.Object3D[] = [];
  private lights!: Lights;
  private simulation!: Simulation;
  private pointRenderer!: ParticleRenderer;
  private postProcessing!: THREE.PostProcessing;
  private bloomPass!: ShaderNodeObject<BloomNode>;
  private pane!: Pane;

  private handleResize!: () => void;

  constructor(canvas: HTMLCanvasElement, options: ExperienceOptions = {}) {
    super(canvas, options);
    this.clock = new THREE.Clock();
  }

  private initScene(): void {
    this.scene = new THREE.Scene();
    this.scene.background = new THREE.Color(0x1a1a1a);
  }

  private initCamera(): void {
    const aspect = this.canvas.clientWidth / this.canvas.clientHeight;
    this.camera = new THREE.PerspectiveCamera(conf.camera.fov, aspect, 0.01, 5);
    const [x, y, z] = conf.camera.position;
    this.camera.position.set(x, y, z);
    this.camera.updateProjectionMatrix();
  }

  private async initRenderer(): Promise<void> {
    this.renderer = new THREE.WebGPURenderer({
      canvas: this.canvas,
      antialias: true,
    });
    await this.renderer.init();
    this.renderer.setSize(this.canvas.clientWidth, this.canvas.clientHeight);
    this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    this.renderer.outputColorSpace = THREE.SRGBColorSpace;
  }

  private initControls(): void {
    this.controls = new OrbitControls(this.camera, this.canvas);
    const [tx, ty, tz] = conf.camera.target;
    this.controls.target.set(tx, ty, tz);
    this.controls.enableDamping = true;
    this.controls.dampingFactor = 0.05;
  }

  private initLights(): void {
    this.lights = new Lights();
    this.scene.add(this.lights.object);
  }

  private setupResize(): void {
    this.handleResize = () => {
      const aspect = this.canvas.clientWidth / this.canvas.clientHeight;
      this.camera.aspect = aspect;
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(this.canvas.clientWidth, this.canvas.clientHeight);
      this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    };

    window.addEventListener("resize", this.handleResize);
  }

  private initObjects(): void {}

  private initPostProcessing(): void {
    const scenePass = pass(this.scene, this.camera);
    scenePass.setMRT(
      mrt({
        output: output,
        bloomIntensity: vec4(0, 0, 0, 1),
      })
    );

    const outputPass = scenePass.getTextureNode();
    const bloomIntensityPass = scenePass.getTextureNode("bloomIntensity");
    const bloomPass = bloom(outputPass.mul(bloomIntensityPass.r));

    const postProcessing = new THREE.PostProcessing(this.renderer);
    postProcessing.outputColorTransform = false;
    postProcessing.outputNode = Fn(() => {
      const a = outputPass.rgb.clamp(0, 1).toVar();
      const b = bloomPass.rgb
        .clamp(0, 1)
        .mul(bloomIntensityPass.r.sign().oneMinus())
        .toVar();
      const blended = a.mul(a.add(b.mul(a.oneMinus()).mul(2))).toVar();
      return vec4(blended.clamp(0, 1), 1.0);
    })().renderOutput();

    this.postProcessing = postProcessing;
    this.bloomPass = bloomPass;
    this.bloomPass.threshold.value = 0.001;
    this.bloomPass.strength.value = 0.94;
    this.bloomPass.radius.value = 0.8;
  }

  private async initSimulation(): Promise<void> {
    this.simulation = new Simulation(this.renderer);
    await this.simulation.init();
    this.pointRenderer = new ParticleRenderer(this.simulation);
    if (this.pointRenderer.object) {
      this.scene.add(this.pointRenderer.object);
    }
  }

  private initGUI(): void {
    const container = this.options.controlsContainer;

    this.pane = new Pane({
      title: "Particles Simulation",
      expanded: true,
      ...(container && { container }),
    });

    // Particle Settings
    const particlesFolder = this.pane.addFolder({
      title: "Particles",
      expanded: false,
    });

    particlesFolder.addBinding(conf.particles, "particles", {
      label: "Particle Count",
      min: 1000,
      max: conf.particles.maxParticles,
      step: 1000,
    });

    particlesFolder.addBinding(conf.particles, "actualSize", {
      label: "Actual Size",
      min: 0.1,
      max: 5,
      step: 0.1,
    });

    particlesFolder.addBinding(conf.particles, "size", {
      label: "Display Size",
      min: 0.1,
      max: 5,
      step: 0.1,
    });

    particlesFolder.addBinding(conf.particles, "points", {
      label: "Show Points",
    });

    // Simulation Physics
    const simulationFolder = this.pane.addFolder({
      title: "Simulation",
      expanded: false,
    });

    simulationFolder.addBinding(conf.simulation, "noise", {
      label: "Noise",
      min: 0,
      max: 5,
      step: 0.1,
    });

    simulationFolder.addBinding(conf.simulation, "speed", {
      label: "Speed",
      min: 0,
      max: 10,
      step: 0.1,
    });

    simulationFolder.addBinding(conf.simulation, "stiffness", {
      label: "Stiffness",
      min: 0,
      max: 10,
      step: 0.1,
    });

    simulationFolder.addBinding(conf.simulation, "restDensity", {
      label: "Rest Density",
      min: 0,
      max: 5,
      step: 0.1,
    });

    simulationFolder.addBinding(conf.simulation, "density", {
      label: "Density",
      min: 0,
      max: 5,
      step: 0.1,
    });

    simulationFolder.addBinding(conf.simulation, "dynamicViscosity", {
      label: "Viscosity",
      min: 0,
      max: 1,
      step: 0.01,
    });

    simulationFolder.addBinding(conf.simulation, "gravity", {
      label: "Gravity",
      min: -10,
      max: 10,
      step: 0.1,
    });

    // Rendering
    const renderingFolder = this.pane.addFolder({
      title: "Rendering",
      expanded: false,
    });

    renderingFolder.addBinding(conf.rendering, "bloom", {
      label: "Bloom Effect",
    });

    renderingFolder.addBinding(conf.rendering, "run", {
      label: "Run Simulation",
    });

    // Camera
    const cameraFolder = this.pane.addFolder({
      title: "Camera",
      expanded: false,
    });

    cameraFolder
      .addBinding(conf.camera, "fov", {
        label: "Field of View",
        min: 10,
        max: 120,
        step: 1,
      })
      .on("change", () => {
        this.camera.fov = conf.camera.fov;
        this.camera.updateProjectionMatrix();
      });

    // Light (Spotlight)
    const lightFolder = this.pane.addFolder({
      title: "Light",
      expanded: false,
    });

    lightFolder.addBinding(conf.light, "intensity", {
      label: "Intensity",
      min: 0,
      max: 5,
      step: 0.1,
    });

    lightFolder.addBinding(conf.light, "angle", {
      label: "Angle",
      min: 0,
      max: Math.PI / 2,
      step: 0.01,
    });

    lightFolder.addBinding(conf.light, "penumbra", {
      label: "Penumbra",
      min: 0,
      max: 1,
      step: 0.01,
    });

    // World
    const worldFolder = this.pane.addFolder({
      title: "World",
      expanded: false,
    });

    worldFolder.addBinding(conf.world, "size", {
      label: "Grid Size",
      min: 16,
      max: 128,
      step: 16,
    });

    // Reset button
    this.pane
      .addButton({
        title: "Reset Settings",
      })
      .on("click", () => {
        conf.particles.particles = 5000;
        conf.simulation.speed = 1.0;
        conf.simulation.stiffness = 1.0;
        conf.rendering.bloom = true;
        conf.rendering.run = true;
        this.pane.refresh();
      });
  }

  private animate = async (): Promise<void> => {
    const delta = this.clock.getDelta();
    this.animationFrameId = requestAnimationFrame(this.animate);
    const pointObj = this.pointRenderer?.object as any;
    pointObj.visible = conf.particles.points;
    this.controls.update(delta);
    this.pointRenderer.update();
    await this.simulation.update(delta);
    if (conf.rendering.bloom && this.postProcessing) {
      await this.postProcessing.renderAsync();
    } else {
      await this.renderer.renderAsync(this.scene, this.camera);
    }
  };

  public async init(): Promise<void> {
    try {
      if (this.options.controlsContainer) {
        this.initGUI();
      }

      this.initScene();
      this.initCamera();
      await this.initRenderer();
      this.initControls();
      await this.initSimulation();
      this.initLights();
      this.setupResize();
      this.initObjects();
      this.initPostProcessing();

      await this.animate();
    } catch (error) {
      console.error("Failed to initialize ParticlesExperience:", error);
      throw error;
    }
  }

  public dispose(): void {
    // Cancel animation frame
    if (this.animationFrameId !== null) {
      cancelAnimationFrame(this.animationFrameId);
    }

    // Remove resize listener
    if (this.handleResize) {
      window.removeEventListener("resize", this.handleResize);
    }

    // Dispose of all objects
    this.objects.forEach((object) => {
      if (object instanceof THREE.Mesh) {
        object.geometry.dispose();
        if (Array.isArray(object.material)) {
          object.material.forEach((material) => material.dispose());
        } else {
          object.material.dispose();
        }
      }
    });

    // Clear objects array
    this.objects.length = 0;

    // Dispose of Tweakpane
    if (this.pane) {
      this.pane.dispose();
    }
  }
}



================================================
FILE: src/vanilla-three/experiences/particles/mls-mpm/constants.ts
================================================
import * as THREE from "three/webgpu";

export const conf = {
  maxParticles: 8192 * 16,
  particles: 8192 * 4,
  gui: null,
  bloom: true,
  run: true,
  noise: 1.0,
  speed: 1,
  stiffness: 3.0,
  restDensity: 1.0,
  density: 1,
  dynamicViscosity: 0.1,
  gravity: 0,
  gravitySensorReading: new THREE.Vector3(),
  accelerometerReading: new THREE.Vector3(),
  actualSize: 1,
  size: 1,
  points: false,

  camera: {
    position: [0.008, 0.867, -0.874],
    target: [0.008, 0.611, 0.153],
    fov: 60,
  },

  light: {
    position: [0, 1.2, -0.8],
    target: [0, 0.7, 0],
  },

  world: {
    size: 64,
    rendererOffset: -32,
  },
};



================================================
FILE: src/vanilla-three/experiences/particles/mls-mpm/Simulation.ts
================================================
import * as THREE from "three/webgpu";
import {
  array,
  Fn,
  If,
  instancedArray,
  instanceIndex,
  Return,
  uniform,
  int,
  float,
  Loop,
  vec3,
  vec4,
  atomicAdd,
  uint,
  max,
  pow,
  mat3,
  clamp,
  time,
  cross,
  mix,
  ivec3,
} from "three/tsl";
import { triNoise3Dvec } from "../../../tsl/triNoise3d";
import { StructuredArray } from "./StructuredArray";
import { hsvtorgb } from "../../../tsl/hsvToRgb";
import { conf } from "../constants";

export class Simulation {
  private renderer: THREE.WebGPURenderer;
  public numParticles = 0;
  private gridSize = new THREE.Vector3(0, 0, 0);
  private gridCellSize = new THREE.Vector3(0, 0, 0);
  private uniforms: Record<string, any> = {};
  private kernels: Record<string, any> = {};
  private fixedPointMultiplier = 1e7;
  private mousePos = new THREE.Vector3();
  private mousePosArray: THREE.Vector3[] = [];
  public particleBuffer!: StructuredArray;
  private cellBuffer!: StructuredArray;
  private cellBufferF!: THREE.TSL.ShaderNodeObject<THREE.StorageBufferNode>;
  private: THREE.Vector3[] = [];

  constructor(renderer: THREE.WebGPURenderer) {
    this.renderer = renderer;
  }
  async init() {
    const { maxParticles } = conf.particles;
    this.gridSize.set(64, 64, 64);

    const particleStruct = {
      position: { type: "vec3" },
      density: { type: "float" },
      velocity: { type: "vec3" },
      mass: { type: "float" },
      C: { type: "mat3" },
      direction: { type: "vec3" },
      color: { type: "vec3" },
    };
    this.particleBuffer = new StructuredArray(
      particleStruct,
      maxParticles,
      "particleData"
    );

    const vec = new THREE.Vector3();
    for (let i = 0; i < maxParticles; i++) {
      let dist = 2;
      while (dist > 1) {
        vec
          .set(Math.random(), Math.random(), Math.random())
          .multiplyScalar(2.0)
          .subScalar(1.0);
        dist = vec.length();
        vec
          .multiplyScalar(0.8)
          .addScalar(1.0)
          .divideScalar(2.0)
          .multiply(this.gridSize);
      }
      const mass = 1.0 - Math.random() * 0.002;
      this.particleBuffer.set(i, "position", vec);
      this.particleBuffer.set(i, "mass", mass);
    }

    const cellCount = this.gridSize.x * this.gridSize.y * this.gridSize.z;
    const cellStruct = {
      x: { type: "int", atomic: true },
      y: { type: "int", atomic: true },
      z: { type: "int", atomic: true },
      mass: { type: "int", atomic: true },
    };
    this.cellBuffer = new StructuredArray(cellStruct, cellCount, "cellData");
    this.cellBufferF = instancedArray(cellCount, "vec4").label("cellDataF");

    this.uniforms.gravityType = uniform(0, "uint");
    this.uniforms.gravity = uniform(new THREE.Vector3());
    this.uniforms.stiffness = uniform(0);
    this.uniforms.restDensity = uniform(0);
    this.uniforms.dynamicViscosity = uniform(0);
    this.uniforms.noise = uniform(0);

    this.uniforms.gridSize = uniform(this.gridSize, "ivec3");
    this.uniforms.gridCellSize = uniform(this.gridCellSize);
    this.uniforms.dt = uniform(0.1);
    this.uniforms.numParticles = uniform(0, "uint");

    this.uniforms.mouseRayDirection = uniform(new THREE.Vector3());
    this.uniforms.mouseRayOrigin = uniform(new THREE.Vector3());
    this.uniforms.mouseForce = uniform(new THREE.Vector3());

    this.kernels.clearGrid = Fn(() => {
      this.cellBuffer.setAtomic("x", false);
      this.cellBuffer.setAtomic("y", false);
      this.cellBuffer.setAtomic("z", false);
      this.cellBuffer.setAtomic("mass", false);

      If(instanceIndex.greaterThanEqual(uint(cellCount)), () => {
        Return();
      });

      this.cellBuffer.element(instanceIndex).get("x").assign(0);
      this.cellBuffer.element(instanceIndex).get("y").assign(0);
      this.cellBuffer.element(instanceIndex).get("z").assign(0);
      this.cellBuffer.element(instanceIndex).get("mass").assign(0);
      this.cellBufferF.element(instanceIndex).assign(0);
    })().compute(cellCount);

    const encodeFixedPoint = (f32: any) => {
      return int(f32.mul(this.fixedPointMultiplier));
    };
    const decodeFixedPoint = (i32: any) => {
      return float(i32).div(this.fixedPointMultiplier);
    };

    const getCellPtr = (ipos: any) => {
      const gridSize = this.uniforms.gridSize;
      const cellPtr = int(ipos.x)
        .mul(gridSize.y)
        .mul(gridSize.z)
        .add(int(ipos.y).mul(gridSize.z))
        .add(int(ipos.z))
        .toConst();
      return cellPtr;
    };
    const getCell = (ipos: any) => {
      // @ts-ignore
      return this.cellBuffer.element(getCellPtr(ipos));
    };

    this.kernels.p2g1 = Fn(() => {
      this.cellBuffer.setAtomic("x", true);
      this.cellBuffer.setAtomic("y", true);
      this.cellBuffer.setAtomic("z", true);
      this.cellBuffer.setAtomic("mass", true);

      If(
        instanceIndex.greaterThanEqual(uint(this.uniforms.numParticles)),
        () => {
          Return();
        }
      );
      const particlePosition = this.particleBuffer
        .element(instanceIndex)
        .get("position")
        .xyz.toConst("particlePosition");
      const particleVelocity = this.particleBuffer
        .element(instanceIndex)
        .get("velocity")
        .xyz.toConst("particleVelocity");

      const cellIndex = ivec3(particlePosition).sub(1).toConst("cellIndex");
      const cellDiff = particlePosition.fract().sub(0.5).toConst("cellDiff");
      const w0 = float(0.5)
        .mul(float(0.5).sub(cellDiff))
        .mul(float(0.5).sub(cellDiff));
      const w1 = float(0.75).sub(cellDiff.mul(cellDiff));
      const w2 = float(0.5)
        .mul(float(0.5).add(cellDiff))
        .mul(float(0.5).add(cellDiff));
      const weights = array([w0, w1, w2]).toConst("weights");

      const C = this.particleBuffer.element(instanceIndex).get("C").toConst();
      Loop({ start: 0, end: 3, type: "int", condition: "<" }, ({ i: gx }) => {
        Loop(
          // @ts-ignore
          { start: 0, end: 3, type: "int", name: "gy", condition: "<" },
          // @ts-ignore
          ({ gy }) => {
            Loop(
              // @ts-ignore
              { start: 0, end: 3, type: "int", name: "gz", condition: "<" },
              // @ts-ignore
              ({ gz }) => {
                const weight = weights
                  .element(gx)
                  .x.mul(weights.element(gy).y)
                  .mul(weights.element(gz).z);
                const cellX = cellIndex.add(ivec3(gx, gy, gz)).toConst();
                const cellDist = vec3(cellX)
                  .add(0.5)
                  .sub(particlePosition)
                  .toConst("cellDist");
                const Q = C.mul(cellDist);

                const massContrib = weight; // assuming particle mass = 1.0
                const velContrib = massContrib
                  .mul(particleVelocity.add(Q))
                  .toConst("velContrib");
                const cell = getCell(cellX);
                atomicAdd(cell.get("x"), encodeFixedPoint(velContrib.x));
                atomicAdd(cell.get("y"), encodeFixedPoint(velContrib.y));
                atomicAdd(cell.get("z"), encodeFixedPoint(velContrib.z));
                atomicAdd(cell.get("mass"), encodeFixedPoint(massContrib));
              }
            );
          }
        );
      });
    })().compute(1);

    this.kernels.p2g2 = Fn(() => {
      this.cellBuffer.setAtomic("x", true);
      this.cellBuffer.setAtomic("y", true);
      this.cellBuffer.setAtomic("z", true);
      this.cellBuffer.setAtomic("mass", false);

      If(
        instanceIndex.greaterThanEqual(uint(this.uniforms.numParticles)),
        () => {
          Return();
        }
      );
      const particlePosition = this.particleBuffer
        .element(instanceIndex)
        .get("position")
        .xyz.toConst("particlePosition");

      const cellIndex = ivec3(particlePosition).sub(1).toConst("cellIndex");
      const cellDiff = particlePosition.fract().sub(0.5).toConst("cellDiff");
      const w0 = float(0.5)
        .mul(float(0.5).sub(cellDiff))
        .mul(float(0.5).sub(cellDiff));
      const w1 = float(0.75).sub(cellDiff.mul(cellDiff));
      const w2 = float(0.5)
        .mul(float(0.5).add(cellDiff))
        .mul(float(0.5).add(cellDiff));
      const weights = array([w0, w1, w2]).toConst("weights");

      const density = float(0).toVar("density");
      Loop(
        // @ts-ignore
        { start: 0, end: 3, type: "int", name: "gx", condition: "<" },
        // @ts-ignore
        ({ gx }) => {
          Loop(
            // @ts-ignore
            { start: 0, end: 3, type: "int", name: "gy", condition: "<" },
            // @ts-ignore
            ({ gy }) => {
              Loop(
                // @ts-ignore
                { start: 0, end: 3, type: "int", name: "gz", condition: "<" },
                // @ts-ignore
                ({ gz }) => {
                  const weight = weights
                    .element(gx)
                    .x.mul(weights.element(gy).y)
                    .mul(weights.element(gz).z);
                  const cellX = cellIndex.add(ivec3(gx, gy, gz)).toConst();
                  const cell = getCell(cellX);
                  density.addAssign(
                    decodeFixedPoint(cell.get("mass")).mul(weight)
                  );
                }
              );
            }
          );
        }
      );
      const densityStore = this.particleBuffer
        .element(instanceIndex)
        .get("density");
      densityStore.assign(mix(densityStore, density, 0.05));

      const volume = float(1).div(density);
      const pressure = max(
        0.0,
        pow(density.div(this.uniforms.restDensity), 5.0)
          .sub(1)
          .mul(this.uniforms.stiffness)
      ).toConst("pressure");
      const stress = mat3(
        pressure.negate(),
        0,
        0,
        0,
        pressure.negate(),
        0,
        0,
        0,
        pressure.negate()
      ).toVar("stress");
      const dudv = this.particleBuffer
        .element(instanceIndex)
        .get("C")
        .toConst("C");

      const strain = dudv.add(dudv.transpose());
      stress.addAssign(strain.mul(this.uniforms.dynamicViscosity));
      const eq16Term0 = volume.mul(-4).mul(stress).mul(this.uniforms.dt);

      Loop(
        // @ts-ignore
        { start: 0, end: 3, type: "int", name: "gx", condition: "<" },
        // @ts-ignore
        ({ gx }) => {
          Loop(
            // @ts-ignore
            { start: 0, end: 3, type: "int", name: "gy", condition: "<" },
            // @ts-ignore
            ({ gy }) => {
              Loop(
                // @ts-ignore
                { start: 0, end: 3, type: "int", name: "gz", condition: "<" },
                // @ts-ignore
                ({ gz }) => {
                  const weight = weights
                    .element(gx)
                    .x.mul(weights.element(gy).y)
                    .mul(weights.element(gz).z);
                  const cellX = cellIndex.add(ivec3(gx, gy, gz)).toConst();
                  const cellDist = vec3(cellX)
                    .add(0.5)
                    .sub(particlePosition)
                    .toConst("cellDist");
                  const cell = getCell(cellX);

                  const momentum = eq16Term0
                    .mul(weight)
                    .mul(cellDist)
                    .toConst("momentum");
                  atomicAdd(cell.get("x"), encodeFixedPoint(momentum.x));
                  atomicAdd(cell.get("y"), encodeFixedPoint(momentum.y));
                  atomicAdd(cell.get("z"), encodeFixedPoint(momentum.z));
                }
              );
            }
          );
        }
      );
    })().compute(1);

    this.kernels.updateGrid = Fn(() => {
      this.cellBuffer.setAtomic("x", false);
      this.cellBuffer.setAtomic("y", false);
      this.cellBuffer.setAtomic("z", false);
      this.cellBuffer.setAtomic("mass", false);

      If(instanceIndex.greaterThanEqual(uint(cellCount)), () => {
        Return();
      });
      const cell = this.cellBuffer.element(instanceIndex).toConst("cell");

      const mass = decodeFixedPoint(cell.get("mass")).toConst();
      If(mass.lessThanEqual(0), () => {
        Return();
      });

      const vx = decodeFixedPoint(cell.get("x")).div(mass).toVar();
      const vy = decodeFixedPoint(cell.get("y")).div(mass).toVar();
      const vz = decodeFixedPoint(cell.get("z")).div(mass).toVar();

      const x = int(instanceIndex)
        .div(this.uniforms.gridSize.z)
        .div(this.uniforms.gridSize.y);
      const y = int(instanceIndex)
        .div(this.uniforms.gridSize.z)
        .mod(this.uniforms.gridSize.y);
      const z = int(instanceIndex).mod(this.uniforms.gridSize.z);

      If(
        x
          .lessThan(int(2))
          .or(x.greaterThan(this.uniforms.gridSize.x.sub(int(2)))),
        () => {
          vx.assign(0);
        }
      );
      If(
        y
          .lessThan(int(2))
          .or(y.greaterThan(this.uniforms.gridSize.y.sub(int(2)))),
        () => {
          vy.assign(0);
        }
      );
      If(
        z
          .lessThan(int(2))
          .or(z.greaterThan(this.uniforms.gridSize.z.sub(int(2)))),
        () => {
          vz.assign(0);
        }
      );

      this.cellBufferF.element(instanceIndex).assign(vec4(vx, vy, vz, mass));
    })().compute(cellCount);

    this.kernels.g2p = Fn(() => {
      If(
        instanceIndex.greaterThanEqual(uint(this.uniforms.numParticles)),
        () => {
          Return();
        }
      );
      const particleMass = this.particleBuffer
        .element(instanceIndex)
        .get("mass")
        .toConst("particleMass");
      const particleDensity = this.particleBuffer
        .element(instanceIndex)
        .get("density")
        .toConst("particleDensity");
      const particlePosition = this.particleBuffer
        .element(instanceIndex)
        .get("position")
        .xyz.toVar("particlePosition");
      const particleVelocity = vec3(0).toVar();
      If(this.uniforms.gravityType.equal(uint(2)), () => {
        const pn = particlePosition
          .div(vec3(this.uniforms.gridSize.sub(1)))
          .sub(0.5)
          .normalize()
          .toConst();
        particleVelocity.subAssign(pn.mul(0.3).mul(this.uniforms.dt));
      }).Else(() => {
        particleVelocity.addAssign(this.uniforms.gravity.mul(this.uniforms.dt));
      });

      const noise = triNoise3Dvec(particlePosition.mul(0.015), time, 0.11)
        .sub(0.285)
        .normalize()
        .mul(0.28)
        .toVar();
      particleVelocity.subAssign(
        noise.mul(this.uniforms.noise).mul(this.uniforms.dt)
      );

      const cellIndex = ivec3(particlePosition).sub(1).toConst("cellIndex");
      const cellDiff = particlePosition.fract().sub(0.5).toConst("cellDiff");

      const w0 = float(0.5)
        .mul(float(0.5).sub(cellDiff))
        .mul(float(0.5).sub(cellDiff));
      const w1 = float(0.75).sub(cellDiff.mul(cellDiff));
      const w2 = float(0.5)
        .mul(float(0.5).add(cellDiff))
        .mul(float(0.5).add(cellDiff));
      const weights = array([w0, w1, w2]).toConst("weights");

      const B = mat3(0).toVar("B");
      Loop(
        // @ts-ignore
        { start: 0, end: 3, type: "int", name: "gx", condition: "<" },
        // @ts-ignore
        ({ gx }) => {
          Loop(
            // @ts-ignore
            { start: 0, end: 3, type: "int", name: "gy", condition: "<" },
            // @ts-ignore
            ({ gy }) => {
              Loop(
                // @ts-ignore
                { start: 0, end: 3, type: "int", name: "gz", condition: "<" },
                // @ts-ignore
                ({ gz }) => {
                  const weight = weights
                    .element(gx)
                    .x.mul(weights.element(gy).y)
                    .mul(weights.element(gz).z);
                  const cellX = cellIndex.add(ivec3(gx, gy, gz)).toConst();
                  const cellDist = vec3(cellX)
                    .add(0.5)
                    .sub(particlePosition)
                    .toConst("cellDist");
                  const cellPtr = getCellPtr(cellX);

                  const weightedVelocity = this.cellBufferF
                    .element(cellPtr)
                    .xyz.mul(weight)
                    .toConst("weightedVelocity");
                  const term = mat3(
                    weightedVelocity.mul(cellDist.x),
                    weightedVelocity.mul(cellDist.y),
                    weightedVelocity.mul(cellDist.z)
                  );
                  B.addAssign(term);
                  particleVelocity.addAssign(weightedVelocity);
                }
              );
            }
          );
        }
      );

      const dist = cross(
        this.uniforms.mouseRayDirection,
        particlePosition.mul(vec3(1, 1, 0.4)).sub(this.uniforms.mouseRayOrigin)
      ).length();
      const force = dist.mul(0.1).oneMinus().max(0.0).pow(2);
      //particleVelocity.assign(mix(particleVelocity, this.uniforms.mouseForce.mul(6), force));
      particleVelocity.addAssign(this.uniforms.mouseForce.mul(1).mul(force));
      particleVelocity.mulAssign(particleMass); // to ensure difference between particles

      this.particleBuffer.element(instanceIndex).get("C").assign(B.mul(4));
      particlePosition.addAssign(particleVelocity.mul(this.uniforms.dt));
      particlePosition.assign(
        clamp(particlePosition, vec3(2), this.uniforms.gridSize.sub(2))
      );

      const wallStiffness = 0.3;
      const xN = particlePosition
        .add(particleVelocity.mul(this.uniforms.dt).mul(3.0))
        .toConst("xN");
      const wallMin = vec3(3).toConst("wallMin");
      const wallMax = vec3(this.uniforms.gridSize).sub(3).toConst("wallMax");
      If(xN.x.lessThan(wallMin.x), () => {
        particleVelocity.x.addAssign(wallMin.x.sub(xN.x).mul(wallStiffness));
      });
      If(xN.x.greaterThan(wallMax.x), () => {
        particleVelocity.x.addAssign(wallMax.x.sub(xN.x).mul(wallStiffness));
      });
      If(xN.y.lessThan(wallMin.y), () => {
        particleVelocity.y.addAssign(wallMin.y.sub(xN.y).mul(wallStiffness));
      });
      If(xN.y.greaterThan(wallMax.y), () => {
        particleVelocity.y.addAssign(wallMax.y.sub(xN.y).mul(wallStiffness));
      });
      If(xN.z.lessThan(wallMin.z), () => {
        particleVelocity.z.addAssign(wallMin.z.sub(xN.z).mul(wallStiffness));
      });
      If(xN.z.greaterThan(wallMax.z), () => {
        particleVelocity.z.addAssign(wallMax.z.sub(xN.z).mul(wallStiffness));
      });

      this.particleBuffer
        .element(instanceIndex)
        .get("position")
        .assign(particlePosition);
      this.particleBuffer
        .element(instanceIndex)
        .get("velocity")
        .assign(particleVelocity);

      const direction = this.particleBuffer
        .element(instanceIndex)
        .get("direction");
      direction.assign(mix(direction, particleVelocity, 0.1));

      const color = hsvtorgb(
        vec3(
          particleDensity
            .div(this.uniforms.restDensity)
            .mul(0.25)
            .add(time.mul(0.05)),
          particleVelocity.length().mul(0.5).clamp(0, 1).mul(0.3).add(0.7),
          force.mul(0.3).add(0.7)
        )
      );
      this.particleBuffer.element(instanceIndex).get("color").assign(color);
    })().compute(1);
  }

  setMouseRay(
    origin: THREE.Vector3,
    direction: THREE.Vector3,
    pos: THREE.Vector3
  ) {
    origin.multiplyScalar(64);
    pos.multiplyScalar(64);
    origin.add(new THREE.Vector3(32, 0, 0));
    this.uniforms.mouseRayDirection.value.copy(direction.normalize());
    this.uniforms.mouseRayOrigin.value.copy(origin);
    this.mousePos.copy(pos);
  }

  async update(interval: number) {
    const { particles } = conf.particles;
    const { run } = conf.rendering;
    const {
      noise,
      dynamicViscosity,
      stiffness,
      restDensity,
      speed,
      gravity,
      gravitySensorReading,
      accelerometerReading,
    } = conf.simulation;

    this.uniforms.noise.value = noise;
    this.uniforms.stiffness.value = stiffness;
    this.uniforms.gravityType.value = gravity;
    if (gravity === 0) {
      this.uniforms.gravity.value.set(0, 0, 0.2);
    } else if (gravity === 1) {
      this.uniforms.gravity.value.set(0, -0.2, 0);
    } else if (gravity === 3) {
      this.uniforms.gravity.value
        .copy(gravitySensorReading)
        .add(accelerometerReading);
    }
    this.uniforms.dynamicViscosity.value = dynamicViscosity;
    this.uniforms.restDensity.value = restDensity;

    if (particles !== this.numParticles) {
      this.numParticles = particles;
      this.uniforms.numParticles.value = particles;
      this.kernels.p2g1.count = particles;
      this.kernels.p2g1.updateDispatchCount();
      this.kernels.p2g2.count = particles;
      this.kernels.p2g2.updateDispatchCount();
      this.kernels.g2p.count = particles;
      this.kernels.g2p.updateDispatchCount();
    }

    interval = Math.min(interval, 1 / 60);
    const dt = interval * 6 * speed;
    this.uniforms.dt.value = dt;

    this.mousePosArray.push(this.mousePos.clone());
    if (this.mousePosArray.length > 3) {
      this.mousePosArray.shift();
    }
    if (this.mousePosArray.length > 1) {
      this.uniforms.mouseForce.value
        .copy(this.mousePosArray[this.mousePosArray.length - 1])
        .sub(this.mousePosArray[0])
        .divideScalar(this.mousePosArray.length);
    }

    if (run) {
      const kernels = [
        this.kernels.clearGrid,
        this.kernels.p2g1,
        this.kernels.p2g2,
        this.kernels.updateGrid,
        this.kernels.g2p,
      ];
      await this.renderer.computeAsync(kernels);
    }
  }
}



================================================
FILE: src/vanilla-three/experiences/particles/mls-mpm/StructuredArray.ts
================================================
import { struct, instancedArray, type ShaderNodeObject } from "three/tsl";
import type { IndexNode, Vector3 } from "three/webgpu";

const TYPES = {
  int: { size: 1, alignment: 1, isFloat: false },
  uint: { size: 1, alignment: 1, isFloat: false },
  float: { size: 1, alignment: 1, isFloat: true },

  vec2: { size: 2, alignment: 2, isFloat: true },
  ivec2: { size: 2, alignment: 2, isFloat: false },
  uvec2: { size: 2, alignment: 2, isFloat: false },

  vec3: { size: 3, alignment: 4, isFloat: true },
  ivec3: { size: 3, alignment: 4, isFloat: false },
  uvec3: { size: 3, alignment: 4, isFloat: false },

  vec4: { size: 4, alignment: 4, isFloat: true },
  ivec4: { size: 4, alignment: 4, isFloat: false },
  uvec4: { size: 4, alignment: 4, isFloat: false },

  mat2: { size: 4, alignment: 2, isFloat: true },
  mat3: { size: 12, alignment: 4, isFloat: true },
  mat4: { size: 16, alignment: 4, isFloat: true },
};

/**
 * Utility for creating structured arrays compatible with Three.js TSL and WebGPU.
 * Handles memory alignment, type safety, and buffer management for GPU operations.
 *
 * @example
 * const particles = new StructuredArray({
 *   position: 'vec3',
 *   velocity: 'vec3',
 *   life: 'float'
 * }, 1000, 'particles');
 */
export class StructuredArray {
  layout: any;
  length: number;

  structNode: any;
  buffer: any;
  structSize = 0;
  floatArray: Float32Array;
  intArray: Int32Array;

  constructor(layout: any, length: number, label: string) {
    this.layout = this._parse(layout);
    this.length = length;
    this.structNode = struct(this.layout);
    this.floatArray = new Float32Array(this.structSize * this.length);
    this.intArray = new Int32Array(this.floatArray.buffer);
    this.buffer = instancedArray(this.floatArray, this.structNode).label(label);
  }

  setAtomic(element: string, value: boolean) {
    const index = Object.keys(this.layout).findIndex((k) => k === element);
    if (index >= 0) {
      this.buffer.structTypeNode.membersLayout[index].atomic = value;
    }
  }

  set(index: number, element: string, value: number | number[] | Vector3) {
    const member = this.layout[element];
    if (!member) {
      return console.error("Unknown element '" + element + "'");
    }
    const offset = index * this.structSize + member.offset;
    const array = member.isFloat ? this.floatArray : this.intArray;

    if (member.size === 1) {
      if (typeof value !== "number") {
        return console.error(
          "Expected a Number value for element '" + element + "'"
        );
      }
      array[offset] = value;
    }
    if (member.size > 1) {
      if (typeof value === "object" && !Array.isArray(value)) {
        const obj = value;
        // @ts-ignore
        value = [obj.x, obj.y || 0, obj.z || 0, obj.w || 0];
      }
      if (!Array.isArray(value) || value.length < member.size) {
        return console.error(
          "Expected an array of length " +
            member.size +
            " for element '" +
            element +
            "'"
        );
      }
      for (let i = 0; i < member.size; i++) {
        array[offset + i] = value[i];
      }
    }
  }

  element(index: ShaderNodeObject<IndexNode>) {
    return this.buffer.element(index);
  }

  get(index: number, element: string) {
    return this.buffer.element(index).get(element);
  }

  _parse(layout: any) {
    let offset = 0;
    const parsedLayout: Record<string, any> = {};

    const keys = Object.keys(layout);
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      let member = layout[key];
      if (typeof member === "string" || member instanceof String) {
        member = { type: member };
      }
      const type = member.type;
      if (!TYPES[type as keyof typeof TYPES]) {
        return console.error("Unknown type '" + type + "'");
      }
      const { size, alignment, isFloat } = TYPES[type as keyof typeof TYPES];
      member.size = size;
      member.isFloat = isFloat;

      const rest = offset % alignment;
      if (rest !== 0) {
        offset += alignment - rest;
      }
      member.offset = offset;
      offset += size;

      parsedLayout[key] = member;
    }

    const rest = offset % 4;
    if (rest !== 0) {
      offset += 4 - rest;
    }

    this.structSize = offset;
    return parsedLayout;
  }
}



================================================
FILE: src/vanilla-three/experiences/particles/renderers/ParticleRenderer.ts
================================================
import * as THREE from "three/webgpu";
import { Fn, vec3, instanceIndex } from "three/tsl";
import { conf } from "../constants";
import { Simulation } from "../mls-mpm/Simulation";

export class ParticleRenderer {
  public simulation: Simulation;
  public object: THREE.Points | null = null;
  public geometry: THREE.InstancedBufferGeometry;

  constructor(simulation: Simulation) {
    this.simulation = simulation;

    this.geometry = new THREE.InstancedBufferGeometry();
    const positionBuffer = new THREE.BufferAttribute(
      new Float32Array(3),
      3,
      false
    );
    const material = new THREE.PointsNodeMaterial();
    this.geometry.setAttribute("position", positionBuffer);
    this.object = new THREE.Points(this.geometry, material);
    material.positionNode = Fn(() => {
      return this.simulation.particleBuffer
        .element(instanceIndex)
        .get("position")
        .mul(vec3(1, 1, 0.4));
    })();

    if (this.object) {
      this.object.frustumCulled = false;

      const s = 1 / conf.world.size;
      this.object.position.set(conf.world.rendererOffset * s, 0, 0);
      this.object.scale.set(s, s, s);
      this.object.castShadow = true;
      this.object.receiveShadow = true;
    }
  }

  update() {
    const { particles } = conf.particles;
    this.geometry.instanceCount = particles;
  }
}



================================================
FILE: src/vanilla-three/experiences/pixel-flow/BehavioralPatterns.ts
================================================
import type { MovementPatternContext } from "./EcosystemMovementPatterns";

export interface BehavioralState {
  energy: number;
  phase: number;
}

export class BehavioralPatternLibrary {
  private behavioralState: BehavioralState;

  constructor() {
    this.behavioralState = {
      energy: 0.5,
      phase: 0,
    };
  }

  public generateSchoolingFish(ctx: MovementPatternContext): {
    x: number;
    y: number;
  } {
    const speed = 0.0008 * (0.5 + this.behavioralState.energy * 0.5);
    const time = ctx.time * speed;

    const centerX = 0.5 + Math.sin(time * 0.7) * 0.2 * ctx.scaleMultiplier;
    const centerY = 0.5 + Math.cos(time * 0.5) * 0.15 * ctx.scaleMultiplier;

    const offsetX = Math.sin(time * 2 + this.behavioralState.phase) * 0.05;
    const offsetY = Math.cos(time * 1.5 + this.behavioralState.phase) * 0.05;

    return { x: centerX + offsetX, y: centerY + offsetY };
  }

  public generateBirdMigration(ctx: MovementPatternContext): {
    x: number;
    y: number;
  } {
    const speed = 0.0006 * (0.3 + this.behavioralState.energy * 0.7);
    const time = ctx.time * speed;

    const angle = (time * 0.3) % (Math.PI * 2);
    const x = 0.5 + Math.cos(angle) * 0.3 * ctx.scaleMultiplier;
    const y = 0.5 + Math.sin(angle) * 0.2 * ctx.scaleMultiplier;

    return { x, y };
  }

  public generatePredatorStalking(ctx: MovementPatternContext): {
    x: number;
    y: number;
  } {
    const huntPhase = (ctx.time * 0.0003) % (Math.PI * 4);
    const isStriking = Math.sin(huntPhase) > 0.8;

    if (isStriking) {
      const speed = 0.003 * ctx.intensity;
      const x = 0.5 + Math.sin(ctx.time * speed) * 0.4;
      const y = 0.5 + Math.cos(ctx.time * speed * 0.8) * 0.3;
      return { x, y };
    } else {
      const speed = 0.0002;
      const time = ctx.time * speed;
      const x =
        0.5 +
        ctx.noiseFunction(time + ctx.baseOffset.x, 0) *
          0.3 *
          ctx.scaleMultiplier;
      const y =
        0.5 +
        ctx.noiseFunction(0, time + ctx.baseOffset.y) *
          0.3 *
          ctx.scaleMultiplier;
      return { x, y };
    }
  }

  public generateInsectSwarm(ctx: MovementPatternContext): {
    x: number;
    y: number;
  } {
    const speed = 0.002 * (0.5 + this.behavioralState.energy * 0.5);
    const time = ctx.time * speed;

    const centerX = 0.5 + Math.sin(time * 0.3) * 0.2;
    const centerY = 0.5 + Math.cos(time * 0.4) * 0.2;

    const offsetX =
      ctx.noiseFunction(time * 3, this.behavioralState.phase) * 0.1;
    const offsetY =
      ctx.noiseFunction(this.behavioralState.phase, time * 3) * 0.1;

    return { x: centerX + offsetX, y: centerY + offsetY };
  }

  public generateSeaweedSway(ctx: MovementPatternContext): {
    x: number;
    y: number;
  } {
    const speed = 0.0005;
    const time = ctx.time * speed;

    const anchorX = 0.5;
    const currentX = Math.sin(time) * 0.3 * ctx.scaleMultiplier;
    const currentY = Math.sin(time * 0.7) * 0.2 * ctx.scaleMultiplier;

    return { x: anchorX + currentX, y: 0.5 + currentY };
  }

  public generateTerritorialPatrol(ctx: MovementPatternContext): {
    x: number;
    y: number;
  } {
    const speed = 0.0004;
    const time = ctx.time * speed;

    const radius = 0.25 * ctx.scaleMultiplier;
    const angle = time % (Math.PI * 2);

    const x = 0.5 + Math.cos(angle) * radius;
    const y = 0.5 + Math.sin(angle) * radius;

    return { x, y };
  }

  public getBehavioralState(): BehavioralState {
    return { ...this.behavioralState };
  }

  public dispose(): void {
    // Cleanup if needed
  }
}



================================================
FILE: src/vanilla-three/experiences/pixel-flow/EcosystemMovementPatterns.ts
================================================
import { BehavioralPatternLibrary } from "./BehavioralPatterns";

export interface MovementPatternContext {
  time: number;
  noiseFunction: (x: number, y: number) => number;
  baseOffset: { x: number; y: number };
  scaleMultiplier: number;
  intensity: number;
  breathingRhythm: number;
  pulseRhythm: number;
  chaosLevel: number;
}

// Global behavioral pattern library instance
let behavioralLibrary: BehavioralPatternLibrary | null = null;

function getBehavioralLibrary(): BehavioralPatternLibrary {
  if (!behavioralLibrary) {
    behavioralLibrary = new BehavioralPatternLibrary();
  }
  return behavioralLibrary;
}

export function generateJellyfishPattern(ctx: MovementPatternContext): {
  x: number;
  y: number;
} {
  const pulseCycle = Math.sin(ctx.time * 0.002) * 0.5 + 0.5;
  const breathingMod = 0.7 + ctx.breathingRhythm * 0.3;
  const baseRadius = 0.3 * ctx.scaleMultiplier * ctx.intensity * breathingMod;
  const pulseRadius = baseRadius * (0.6 + pulseCycle * 0.8);

  const angle = ctx.time * 0.0008;
  const centerX = 0.5 + Math.cos(angle * 0.3) * 0.25;
  const centerY = 0.5 + Math.sin(angle * 0.3) * 0.25;

  const noiseX =
    ctx.noiseFunction(ctx.time * 0.005 + ctx.baseOffset.x, 0) * 0.2;
  const noiseY =
    ctx.noiseFunction(0, ctx.time * 0.005 + ctx.baseOffset.y) * 0.2;

  return {
    x: centerX + Math.cos(angle) * pulseRadius + noiseX,
    y: centerY + Math.sin(angle) * pulseRadius + noiseY,
  };
}

export function generateKelpPattern(ctx: MovementPatternContext): {
  x: number;
  y: number;
} {
  const anchorY = 0.8;
  const currentStrength = 0.3 + ctx.pulseRhythm * 0.4;
  const swayX =
    Math.sin(ctx.time * 0.001) * currentStrength * ctx.scaleMultiplier;
  const swayY = Math.cos(ctx.time * 0.0007) * 0.2 * ctx.scaleMultiplier;
  const breathingY = ctx.breathingRhythm * 0.1;
  const flowNoise =
    ctx.noiseFunction(ctx.time * 0.003, ctx.baseOffset.y) * 0.15;

  return {
    x: 0.5 + swayX + flowNoise,
    y: anchorY - Math.abs(swayY) - breathingY,
  };
}

export function generateThermalPattern(ctx: MovementPatternContext): {
  x: number;
  y: number;
} {
  const thermalCycle = (ctx.time * 0.0005) % (Math.PI * 4);
  const spiralRadius = 0.35 * ctx.scaleMultiplier * ctx.intensity;

  const radiusVariation = Math.sin(thermalCycle * 0.5) * 0.3 + 0.7;
  const currentRadius = spiralRadius * radiusVariation;

  // More dramatic vertical movement
  const verticalCycle = Math.sin(ctx.time * 0.0003) * 0.4;
  const breathingInfluence = ctx.breathingRhythm * 0.3;

  // Vary center positions more dramatically
  const angle = thermalCycle;
  const centerX = 0.5 + Math.sin(ctx.time * 0.0002) * 0.3;
  const centerY = 0.5 + verticalCycle + breathingInfluence;

  // Increased turbulence
  const turbulence = ctx.chaosLevel * 0.2;
  const turbX =
    ctx.noiseFunction(ctx.time * 0.008, ctx.baseOffset.x) * turbulence;
  const turbY =
    ctx.noiseFunction(ctx.baseOffset.x, ctx.time * 0.008) * turbulence;

  return {
    x: centerX + Math.cos(angle) * currentRadius + turbX,
    y: centerY + Math.sin(angle) * currentRadius * 0.8 + turbY,
  };
}

export function generateMigrationPattern(ctx: MovementPatternContext): {
  x: number;
  y: number;
} {
  // Migration: coordinated directional movement
  const migrationPhase = (ctx.time * 0.0003) % (Math.PI * 2);
  const formationTightness = 0.8 + ctx.pulseRhythm * 0.2;

  // V-formation or line formation
  const useVFormation = ctx.chaosLevel < 0.5;

  if (useVFormation) {
    // V-formation like birds
    const vAngle = Math.PI * 0.2; // 36 degree V
    const distanceFromLeader = 0.3 * ctx.scaleMultiplier;
    const leaderX = 0.3 + Math.sin(migrationPhase) * 0.2;
    const leaderY = 0.5 + Math.cos(migrationPhase * 0.7) * 0.1;

    // Follow leader with V offset
    const side = Math.sin(ctx.time * 0.001) > 0 ? 1 : -1;
    const offsetX =
      Math.cos(vAngle) * distanceFromLeader * side * formationTightness;
    const offsetY = Math.sin(vAngle) * distanceFromLeader * formationTightness;

    return {
      x: leaderX + offsetX,
      y: leaderY + offsetY,
    };
  } else {
    // Line formation like fish school
    const schoolDirection = migrationPhase;
    const schoolSpeed = 0.2 * ctx.intensity;
    const cohesionRadius = 0.15 * formationTightness;

    // Move in formation
    const formationX = 0.5 + Math.cos(schoolDirection) * schoolSpeed;
    const formationY = 0.5 + Math.sin(schoolDirection) * schoolSpeed * 0.5;

    // Add slight randomness for natural feel
    const randomOffset =
      ctx.noiseFunction(ctx.time * 0.004, ctx.baseOffset.x) * cohesionRadius;

    return {
      x: formationX + randomOffset,
      y:
        formationY +
        ctx.noiseFunction(ctx.baseOffset.y, ctx.time * 0.004) * cohesionRadius,
    };
  }
}

// Enhanced organic pattern with rhythm integration
export function generateEnhancedOrganicPattern(ctx: MovementPatternContext): {
  x: number;
  y: number;
} {
  // Multi-layered organic movement with rhythm integration
  const breathingScale = 0.8 + ctx.breathingRhythm * 0.4;
  const pulseSpeed = 0.8 + ctx.pulseRhythm * 0.4;

  // Primary organic flow
  const primaryX =
    ctx.noiseFunction(ctx.time * 0.01 * pulseSpeed + ctx.baseOffset.x, 0) *
    ctx.scaleMultiplier *
    ctx.intensity *
    breathingScale;

  const primaryY =
    ctx.noiseFunction(0, ctx.time * 0.01 * pulseSpeed + ctx.baseOffset.y) *
    ctx.scaleMultiplier *
    ctx.intensity *
    breathingScale;

  // Secondary layer for complexity
  const secondaryScale = 0.3 * ctx.chaosLevel;
  const secondaryX =
    ctx.noiseFunction(
      ctx.time * 0.003 + ctx.baseOffset.x + 100,
      ctx.time * 0.002
    ) * secondaryScale;

  const secondaryY =
    ctx.noiseFunction(
      ctx.time * 0.002 + 200,
      ctx.time * 0.003 + ctx.baseOffset.y
    ) * secondaryScale;

  return {
    x: 0.5 + primaryX + secondaryX,
    y: 0.5 + primaryY + secondaryY,
  };
}

// Enhanced drift pattern with environmental influences
export function generateEnhancedDriftPattern(ctx: MovementPatternContext): {
  x: number;
  y: number;
} {
  const driftSpeed = 0.0003 * (0.7 + ctx.pulseRhythm * 0.6);
  const environmentalPush = ctx.chaosLevel * 0.4;

  // Main drift with environmental influence
  const driftX =
    ctx.noiseFunction(
      ctx.time * driftSpeed + ctx.baseOffset.x,
      ctx.time * driftSpeed * 0.7
    ) *
    ctx.scaleMultiplier *
    ctx.intensity;

  const driftY =
    ctx.noiseFunction(
      ctx.time * driftSpeed * 1.3,
      ctx.time * driftSpeed + ctx.baseOffset.y
    ) *
    ctx.scaleMultiplier *
    ctx.intensity;

  // Environmental push (like wind or current)
  const pushAngle = ctx.time * 0.0001;
  const pushX = Math.cos(pushAngle) * environmentalPush * 0.1;
  const pushY = Math.sin(pushAngle) * environmentalPush * 0.1;

  // Breathing influence on buoyancy
  const buoyancy = ctx.breathingRhythm * 0.05;

  return {
    x: 0.5 + driftX + pushX,
    y: 0.5 + driftY + pushY - buoyancy,
  };
}

// Advanced behavioral patterns using the behavioral library
// Movement pattern functions that use behavioral library
export const behavioralPatterns = {
  schoolingFish: (ctx: MovementPatternContext) =>
    getBehavioralLibrary().generateSchoolingFish(ctx),
  birdMigration: (ctx: MovementPatternContext) =>
    getBehavioralLibrary().generateBirdMigration(ctx),
  predatorStalking: (ctx: MovementPatternContext) =>
    getBehavioralLibrary().generatePredatorStalking(ctx),
  insectSwarm: (ctx: MovementPatternContext) =>
    getBehavioralLibrary().generateInsectSwarm(ctx),
  seaweedSway: (ctx: MovementPatternContext) =>
    getBehavioralLibrary().generateSeaweedSway(ctx),
  territorialPatrol: (ctx: MovementPatternContext) =>
    getBehavioralLibrary().generateTerritorialPatrol(ctx),
};

export function disposeBehavioralLibrary(): void {
  if (behavioralLibrary) {
    behavioralLibrary.dispose();
    behavioralLibrary = null;
  }
}



================================================
FILE: src/vanilla-three/experiences/pixel-flow/EcosystemStates.ts
================================================
export type EcosystemPattern =
  | "organic"
  | "circular"
  | "figure8"
  | "drift"
  | "jellyfish"
  | "thermal"
  | "schoolingFish"
  | "seaweedSway";

export interface EcosystemState {
  name: string;
  category: "calm" | "dynamic" | "transition";
  speedMultiplier: number;
  scaleMultiplier: number;
  pattern: EcosystemPattern;
  intensity: number;
  duration: number;
  breathingInfluence: number;
  pulseInfluence: number;
  chaosInfluence: number;
  transitionWeight: number;
  preferredTransitions: string[];
}

export interface EcosystemCollection {
  calm: EcosystemState[];
  dynamic: EcosystemState[];
  transition: EcosystemState[];
}

export const ECOSYSTEM_STATES: EcosystemCollection = {
  calm: [
    {
      name: "Lake",
      category: "calm",
      speedMultiplier: 0.1,
      scaleMultiplier: 1.5,
      pattern: "drift",
      intensity: 0.2,
      duration: 25,
      breathingInfluence: 0.3,
      pulseInfluence: 0.1,
      chaosInfluence: 0.05,
      transitionWeight: 0.5,
      preferredTransitions: ["Ocean"],
    },
  ],

  dynamic: [
    {
      name: "Ocean",
      category: "dynamic",
      speedMultiplier: 0.8,
      scaleMultiplier: 1.8,
      pattern: "figure8",
      intensity: 0.8,
      duration: 12,
      breathingInfluence: 0.4,
      pulseInfluence: 0.8,
      chaosInfluence: 0.3,
      transitionWeight: 0.7,
      preferredTransitions: ["Storm", "Kelp"],
    },
    {
      name: "Storm",
      category: "dynamic",
      speedMultiplier: 1.2,
      scaleMultiplier: 2.0,
      pattern: "organic",
      intensity: 1.0,
      duration: 8,
      breathingInfluence: 0.2,
      pulseInfluence: 0.6,
      chaosInfluence: 0.9,
      transitionWeight: 0.3,
      preferredTransitions: ["Wind", "Ocean"],
    },
    {
      name: "Jellyfish",
      category: "dynamic",
      speedMultiplier: 0.5,
      scaleMultiplier: 1.0,
      pattern: "jellyfish",
      intensity: 0.4,
      duration: 12,
      breathingInfluence: 0.5,
      pulseInfluence: 0.6,
      chaosInfluence: 0.1,
      transitionWeight: 0.5,
      preferredTransitions: ["Ocean"],
    },
    {
      name: "Kelp",
      category: "dynamic",
      speedMultiplier: 0.4,
      scaleMultiplier: 1.4,
      pattern: "seaweedSway",
      intensity: 0.7,
      duration: 11,
      breathingInfluence: 0.6,
      pulseInfluence: 0.3,
      chaosInfluence: 0.2,
      transitionWeight: 0.6,
      preferredTransitions: ["Ocean", "School"],
    },
    {
      name: "School",
      category: "dynamic",
      speedMultiplier: 0.7,
      scaleMultiplier: 1.3,
      pattern: "schoolingFish",
      intensity: 0.6,
      duration: 10,
      breathingInfluence: 0.3,
      pulseInfluence: 0.7,
      chaosInfluence: 0.4,
      transitionWeight: 0.5,
      preferredTransitions: ["Ocean", "Kelp"],
    },
  ],

  transition: [
    {
      name: "Wind",
      category: "transition",
      speedMultiplier: 0.9,
      scaleMultiplier: 1.6,
      pattern: "circular",
      intensity: 0.6,
      duration: 5,
      breathingInfluence: 0.5,
      pulseInfluence: 0.5,
      chaosInfluence: 0.8,
      transitionWeight: 1.0,
      preferredTransitions: ["Storm"],
    },
  ],
};

export function getAllEcosystems(): EcosystemState[] {
  return [
    ...ECOSYSTEM_STATES.calm,
    ...ECOSYSTEM_STATES.dynamic,
    ...ECOSYSTEM_STATES.transition,
  ];
}

export function getEcosystemByName(name: string): EcosystemState | null {
  const all = getAllEcosystems();
  return all.find((eco) => eco.name === name) || null;
}

export function getEcosystemsByCategory(
  category: "calm" | "dynamic" | "transition"
): EcosystemState[] {
  return ECOSYSTEM_STATES[category];
}

export function selectNextEcosystem(
  currentEcosystem: EcosystemState,
  rhythmIntensity: number
): EcosystemState {
  // Prefer transitions from current ecosystem
  const preferred = currentEcosystem.preferredTransitions
    .map((name) => getEcosystemByName(name))
    .filter((eco) => eco !== null) as EcosystemState[];

  if (preferred.length === 0) {
    return getAllEcosystems()[0]; // fallback
  }

  // Simple selection based on rhythm intensity
  if (rhythmIntensity > 0.7) {
    return preferred.find((eco) => eco.category === "dynamic") || preferred[0];
  } else if (rhythmIntensity < 0.3) {
    return preferred.find((eco) => eco.category === "calm") || preferred[0];
  } else {
    return preferred[Math.floor(Math.random() * preferred.length)];
  }
}



================================================
FILE: src/vanilla-three/experiences/pixel-flow/IdleMovementController.ts
================================================
import { createNoise2D } from "simplex-noise";
import { NatureRhythmEngine } from "./NatureRhythmEngine";
import type { RhythmState } from "./NatureRhythmEngine";
import { getAllEcosystems, selectNextEcosystem } from "./EcosystemStates";
import type { EcosystemState } from "./EcosystemStates";
import {
  generateJellyfishPattern,
  generateThermalPattern,
  generateEnhancedOrganicPattern,
  generateEnhancedDriftPattern,
  behavioralPatterns,
  disposeBehavioralLibrary,
} from "./EcosystemMovementPatterns";
import type { MovementPatternContext } from "./EcosystemMovementPatterns";

export interface MovementMood {
  name: string;
  speedMultiplier: number;
  scaleMultiplier: number;
  pattern: "organic" | "circular" | "figure8" | "drift";
  intensity: number;
  duration: number; // in seconds
}

export interface IdleSettings {
  idleTimeout: number;
  transitionDuration: number;
  enabled: boolean;
}

export class IdleMovementController {
  private noise2D: (x: number, y: number) => number;
  private rhythmEngine: NatureRhythmEngine;
  private isIdle = false;
  private lastUserInteraction = 0;
  private idleStartTime = 0;
  private currentEcosystemIndex = 0;
  private ecosystemStartTime = 0;
  private transitionProgress = 0;
  private noiseTime = 0;
  private baseNoiseOffset = {
    x: Math.random() * 1000,
    y: Math.random() * 1000,
  };
  private currentRhythms: RhythmState | null = null;
  private currentEcosystem: EcosystemState;
  private ecosystems: EcosystemState[];

  private settings: IdleSettings = {
    idleTimeout: 3000, // 3 seconds
    transitionDuration: 1000, // 1 second transition
    enabled: true,
  };

  constructor() {
    this.noise2D = createNoise2D();
    this.rhythmEngine = new NatureRhythmEngine();
    this.ecosystems = getAllEcosystems();
    this.currentEcosystem = this.ecosystems[0]; // Start with first ecosystem
    this.resetIdleTimer();
  }

  public resetIdleTimer(): void {
    this.lastUserInteraction = Date.now();

    if (this.isIdle) {
      this.isIdle = false;
      this.transitionProgress = 0;
    }
  }

  public update(deltaTime: number): {
    shouldUseAutoMovement: boolean;
    position: { x: number; y: number } | null;
    transitionFactor: number;
    rhythms: RhythmState | null;
  } {
    if (!this.settings.enabled) {
      return {
        shouldUseAutoMovement: false,
        position: null,
        transitionFactor: 0,
        rhythms: null,
      };
    }

    const now = Date.now();
    const timeSinceLastInteraction = now - this.lastUserInteraction;

    // Check if we should enter idle state
    if (!this.isIdle && timeSinceLastInteraction > this.settings.idleTimeout) {
      this.isIdle = true;
      this.idleStartTime = now;
      this.ecosystemStartTime = now;
      this.transitionProgress = 0;
    }

    if (!this.isIdle) {
      return {
        shouldUseAutoMovement: false,
        position: null,
        transitionFactor: 0,
        rhythms: null,
      };
    }

    // Update transition progress
    const transitionTime = Math.min(
      now - this.idleStartTime,
      this.settings.transitionDuration
    );
    this.transitionProgress = transitionTime / this.settings.transitionDuration;

    // Update nature rhythms
    this.currentRhythms = this.rhythmEngine.updateRhythms();

    // Handle ecosystem changes with rhythm influence
    this.updateEcosystem(now);

    // Generate movement
    this.noiseTime += deltaTime;
    const position = this.generateMovement();

    return {
      shouldUseAutoMovement: true,
      position,
      transitionFactor: this.transitionProgress,
      rhythms: this.currentRhythms,
    };
  }

  private updateEcosystem(now: number): void {
    const ecosystemDuration = this.currentEcosystem.duration * 1000; // Convert to milliseconds
    const rhythms = this.currentRhythms;

    if (now - this.ecosystemStartTime > ecosystemDuration) {
      // Smart ecosystem selection based on rhythm state
      if (rhythms) {
        this.currentEcosystem = selectNextEcosystem(
          this.currentEcosystem,
          rhythms.intensity
        );
      } else {
        // Fallback to simple rotation
        this.currentEcosystemIndex =
          (this.currentEcosystemIndex + 1) % this.ecosystems.length;
        this.currentEcosystem = this.ecosystems[this.currentEcosystemIndex];
      }

      this.ecosystemStartTime = now;
      console.log(
        `Ecosystem changed to: ${this.currentEcosystem.name} (${this.currentEcosystem.category})`
      );
    }
  }

  private generateMovement(): { x: number; y: number } {
    const ecosystem = this.currentEcosystem;
    const rhythms = this.currentRhythms;

    // Apply rhythm modulation to movement parameters
    const rhythmSpeedMultiplier = rhythms ? 0.5 + rhythms.overall * 0.5 : 1.0;
    const rhythmIntensityMultiplier = rhythms
      ? 0.5 + rhythms.intensity * 0.5
      : 1.0;

    // Apply ecosystem-specific rhythm influences
    const breathingInfluence = rhythms
      ? rhythms.breathing * ecosystem.breathingInfluence
      : 0.5;
    const pulseInfluence = rhythms
      ? rhythms.pulse * ecosystem.pulseInfluence
      : 0.5;
    const chaosInfluence = rhythms
      ? rhythms.chaos * ecosystem.chaosInfluence
      : 0.1;

    const time =
      this.noiseTime * ecosystem.speedMultiplier * rhythmSpeedMultiplier;

    // Create movement pattern context
    const context: MovementPatternContext = {
      time,
      noiseFunction: this.noise2D,
      baseOffset: this.baseNoiseOffset,
      scaleMultiplier: ecosystem.scaleMultiplier,
      intensity: ecosystem.intensity * rhythmIntensityMultiplier,
      breathingRhythm: breathingInfluence,
      pulseRhythm: pulseInfluence,
      chaosLevel: chaosInfluence,
    };

    let position: { x: number; y: number };

    switch (ecosystem.pattern) {
      case "jellyfish":
        position = generateJellyfishPattern(context);
        break;
      case "thermal":
        position = generateThermalPattern(context);
        break;
      case "schoolingFish":
        position = behavioralPatterns.schoolingFish(context);
        break;
      case "seaweedSway":
        position = behavioralPatterns.seaweedSway(context);
        break;
      case "organic":
        position = generateEnhancedOrganicPattern(context);
        break;
      case "drift":
        position = generateEnhancedDriftPattern(context);
        break;
      case "circular": {
        const radius =
          0.4 *
          ecosystem.scaleMultiplier *
          ecosystem.intensity *
          rhythmIntensityMultiplier;
        const angle = time * 0.001;
        // Add some drift to the center position
        const centerDrift = Math.sin(time * 0.0002) * 0.1;
        position = {
          x: 0.5 + centerDrift + Math.cos(angle) * radius,
          y: 0.5 + Math.sin(angle) * radius,
        };
        break;
      }
      case "figure8": {
        const fig8Scale =
          0.35 *
          ecosystem.scaleMultiplier *
          ecosystem.intensity *
          rhythmIntensityMultiplier;
        const t = time * 0.0005;
        // Add asymmetry to make it more interesting
        position = {
          x: 0.5 + Math.sin(t) * fig8Scale,
          y: 0.5 + Math.sin(2 * t) * fig8Scale * 0.8,
        };
        break;
      }
      default:
        position = generateEnhancedOrganicPattern(context);
        break;
    }

    // Clamp to valid range
    position.x = Math.max(0.1, Math.min(0.9, position.x));
    position.y = Math.max(0.1, Math.min(0.9, position.y));

    return position;
  }

  public getCurrentEcosystem(): EcosystemState {
    return this.currentEcosystem;
  }

  public getSettings(): IdleSettings {
    return this.settings;
  }

  public updateSettings(newSettings: Partial<IdleSettings>): void {
    this.settings = { ...this.settings, ...newSettings };
  }

  public getEcosystems(): EcosystemState[] {
    return this.ecosystems;
  }

  public setEcosystem(index: number): void {
    if (index >= 0 && index < this.ecosystems.length) {
      this.currentEcosystemIndex = index;
      this.currentEcosystem = this.ecosystems[index];
      this.ecosystemStartTime = Date.now();
    }
  }

  public setEcosystemByName(name: string): void {
    const ecosystem = this.ecosystems.find((eco) => eco.name === name);
    if (ecosystem) {
      this.currentEcosystem = ecosystem;
      this.currentEcosystemIndex = this.ecosystems.indexOf(ecosystem);
      this.ecosystemStartTime = Date.now();
    }
  }

  public getIdleState(): boolean {
    return this.isIdle;
  }

  public getCurrentRhythms(): RhythmState | null {
    return this.currentRhythms;
  }

  public getRhythmEngine(): NatureRhythmEngine {
    return this.rhythmEngine;
  }

  public dispose(): void {
    if (this.rhythmEngine) {
      this.rhythmEngine.dispose();
    }

    // Dispose behavioral library
    disposeBehavioralLibrary();
  }
}



================================================
FILE: src/vanilla-three/experiences/pixel-flow/NatureRhythmEngine.ts
================================================
import { createNoise2D } from "simplex-noise";

export interface RhythmLayer {
  name: string;
  frequency: number; // cycles per minute
  amplitude: number; // 0-1 influence strength
  phase: number; // 0-2π offset
  enabled: boolean;
}

export interface NatureRhythms {
  microBreathing: RhythmLayer;
  mesoPulse: RhythmLayer;
  macroCircadian: RhythmLayer;
  chaosWeather: RhythmLayer;
}

export interface RhythmState {
  // Combined rhythm values (0-1)
  breathing: number;
  pulse: number;
  circadian: number;
  chaos: number;

  // Composite values for easy use
  overall: number; // master rhythm combining all layers
  intensity: number; // how active the system should be
  relaxation: number; // how much the system should decay
}

export class NatureRhythmEngine {
  private noise2D: (x: number, y: number) => number;
  private startTime: number;
  private lastChaosEvent: number;

  private rhythms: NatureRhythms = {
    // Fast breathing pattern - 4-7 breaths per minute
    microBreathing: {
      name: "Breathing",
      frequency: 5.5, // breaths per minute
      amplitude: 0.8,
      phase: 0,
      enabled: true,
    },

    // Medium pulse - like a slow heartbeat
    mesoPulse: {
      name: "Pulse",
      frequency: 1.2, // beats per minute
      amplitude: 0.6,
      phase: Math.PI / 4,
      enabled: true,
    },

    // Slow circadian-like cycle
    macroCircadian: {
      name: "Circadian",
      frequency: 0.1, // 10-minute cycles
      amplitude: 0.4,
      phase: 0,
      enabled: true,
    },

    // Chaotic weather events
    chaosWeather: {
      name: "Weather",
      frequency: 0.3, // random events every ~3 minutes
      amplitude: 0.9,
      phase: 0,
      enabled: true,
    },
  };

  constructor() {
    this.noise2D = createNoise2D();
    this.startTime = Date.now();
    this.lastChaosEvent = 0;
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  public updateRhythms(): RhythmState {
    const now = Date.now();
    const elapsed = (now - this.startTime) / 1000; // seconds since start
    const elapsedMinutes = elapsed / 60;

    // Calculate each rhythm layer
    const breathing = this.calculateRhythm(
      this.rhythms.microBreathing,
      elapsedMinutes
    );
    const pulse = this.calculateRhythm(this.rhythms.mesoPulse, elapsedMinutes);
    const circadian = this.calculateRhythm(
      this.rhythms.macroCircadian,
      elapsedMinutes
    );
    const chaos = this.calculateChaosLayer(elapsed);

    // Create composite values
    const overall = this.combineRhythms(breathing, pulse, circadian, chaos);
    const intensity = this.calculateIntensity(breathing, pulse, chaos);
    const relaxation = this.calculateRelaxation(circadian, chaos);

    return {
      breathing,
      pulse,
      circadian,
      chaos,
      overall,
      intensity,
      relaxation,
    };
  }

  private calculateRhythm(rhythm: RhythmLayer, elapsedMinutes: number): number {
    if (!rhythm.enabled) return 0.5;

    const cyclePosition =
      (elapsedMinutes * rhythm.frequency + rhythm.phase / (2 * Math.PI)) % 1;

    // Use sine wave for smooth, natural rhythm
    const sineValue = Math.sin(cyclePosition * 2 * Math.PI);

    // Convert from [-1, 1] to [0, 1] and apply amplitude
    return 0.5 + sineValue * rhythm.amplitude * 0.5;
  }

  private calculateChaosLayer(elapsedSeconds: number): number {
    const timeSinceLastEvent = elapsedSeconds - this.lastChaosEvent;

    // Base chaos from noise
    const baseNoise = this.noise2D(elapsedSeconds * 0.01, 0) * 0.5 + 0.5;

    // Periodic chaos events (like weather changes)
    const eventThreshold = 180; // ~3 minutes
    if (timeSinceLastEvent > eventThreshold && Math.random() < 0.1) {
      this.lastChaosEvent = elapsedSeconds;
      return Math.random() * 0.8 + 0.2; // Strong chaos event
    }

    // Decay from last event
    const decayFactor = Math.max(0, 1 - timeSinceLastEvent / eventThreshold);
    const eventChaos = decayFactor * 0.6;

    return Math.max(baseNoise, eventChaos);
  }

  private combineRhythms(
    breathing: number,
    pulse: number,
    circadian: number,
    chaos: number
  ): number {
    // Weighted combination of all rhythms
    const weights = {
      breathing: 0.4,
      pulse: 0.3,
      circadian: 0.2,
      chaos: 0.1,
    };

    return (
      breathing * weights.breathing +
      pulse * weights.pulse +
      circadian * weights.circadian +
      chaos * weights.chaos
    );
  }

  private calculateIntensity(
    breathing: number,
    pulse: number,
    chaos: number
  ): number {
    // Higher values during active breathing, strong pulse, or chaos events
    const breathingContrib = Math.pow(breathing, 2) * 0.4;
    const pulseContrib = pulse * 0.4;
    const chaosContrib = Math.pow(chaos, 1.5) * 0.2;

    return Math.min(1, breathingContrib + pulseContrib + chaosContrib);
  }

  private calculateRelaxation(circadian: number, chaos: number): number {
    // Higher relaxation during low circadian periods and low chaos
    const circadianFactor = 1 - circadian; // inverse relationship
    const chaosFactor = 1 - chaos;

    // Map to relaxation range [0.85, 0.98]
    const baseRelaxation = 0.85;
    const relaxationRange = 0.13;

    return baseRelaxation + circadianFactor * chaosFactor * relaxationRange;
  }

  // Public getters for debugging and control
  public getRhythms(): NatureRhythms {
    return { ...this.rhythms };
  }

  public updateRhythm(
    layerName: keyof NatureRhythms,
    updates: Partial<RhythmLayer>
  ): void {
    this.rhythms[layerName] = { ...this.rhythms[layerName], ...updates };
  }

  public resetChaos(): void {
    this.lastChaosEvent = 0;
  }

  public triggerChaosEvent(): void {
    this.lastChaosEvent = (Date.now() - this.startTime) / 1000;
  }

  public dispose(): void {
    // Clean up if needed
  }
}



================================================
FILE: src/vanilla-three/experiences/pixel-flow/ParameterOrchestra.ts
================================================
import type { EcosystemState } from "./EcosystemStates";
import type { RhythmState } from "./NatureRhythmEngine";

export interface OrchestrationState {
  distortion: number;
  strength: number;
  relaxation: number;
  mouseRadius: number;
}

export class ParameterOrchestra {
  private currentState: OrchestrationState;
  private baseSettings: OrchestrationState;
  private buildupPhase = 0;
  private lastBuildupTime = 0;
  private buildupDecayRate = 0.0008;
  private holdDuration = 3000;
  private isInHoldPhase = false;
  private holdStartTime = 0;

  constructor(baseSettings: OrchestrationState) {
    this.baseSettings = { ...baseSettings };
    this.currentState = { ...baseSettings };
  }

  public updateBaseSettings(newSettings: Partial<OrchestrationState>): void {
    Object.assign(this.baseSettings, newSettings);
  }

  public orchestrate(
    ecosystem: EcosystemState,
    rhythms: RhythmState | null,
    deltaTime: number
  ): OrchestrationState {
    if (!rhythms) {
      return this.baseSettings;
    }

    const now = Date.now();

    const shouldTriggerBuildup =
      rhythms.chaos > 0.8 &&
      rhythms.intensity > 0.7 &&
      now - this.lastBuildupTime > 8000 &&
      Math.random() < 0.02;

    if (shouldTriggerBuildup) {
      this.buildupPhase = 1.0;
      this.lastBuildupTime = now;
      this.isInHoldPhase = true;
      this.holdStartTime = now;
    }

    if (this.isInHoldPhase) {
      if (now - this.holdStartTime > this.holdDuration) {
        this.isInHoldPhase = false;
        console.log("🌀 Hold phase complete, starting slow decay...");
      }
    } else if (this.buildupPhase > 0) {
      this.buildupPhase = Math.max(
        0,
        this.buildupPhase - this.buildupDecayRate * deltaTime
      );
    }

    const breathingMod = rhythms.breathing * 0.15;
    const pulseMod = rhythms.pulse * 0.2;
    const chaosMod = rhythms.chaos * 0.25;

    const breathingInfluence = ecosystem.breathingInfluence * breathingMod;
    const pulseInfluence = ecosystem.pulseInfluence * pulseMod;
    const chaosInfluence = ecosystem.chaosInfluence * chaosMod;

    const mouseRadiusBase = this.baseSettings.mouseRadius;
    const mouseRadiusFluctuation =
      Math.sin(now * 0.001) * 0.3 + rhythms.pulse * 0.4 + rhythms.chaos * 0.5;

    const mouseRadius = mouseRadiusBase * (0.5 + mouseRadiusFluctuation);

    let relaxation = this.baseSettings.relaxation * (1 - chaosInfluence * 0.1);

    // during buildup phase, relaxation approaches 1.0
    if (this.buildupPhase > 0) {
      const buildupIntensity = this.buildupPhase * this.buildupPhase; // Squared for sharper curve
      relaxation = relaxation * (1 - buildupIntensity) + 1.0 * buildupIntensity;
    }

    // Calculate modulated values
    this.currentState = {
      distortion:
        this.baseSettings.distortion *
        (1 + breathingInfluence + chaosInfluence),
      strength:
        this.baseSettings.strength * (1 + pulseInfluence + breathingInfluence),
      relaxation,
      mouseRadius,
    };

    this.currentState.distortion = Math.max(
      0.005,
      Math.min(0.1, this.currentState.distortion)
    );
    this.currentState.strength = Math.max(
      0.1,
      Math.min(1.5, this.currentState.strength)
    );
    this.currentState.relaxation = Math.max(
      0.5,
      Math.min(1.0, this.currentState.relaxation)
    );
    this.currentState.mouseRadius = Math.max(
      0.05,
      Math.min(1.0, this.currentState.mouseRadius)
    );

    return this.currentState;
  }

  public getCurrentState(): OrchestrationState {
    return { ...this.currentState };
  }

  public triggerBuildup(): void {
    this.buildupPhase = 1.0;
    this.lastBuildupTime = Date.now();
    this.isInHoldPhase = true;
    this.holdStartTime = Date.now();
  }

  public dispose(): void {
    // Cleanup if needed
  }
}



================================================
FILE: src/vanilla-three/experiences/pixel-flow/PixelFlowExperience.ts
================================================
import { Pane } from "tweakpane";
import * as THREE from "three/webgpu";
import { uv, uniform, pass, renderOutput, texture } from "three/tsl";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";
import { BaseExperience } from "../BaseExperience";
import { IdleMovementController } from "./IdleMovementController";
import { ParameterOrchestra } from "./ParameterOrchestra";
import type { OrchestrationState } from "./ParameterOrchestra";

export class PixelFlowExperience extends BaseExperience {
  private scene!: THREE.Scene;
  private camera!: THREE.OrthographicCamera;
  private renderer!: THREE.WebGPURenderer;
  private controls!: OrbitControls;
  private postProcessing!: THREE.PostProcessing;
  private animationFrameId: number | null = null;
  private handleResize!: () => void;
  private handlePointerMove!: (event: MouseEvent) => void;
  private mesh!: THREE.Mesh;
  private material!: THREE.MeshBasicNodeMaterial;
  private dataTexture!: THREE.DataTexture;
  private imageTexture!: THREE.Texture;
  private pane!: Pane;
  private idleController!: IdleMovementController;
  private parameterOrchestra!: ParameterOrchestra;

  private resolutionUniform = uniform(new THREE.Vector4());
  private offsetStrengthUniform = uniform(0.02);
  private imageAspectRatio = 1;

  // Raycaster setup for accurate mouse interaction
  private interactivePlane!: THREE.Mesh;
  private raycaster!: THREE.Raycaster;
  private screenCursor!: THREE.Vector2;

  private pointer = {
    x: 0,
    y: 0,
    prevX: 0,
    prevY: 0,
    vX: 0,
    vY: 0,
  };

  private settings = {
    offsetStrength: 0.02,
    gridSize: 100,
    mouse: 0.16,
    strength: 0.3,
    relaxation: 0.9,
    enableMouseInteraction: true,
  };

  constructor(canvas: HTMLCanvasElement) {
    super(canvas);
  }

  private initScene(): void {
    this.scene = new THREE.Scene();
    this.scene.background = new THREE.Color(0x1a1a1a);
  }

  private initCamera(): void {
    const frustumSize = 1;

    // const aspect = this.sizes.width / this.sizes.height;
    this.camera = new THREE.OrthographicCamera(
      frustumSize / -2,
      frustumSize / 2,
      frustumSize / 2,
      frustumSize / -2,
      -1000,
      1000
    );

    this.camera.position.set(0, 0, 5);
  }

  private initRenderer(): void {
    this.renderer = new THREE.WebGPURenderer({
      canvas: this.canvas,
      antialias: true,
      forceWebGL: false,
    });
    this.renderer.setSize(this.sizes.width, this.sizes.height);
    this.renderer.setPixelRatio(this.sizes.pixelRatio);
    this.renderer.outputColorSpace = THREE.SRGBColorSpace;
  }

  private initControls(): void {
    this.controls = new OrbitControls(this.camera, this.canvas);
    this.controls.enableDamping = true;
    // disable rotation & zoom on touch
    this.controls.touches.ONE = null;
    this.controls.touches.TWO = null;
  }

  private initPostProcessing(): void {
    this.postProcessing = new THREE.PostProcessing(this.renderer);
    const scenePass = pass(this.scene, this.camera);
    const outputPass = renderOutput(scenePass);
    this.postProcessing.outputNode = outputPass;
  }

  private initRaycaster(): void {
    // Create invisible interactive plane for raycasting
    this.interactivePlane = new THREE.Mesh(
      new THREE.PlaneGeometry(1, 1),
      new THREE.MeshBasicMaterial({ side: THREE.DoubleSide })
    );
    this.interactivePlane.visible = false;
    this.scene.add(this.interactivePlane);

    this.raycaster = new THREE.Raycaster();
    this.screenCursor = new THREE.Vector2(9999, 9999);
  }

  private updateImageCover(): void {
    let a1, a2;
    if (this.sizes.height / this.sizes.width > this.imageAspectRatio) {
      a1 = (this.sizes.width / this.sizes.height) * this.imageAspectRatio;
      a2 = 1;
    } else {
      a1 = 1;
      a2 = this.sizes.height / this.sizes.width / this.imageAspectRatio;
    }
    this.resolutionUniform.value.set(
      this.sizes.width,
      this.sizes.height,
      a1,
      a2
    );
  }

  private setupResize(): void {
    this.handleResize = () => {
      this.updateSizes();
      this.renderer.setSize(this.sizes.width, this.sizes.height);
      this.renderer.setPixelRatio(this.sizes.pixelRatio);

      this.updateImageCover();
      this.camera.updateProjectionMatrix();
    };

    this.handlePointerMove = (event: MouseEvent) => {
      if (!this.settings.enableMouseInteraction) return;

      // convert screen coordinates to normalized device coordinates
      this.screenCursor.x = (event.clientX / this.sizes.width) * 2 - 1;
      this.screenCursor.y = -(event.clientY / this.sizes.height) * 2 + 1;

      // Reset idle timer on mouse movement
      this.idleController.resetIdleTimer();
    };

    window.addEventListener("resize", this.handleResize);
    window.addEventListener("pointermove", this.handlePointerMove);
  }

  private updatePointerFromRaycaster(): void {
    this.raycaster.setFromCamera(this.screenCursor, this.camera);
    const intersections = this.raycaster.intersectObject(this.interactivePlane);

    if (intersections.length > 0) {
      const uv = intersections[0].uv;
      if (uv) {
        this.pointer.prevX = this.pointer.x;
        this.pointer.prevY = this.pointer.y;

        this.pointer.x = uv.x;
        this.pointer.y = 1 - uv.y;

        this.pointer.vX = this.pointer.x - this.pointer.prevX;
        this.pointer.vY = this.pointer.y - this.pointer.prevY;
      }
    }
  }

  private initObjects(): void {
    this.regenerateGrid();

    this.material = new THREE.MeshBasicNodeMaterial();
    const geometry = new THREE.PlaneGeometry(1, 1, 32, 32);
    this.mesh = new THREE.Mesh(geometry, this.material);

    const textureLoader = new THREE.TextureLoader();
    this.imageTexture = textureLoader.load(
      "/cursor-trails/pixel-jellyfish.png",
      (texture) => {
        texture.colorSpace = THREE.SRGBColorSpace;

        // const aspectRatio = texture.image.width / texture.image.height;
        // this.mesh.scale.set(aspectRatio, 1, 1);
        // this.interactivePlane.scale.set(aspectRatio, 1, 1);

        this.imageAspectRatio = texture.image.height / texture.image.width;
        this.updateImageCover();
        this.updateMaterialNodes();

        // Only add mesh to scene after texture is loaded and material is ready
        this.scene.add(this.mesh);
      }
    );
  }

  private regenerateGrid(): void {
    const width = this.settings.gridSize;
    const height = this.settings.gridSize;
    const size = width * height;
    const data = new Float32Array(4 * size);

    for (let i = 0; i < size; i++) {
      const r = Math.random() * 255 - 125;
      const r1 = Math.random() * 255 - 125;
      const stride = i * 4;

      data[stride] = r;
      data[stride + 1] = r1;
      data[stride + 2] = r;
      data[stride + 3] = 255;
    }

    // Dispose old texture if it exists
    if (this.dataTexture) {
      this.dataTexture.dispose();
    }

    this.dataTexture = new THREE.DataTexture(
      data,
      width,
      height,
      THREE.RGBAFormat,
      THREE.FloatType
    );

    this.dataTexture.magFilter = this.dataTexture.minFilter =
      THREE.NearestFilter;
    // this.dataTexture.needsUpdate = true;

    // Update material nodes when data texture changes
    if (this.material) {
      console.log("Updating material nodes");
      this.updateMaterialNodes();
    }
  }

  private updateMaterialNodes(): void {
    if (!this.imageTexture || !this.dataTexture) return;

    const imageTextureNode = texture(this.imageTexture);
    const dataTextureNode = texture(this.dataTexture);

    const baseUV = uv();

    // Apply image cover transformation (equivalent to reference's newUV calculation)
    const coverUV = baseUV.sub(0.5).mul(this.resolutionUniform.zw).add(0.5);

    const offset = dataTextureNode.sample(baseUV);

    const distortedUV = coverUV.sub(offset.rg.mul(this.offsetStrengthUniform));

    this.material.colorNode = imageTextureNode.sample(distortedUV);
  }

  private updateDataTexture(): void {
    if (!this.dataTexture?.image?.data) return;

    const data = this.dataTexture.image.data as Float32Array;

    // Apply relaxation
    for (let i = 0; i < data.length; i += 4) {
      data[i] *= this.settings.relaxation;
      data[i + 1] *= this.settings.relaxation;
    }

    // compute mouse influence using raycasted coordinates
    const gridMouseX = this.settings.gridSize * this.pointer.x;
    const gridMouseY = this.settings.gridSize * (1 - this.pointer.y);
    const maxDist = this.settings.gridSize * this.settings.mouse;
    const aspect = this.sizes.width / this.sizes.height;

    for (let i = 0; i < this.settings.gridSize; i++) {
      for (let j = 0; j < this.settings.gridSize; j++) {
        // Properly handle aspect ratio correction for circular mouse effect
        // Multiply dx by aspect to compensate for screen stretching
        const dx = (gridMouseX - i) * aspect;
        const dy = gridMouseY - j;
        const distance = dx * dx + dy * dy;
        const maxDistSq = maxDist ** 2;

        if (distance < maxDistSq) {
          const index = 4 * (i + this.settings.gridSize * j);
          let power = maxDist / Math.sqrt(distance);
          power = Math.max(0, Math.min(power, 10));

          data[index] += this.settings.strength * 100 * this.pointer.vX * power;
          data[index + 1] -=
            this.settings.strength * 100 * this.pointer.vY * power;
        }
      }
    }

    // dampen mouse velocity
    this.pointer.vX *= 0.9;
    this.pointer.vY *= 0.9;
    this.dataTexture.needsUpdate = true;
  }

  private animate(): void {
    this.controls.update();

    // Check idle state and update pointer accordingly
    const idleState = this.idleController.update(16.67); // ~60fps deltaTime

    if (idleState.shouldUseAutoMovement && idleState.position) {
      // Use automatic movement
      this.pointer.prevX = this.pointer.x;
      this.pointer.prevY = this.pointer.y;

      // Blend between current position and target position for smooth transitions
      const blendFactor = idleState.transitionFactor;
      this.pointer.x =
        this.pointer.x * (1 - blendFactor) + idleState.position.x * blendFactor;
      this.pointer.y =
        this.pointer.y * (1 - blendFactor) + idleState.position.y * blendFactor;

      this.pointer.vX = this.pointer.x - this.pointer.prevX;
      this.pointer.vY = this.pointer.y - this.pointer.prevY;

      // Subtle visual indicator for idle state
      const idleIntensity = idleState.transitionFactor * 0.1;
      const baseColor = new THREE.Color(0x1a1a1a);
      const idleColor = new THREE.Color(0x1a1b1f); // Slightly bluer
      this.scene.background = baseColor.lerp(idleColor, idleIntensity);
    } else if (this.settings.enableMouseInteraction) {
      // Use manual mouse input only if mouse interaction is enabled
      this.updatePointerFromRaycaster();

      // Reset background to normal
      this.scene.background = new THREE.Color(0x1a1a1a);
    } else {
      // Mouse interaction disabled, keep background indicating idle debugging mode
      this.scene.background = new THREE.Color(0x1a1a1a);
    }

    // Get orchestrated parameters if idle
    let orchestratedParams: OrchestrationState | null = null;
    if (idleState.shouldUseAutoMovement && idleState.rhythms) {
      const currentEcosystem = this.idleController.getCurrentEcosystem();
      orchestratedParams = this.parameterOrchestra.orchestrate(
        currentEcosystem,
        idleState.rhythms,
        16.67 // deltaTime
      );

      // Apply orchestrated parameters to settings
      this.settings.offsetStrength = orchestratedParams.distortion;
      this.settings.strength = orchestratedParams.strength;
      this.settings.relaxation = orchestratedParams.relaxation;
      this.settings.mouse = orchestratedParams.mouseRadius;
    } else {
      // Update base settings in orchestra when not idle
      this.parameterOrchestra.updateBaseSettings({
        distortion: this.settings.offsetStrength,
        strength: this.settings.strength,
        relaxation: this.settings.relaxation,
        mouseRadius: this.settings.mouse,
      });
    }

    this.updateDataTexture();

    // Update uniforms
    this.offsetStrengthUniform.value = this.settings.offsetStrength;

    // Use post-processing render instead of direct scene render
    this.postProcessing.renderAsync();
  }

  public async init(): Promise<void> {
    try {
      this.initScene();
      this.initCamera();
      this.initRenderer();
      this.initControls();
      this.initPostProcessing();
      this.initRaycaster();
      this.setupResize();
      this.initObjects();
      this.initIdleController();
      this.initParameterOrchestra();
      this.initGUI();

      // Start animation loop using WebGPU's setAnimationLoop
      this.renderer.setAnimationLoop(() => this.animate());
    } catch (error) {
      console.error("Failed to initialize PixelFlowExperience:", error);
      throw error;
    }
  }

  private initIdleController(): void {
    this.idleController = new IdleMovementController();
  }

  private initParameterOrchestra(): void {
    const baseSettings: OrchestrationState = {
      distortion: this.settings.offsetStrength,
      strength: this.settings.strength,
      relaxation: this.settings.relaxation,
      mouseRadius: this.settings.mouse,
    };
    this.parameterOrchestra = new ParameterOrchestra(baseSettings);
  }

  public dispose(): void {
    if (this.animationFrameId !== null) {
      cancelAnimationFrame(this.animationFrameId);
    }

    if (this.handleResize) {
      window.removeEventListener("resize", this.handleResize);
    }

    if (this.handlePointerMove) {
      window.removeEventListener("pointermove", this.handlePointerMove);
    }

    if (this.pane) {
      this.pane.dispose();
    }

    if (this.idleController) {
      this.idleController.dispose();
    }

    if (this.parameterOrchestra) {
      this.parameterOrchestra.dispose();
    }

    if (this.renderer) {
      this.renderer.setAnimationLoop(null);
      // Disposal is handled by base class or WebGPU renderer
    }

    if (this.mesh) {
      this.mesh.geometry.dispose();
      // TSL materials have different disposal patterns
    }

    if (this.imageTexture) {
      this.imageTexture.dispose();
    }

    if (this.dataTexture) {
      this.dataTexture.dispose();
    }
  }

  private initGUI(): void {
    this.pane = new Pane({
      title: "Pixel Flow Controls",
      expanded: true,
    });

    // Mouse interaction controls
    const interactionFolder = this.pane.addFolder({
      title: "Mouse Interaction",
      expanded: true,
    });

    interactionFolder.addBinding(this.settings, "mouse", {
      min: 0,
      max: 1,
      step: 0.01,
      label: "Mouse Radius",
    });

    interactionFolder.addBinding(this.settings, "strength", {
      min: 0,
      max: 1,
      step: 0.01,
      label: "Strength",
    });

    interactionFolder.addBinding(this.settings, "relaxation", {
      min: 0.5,
      max: 1,
      step: 0.01,
      label: "Relaxation",
    });

    // Distortion control
    interactionFolder.addBinding(this.settings, "offsetStrength", {
      min: 0,
      max: 0.1,
      step: 0.001,
      label: "Distortion",
    });

    interactionFolder.addBinding(this.settings, "enableMouseInteraction", {
      label: "Enable Mouse Input",
    });

    // Idle movement controls
    const idleFolder = this.pane.addFolder({
      title: "Idle Movement",
      expanded: true,
    });

    const idleSettings = this.idleController.getSettings();

    idleFolder.addBinding(idleSettings, "enabled", {
      label: "Enable Idle",
    });

    idleFolder.addBinding(idleSettings, "idleTimeout", {
      min: 1000,
      max: 10000,
      step: 500,
      label: "Idle Timeout (ms)",
    });

    idleFolder.addBinding(idleSettings, "transitionDuration", {
      min: 500,
      max: 3000,
      step: 100,
      label: "Transition Time (ms)",
    });

    // Current ecosystem display
    const ecosystemDisplay = {
      ecosystem: this.idleController.getCurrentEcosystem().name,
    };
    const currentEcosystemMonitor = idleFolder.addBinding(
      ecosystemDisplay,
      "ecosystem",
      {
        label: "Current Ecosystem",
        readonly: true,
      }
    );

    // Update ecosystem display every frame

    // Ecosystem selection
    const ecosystemOptions = this.idleController
      .getEcosystems()
      .reduce((acc, ecosystem, index) => {
        acc[`${ecosystem.name} (${ecosystem.category})`] = index;
        return acc;
      }, {} as Record<string, number>);

    idleFolder
      .addBinding({ selectedEcosystem: 0 }, "selectedEcosystem", {
        label: "Force Ecosystem",
        options: ecosystemOptions,
      })
      .on("change", (ev) => {
        this.idleController.setEcosystem(ev.value);
      });

    // Debug controls
    const debugButton = idleFolder.addButton({
      title: "Force Idle Now",
    });

    debugButton.on("click", () => {
      // Force idle state by setting last interaction to past time
      this.idleController.resetIdleTimer();
      // Then immediately trigger idle by setting the timer far back
      (this.idleController as any).lastUserInteraction = Date.now() - 10000;
    });

    const buildupButton = idleFolder.addButton({
      title: "Trigger Relaxation Buildup",
    });

    buildupButton.on("click", () => {
      this.parameterOrchestra.triggerBuildup();
    });

    // Rhythm monitoring section
    const rhythmFolder = this.pane.addFolder({
      title: "Nature Rhythms",
      expanded: false,
    });

    const rhythmDisplay = {
      breathing: "0.0",
      pulse: "0.0",
      circadian: "0.0",
      chaos: "0.0",
      overall: "0.0",
      intensity: "0.0",
    };

    const rhythmMonitors = {
      breathing: rhythmFolder.addBinding(rhythmDisplay, "breathing", {
        label: "Breathing",
        readonly: true,
      }),
      pulse: rhythmFolder.addBinding(rhythmDisplay, "pulse", {
        label: "Pulse",
        readonly: true,
      }),
      circadian: rhythmFolder.addBinding(rhythmDisplay, "circadian", {
        label: "Circadian",
        readonly: true,
      }),
      chaos: rhythmFolder.addBinding(rhythmDisplay, "chaos", {
        label: "Chaos",
        readonly: true,
      }),
      overall: rhythmFolder.addBinding(rhythmDisplay, "overall", {
        label: "Overall",
        readonly: true,
      }),
      intensity: rhythmFolder.addBinding(rhythmDisplay, "intensity", {
        label: "Intensity",
        readonly: true,
      }),
    };

    // Parameter Orchestra monitoring
    const orchestraFolder = this.pane.addFolder({
      title: "Parameter Orchestra",
      expanded: false,
    });

    const orchestraDisplay = {
      distortion: "0.000",
      strength: "0.00",
      relaxation: "0.00",
      mouseRadius: "0.00",
      isActive: "No",
    };

    const orchestraMonitors = {
      isActive: orchestraFolder.addBinding(orchestraDisplay, "isActive", {
        label: "Active",
        readonly: true,
      }),
      distortion: orchestraFolder.addBinding(orchestraDisplay, "distortion", {
        label: "Distortion",
        readonly: true,
      }),
      strength: orchestraFolder.addBinding(orchestraDisplay, "strength", {
        label: "Strength",
        readonly: true,
      }),
      relaxation: orchestraFolder.addBinding(orchestraDisplay, "relaxation", {
        label: "Relaxation",
        readonly: true,
      }),
      mouseRadius: orchestraFolder.addBinding(orchestraDisplay, "mouseRadius", {
        label: "Mouse Radius",
        readonly: true,
      }),
    };

    // Update displays periodically
    const updateDisplays = () => {
      // Update ecosystem display
      const currentEcosystem = this.idleController.getCurrentEcosystem();
      ecosystemDisplay.ecosystem = `${currentEcosystem.name} (${currentEcosystem.category})`;
      currentEcosystemMonitor.refresh();

      // Update rhythm displays
      const rhythms = this.idleController.getCurrentRhythms();
      if (rhythms) {
        rhythmDisplay.breathing = rhythms.breathing.toFixed(2);
        rhythmDisplay.pulse = rhythms.pulse.toFixed(2);
        rhythmDisplay.circadian = rhythms.circadian.toFixed(2);
        rhythmDisplay.chaos = rhythms.chaos.toFixed(2);
        rhythmDisplay.overall = rhythms.overall.toFixed(2);
        rhythmDisplay.intensity = rhythms.intensity.toFixed(2);

        Object.values(rhythmMonitors).forEach((monitor) => monitor.refresh());
      }

      // Update orchestra displays
      const isIdle = this.idleController.getIdleState();
      if (isIdle && rhythms) {
        const orchestratedParams = this.parameterOrchestra.getCurrentState();
        orchestraDisplay.isActive = "Yes";
        orchestraDisplay.distortion = orchestratedParams.distortion.toFixed(3);
        orchestraDisplay.strength = orchestratedParams.strength.toFixed(2);
        orchestraDisplay.relaxation = orchestratedParams.relaxation.toFixed(2);
        orchestraDisplay.mouseRadius =
          orchestratedParams.mouseRadius.toFixed(2);
      } else {
        orchestraDisplay.isActive = "No";
        orchestraDisplay.distortion = this.settings.offsetStrength.toFixed(3);
        orchestraDisplay.strength = this.settings.strength.toFixed(2);
        orchestraDisplay.relaxation = this.settings.relaxation.toFixed(2);
        orchestraDisplay.mouseRadius = this.settings.mouse.toFixed(2);
      }

      Object.values(orchestraMonitors).forEach((monitor) => monitor.refresh());
    };

    setInterval(updateDisplays, 100);
  }
}



================================================
FILE: src/vanilla-three/experiences/shaders/README.md
================================================
# Shader Gallery

## Adding a New Shader

### Step 1: Create your shader files

Put your fragment shader in the appropriate category folder:

```
src/vanilla-three/shaders/gallery/
├── [category]/
│   └── your-shader-fragment.glsl
```

### Step 2: Add it to the definitions

Open up `src/vanilla-three/experiences/shaders/shader-definitions.ts` and add your shader:

```typescript
'your-shader-id': {
  id: 'your-shader-id',
  name: 'Your Shader Name',
  description: 'Brief description of what it does',
  category: 'noise' | 'fractal' | 'effect' | 'artistic' | 'geometric',
  vertexShader: baseVertexShader,
  fragmentShader: yourShaderFragment,
  geometry: 'plane', // or 'sphere', 'cube', 'torus'
  uniforms: {
    uCustomParam: { value: 1.0 },
    uColor: { value: [1.0, 0.0, 0.5] },
  },
},
```

### Step 3: Done

The system will automatically:

- Create a route at `/experiments/shader-gallery/your-shader-id`
- Generate Leva controls for your uniforms
- Use a template image based on your category

## Basic Shader Template

```glsl
// your-shader-fragment.glsl
uniform float uTime;
uniform vec2 uResolution;
uniform vec2 uMouse;
uniform float uCustomParam;
uniform vec3 uColor;

varying vec2 vUv;

void main() {
    vec2 uv = vUv;

    // Your shader code goes here
    vec3 color = uColor * sin(uv.x * 10.0 + uTime * uCustomParam);

    gl_FragColor = vec4(color, 1.0);
}
```

## Controls

The system automatically generates controls based on your uniform types:

- `float` values get sliders (range is roughly value*0.1 to value*3)
- `vec2` values get two sliders for X and Y components
- More types can be added as needed

## Categories and Colors

Each category gets its own color scheme for the template images:

- `noise` - Blue gradients
- `fractal` - Purple gradients
- `effect` - Green gradients
- `artistic` - Orange gradients
- `geometric` - Indigo gradients



================================================
FILE: src/vanilla-three/experiences/shaders/ShaderGalleryExperience.ts
================================================
import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";
import { Pane } from "tweakpane";
import { BaseExperience, type ExperienceOptions } from "../BaseExperience";
import { shaderDefinitions } from "./gallery";

export interface ShaderUniforms {
  uTime: { value: number };
  uResolution: { value: THREE.Vector2 };
  uMouse: { value: THREE.Vector2 };
  [key: string]: { value: any };
}

export interface ShaderDefinition {
  id: string;
  name: string;
  description: string;
  category: "noise" | "fractal" | "effect" | "artistic" | "geometric";
  vertexShader: string;
  fragmentShader: string;
  uniforms?: Record<string, { value: any }>;
  geometry?: "plane" | "sphere" | "cube" | "torus";
  needsOrbitControls?: boolean;
  setupTweakpane?: (
    pane: Pane,
    uniforms: Record<string, { value: any }>
  ) => void;
}

/**
 * Shader Gallery Experience - displays interactive WebGL shaders with Tweakpane controls.
 * Replaces the previous BaseShaderExperience + GenericShaderExperience abstraction.
 */
export class ShaderGalleryExperience extends BaseExperience {
  private shaderId: string;
  private shaderDefinition: ShaderDefinition;

  private scene!: THREE.Scene;
  private camera!: THREE.PerspectiveCamera | THREE.OrthographicCamera;
  private renderer!: THREE.WebGLRenderer;
  private controls?: OrbitControls;
  private clock: THREE.Clock;
  private animationFrameId: number | null = null;

  private shaderMaterial!: THREE.ShaderMaterial;
  private mesh!: THREE.Mesh;
  private handleResize!: () => void;
  private mouse = new THREE.Vector2();

  private pane!: Pane;

  // Default shader uniforms
  private baseUniforms: ShaderUniforms = {
    uTime: { value: 0 },
    uResolution: { value: new THREE.Vector2() },
    uMouse: { value: new THREE.Vector2() },
  };

  constructor(
    canvas: HTMLCanvasElement,
    shaderId: string,
    options: ExperienceOptions = {}
  ) {
    super(canvas, options);
    this.shaderId = shaderId;
    this.clock = new THREE.Clock();

    // Get shader definition at construction time
    const definition = shaderDefinitions.find(
      (def) => def.id === this.shaderId
    );
    if (!definition) {
      throw new Error(`Shader definition not found for id: ${this.shaderId}`);
    }
    this.shaderDefinition = definition;
  }

  // Public method to update uniforms from external controls
  public updateUniformExternal(name: string, value: any): void {
    if (this.shaderMaterial && this.shaderMaterial.uniforms[name]) {
      // Handle vector uniforms (THREE.Vector2, THREE.Vector3, etc.)
      const currentValue = this.shaderMaterial.uniforms[name].value;
      if (
        currentValue &&
        typeof currentValue === "object" &&
        "set" in currentValue
      ) {
        if (Array.isArray(value)) {
          (currentValue as any).set(...value);
        } else {
          (currentValue as any).copy(value);
        }
      } else {
        // Handle scalar uniforms
        this.shaderMaterial.uniforms[name].value = value;
      }
    }
  }

  // Get current uniform value
  public getUniformExternal(name: string): any {
    if (this.shaderMaterial && this.shaderMaterial.uniforms[name]) {
      return this.shaderMaterial.uniforms[name].value;
    }
    return null;
  }

  private initScene(): void {
    this.scene = new THREE.Scene();
    this.scene.background = new THREE.Color(0x000000);
  }

  private initCamera(): void {
    if (
      this.shaderDefinition.geometry === "plane" ||
      !this.shaderDefinition.geometry
    ) {
      // Orthographic camera for fullscreen shaders
      this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
    } else {
      // Perspective camera for 3D geometry
      const aspect = this.sizes.width / this.sizes.height;
      this.camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
      this.camera.position.set(0, 0, 3);
    }
  }

  private initRenderer(): void {
    this.renderer = new THREE.WebGLRenderer({
      canvas: this.canvas,
      antialias: true,
    });
    this.renderer.setSize(this.sizes.width, this.sizes.height);
    this.renderer.setPixelRatio(this.sizes.pixelRatio);
  }

  private initControls(): void {
    if (
      this.shaderDefinition.needsOrbitControls &&
      this.camera instanceof THREE.PerspectiveCamera
    ) {
      this.controls = new OrbitControls(this.camera, this.canvas);
      this.controls.enableDamping = true;
      this.controls.dampingFactor = 0.05;
    }
  }

  private setupResize(): void {
    this.handleResize = () => {
      this.updateSizes();

      if (this.camera instanceof THREE.PerspectiveCamera) {
        this.camera.aspect = this.sizes.width / this.sizes.height;
        this.camera.updateProjectionMatrix();
      } else if (this.camera instanceof THREE.OrthographicCamera) {
        // For fullscreen shaders, keep orthographic camera at fixed bounds
        // Let the shader handle aspect ratio via uResolution uniform
        // No need to update camera bounds - keep at (-1, 1, 1, -1)
      }

      this.renderer.setSize(this.sizes.width, this.sizes.height);
      this.renderer.setPixelRatio(this.sizes.pixelRatio);

      // Update resolution uniform (include pixel ratio for accurate shader rendering)
      if (this.shaderMaterial) {
        this.shaderMaterial.uniforms.uResolution.value.set(
          this.sizes.width * this.sizes.pixelRatio,
          this.sizes.height * this.sizes.pixelRatio
        );
      }
    };

    window.addEventListener("resize", this.handleResize);
  }

  private setupMouseTracking(): void {
    const handleMouseMove = (event: MouseEvent) => {
      const rect = this.canvas.getBoundingClientRect();
      this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

      if (this.shaderMaterial) {
        this.shaderMaterial.uniforms.uMouse.value.copy(this.mouse);
      }
    };

    this.canvas.addEventListener("mousemove", handleMouseMove);
  }

  private createGeometry(): THREE.BufferGeometry {
    switch (this.shaderDefinition.geometry) {
      case "sphere":
        return new THREE.SphereGeometry(1, 32, 32);
      case "cube":
        return new THREE.BoxGeometry(1, 1, 1);
      case "torus":
        return new THREE.TorusGeometry(1, 0.4, 16, 100);
      case "plane":
      default:
        return new THREE.PlaneGeometry(2, 2);
    }
  }

  private initShader(): void {
    const geometry = this.createGeometry();

    // Convert uniform definitions to Three.js format
    const customUniforms: Record<string, { value: any }> = {};
    if (this.shaderDefinition.uniforms) {
      Object.entries(this.shaderDefinition.uniforms).forEach(([key, def]) => {
        customUniforms[key] = { value: def.value };
      });
    }

    // Merge custom uniforms with base uniforms
    const uniforms = {
      ...this.baseUniforms,
      ...customUniforms,
    };

    this.shaderMaterial = new THREE.ShaderMaterial({
      vertexShader: this.shaderDefinition.vertexShader,
      fragmentShader: this.shaderDefinition.fragmentShader,
      uniforms,
      side: THREE.DoubleSide,
    });

    this.mesh = new THREE.Mesh(geometry, this.shaderMaterial);
    this.scene.add(this.mesh);

    // Set initial resolution (include pixel ratio for accurate shader rendering)
    this.shaderMaterial.uniforms.uResolution.value.set(
      this.sizes.width * this.sizes.pixelRatio,
      this.sizes.height * this.sizes.pixelRatio
    );
  }

  private initGUI(): void {
    const container = this.options.controlsContainer;

    this.pane = new Pane({
      title: this.shaderDefinition.name,
      expanded: true,
      ...(container && { container }),
    });

    // Call the setup function with error handling
    if (this.shaderDefinition.setupTweakpane) {
      try {
        this.shaderDefinition.setupTweakpane(
          this.pane,
          this.shaderMaterial.uniforms
        );
      } catch (error) {
        console.error(`Failed to setup Tweakpane for ${this.shaderId}:`, error);

        // Fallback: Add a simple error message to the pane
        this.pane.addBlade({
          view: "text",
          label: "Error",
          value: "Failed to load shader controls",
          readonly: true,
        });
      }
    }
  }

  private animate(): void {
    this.animationFrameId = requestAnimationFrame(this.animate.bind(this));

    const elapsedTime = this.clock.getElapsedTime();

    // Update shader uniforms
    if (this.shaderMaterial) {
      this.shaderMaterial.uniforms.uTime.value = elapsedTime;
    }

    // Update controls
    if (this.controls) {
      this.controls.update();
    }

    // Render scene
    this.renderer.render(this.scene, this.camera);
  }

  public async init(): Promise<void> {
    try {
      this.initScene();
      this.initCamera();
      this.initRenderer();
      this.initControls();
      this.setupResize();
      this.setupMouseTracking();
      this.initShader();

      // Initialize GUI after shader is ready
      if (this.options.controlsContainer) {
        this.initGUI();
      }

      this.animate();
    } catch (error) {
      console.error("Failed to initialize ShaderGalleryExperience:", error);
      throw error;
    }
  }

  public dispose(): void {
    // Cancel animation frame
    if (this.animationFrameId !== null) {
      cancelAnimationFrame(this.animationFrameId);
    }

    // Remove resize listener
    if (this.handleResize) {
      window.removeEventListener("resize", this.handleResize);
    }

    // Dispose of Tweakpane
    if (this.pane) {
      this.pane.dispose();
    }

    // Dispose of geometry and material
    if (this.mesh) {
      this.mesh.geometry.dispose();
      if (this.mesh.material instanceof THREE.Material) {
        this.mesh.material.dispose();
      }
    }

    // Dispose of renderer
    if (this.renderer) {
      this.renderer.dispose();
    }
  }
}



================================================
FILE: src/vanilla-three/experiences/shaders/gallery/index.ts
================================================
// Noise shaders
export { perlinWavesShader } from "./noise/perlin-waves";

// Fractal shaders
export { mandelbrotShader } from "./fractals/mandelbrot";
export { juliaSetShader } from "./fractals/julia-set";

// Effect shaders
export { kaleidoscopeShader } from "./effects/kaleidoscope";
export { lavaLampShader } from "./effects/lava-lamp";

// Artistic shaders
export { auroraShader } from "./artistic/aurora";

// Aggregate all shaders into a single export
import type { ShaderDefinition } from "../ShaderGalleryExperience";
import { perlinWavesShader } from "./noise/perlin-waves";
import { mandelbrotShader } from "./fractals/mandelbrot";
import { juliaSetShader } from "./fractals/julia-set";
import { kaleidoscopeShader } from "./effects/kaleidoscope";
import { lavaLampShader } from "./effects/lava-lamp";
import { auroraShader } from "./artistic/aurora";

export const shaderDefinitions: ShaderDefinition[] = [
  perlinWavesShader,
  mandelbrotShader,
  juliaSetShader,
  kaleidoscopeShader,
  lavaLampShader,
  auroraShader,
];



================================================
FILE: src/vanilla-three/experiences/shaders/gallery/artistic/aurora.ts
================================================
import perlinVertexShader from "@/vanilla-three/shaders/gallery/base-vertex.glsl";
import auroraFragmentShader from "@/vanilla-three/shaders/gallery/artistic/aurora-fragment.glsl";
import type { ShaderDefinition } from "../../ShaderGalleryExperience";

export const auroraShader: ShaderDefinition = {
  id: "aurora",
  name: "Aurora Borealis",
  description:
    "Dynamic aurora effect with flowing lights and ethereal color transitions",
  category: "artistic",
  vertexShader: perlinVertexShader,
  fragmentShader: auroraFragmentShader,
  geometry: "plane",
  uniforms: {
    uFlowSpeed: { value: 1.0 },
    uIntensity: { value: 1.5 },
    uColorShift: { value: 0.5 },
    uWaveHeight: { value: 0.3 },
  },
  setupTweakpane: (pane, uniforms) => {
    const defaults = {
      flowSpeed: 1.0,
      intensity: 1.5,
      colorShift: 0.5,
      waveHeight: 0.3,
    };

    const settings = {
      flowSpeed: uniforms.uFlowSpeed.value,
      intensity: uniforms.uIntensity.value,
      colorShift: uniforms.uColorShift.value,
      waveHeight: uniforms.uWaveHeight.value,
    };

    const auroraFolder = pane.addFolder({
      title: "Aurora Properties",
      expanded: true,
    });

    auroraFolder
      .addBinding(settings, "flowSpeed", {
        label: "Flow Speed",
        min: 0.1,
        max: 3.0,
        step: 0.1,
      })
      .on("change", (ev) => {
        uniforms.uFlowSpeed.value = ev.value;
      });

    auroraFolder
      .addBinding(settings, "intensity", {
        label: "Light Intensity",
        min: 0.5,
        max: 3.0,
        step: 0.1,
      })
      .on("change", (ev) => {
        uniforms.uIntensity.value = ev.value;
      });

    auroraFolder
      .addBinding(settings, "colorShift", {
        label: "Color Shift",
        min: 0.0,
        max: 2.0,
        step: 0.1,
      })
      .on("change", (ev) => {
        uniforms.uColorShift.value = ev.value;
      });

    auroraFolder
      .addBinding(settings, "waveHeight", {
        label: "Wave Height",
        min: 0.1,
        max: 1.0,
        step: 0.05,
      })
      .on("change", (ev) => {
        uniforms.uWaveHeight.value = ev.value;
      });

    pane
      .addButton({
        title: "Reset to Defaults",
      })
      .on("click", () => {
        uniforms.uFlowSpeed.value = defaults.flowSpeed;
        uniforms.uIntensity.value = defaults.intensity;
        uniforms.uColorShift.value = defaults.colorShift;
        uniforms.uWaveHeight.value = defaults.waveHeight;

        Object.assign(settings, defaults);
        pane.refresh();
      });
  },
};



================================================
FILE: src/vanilla-three/experiences/shaders/gallery/effects/kaleidoscope.ts
================================================
import perlinVertexShader from "@/vanilla-three/shaders/gallery/base-vertex.glsl";
import kaleidoscopeFragmentShader from "@/vanilla-three/shaders/gallery/effects/kaleidoscope-fragment.glsl";
import type { ShaderDefinition } from "../../ShaderGalleryExperience";

export const kaleidoscopeShader: ShaderDefinition = {
  id: "kaleidoscope",
  name: "Kaleidoscope",
  description:
    "Symmetrical kaleidoscope effect with dynamic patterns and colors",
  category: "effect",
  vertexShader: perlinVertexShader,
  fragmentShader: kaleidoscopeFragmentShader,
  geometry: "plane",
  uniforms: {
    uSegments: { value: 6.0 },
    uRotation: { value: 0.0 },
    uScale: { value: 1.0 },
  },
  setupTweakpane: (pane, uniforms) => {
    const defaults = {
      segments: 6.0,
      rotation: 0.0,
      scale: 1.0,
    };

    const settings = {
      segments: uniforms.uSegments.value,
      rotation: uniforms.uRotation.value,
      scale: uniforms.uScale.value,
    };

    pane
      .addBinding(settings, "segments", {
        label: "Segments",
        min: 3.0,
        max: 20.0,
        step: 1.0,
      })
      .on("change", (ev) => {
        uniforms.uSegments.value = ev.value;
      });

    pane
      .addBinding(settings, "rotation", {
        label: "Rotation",
        min: 0.0,
        max: 6.28,
        step: 0.1,
      })
      .on("change", (ev) => {
        uniforms.uRotation.value = ev.value;
      });

    pane
      .addBinding(settings, "scale", {
        label: "Scale",
        min: 0.2,
        max: 5.0,
        step: 0.1,
      })
      .on("change", (ev) => {
        uniforms.uScale.value = ev.value;
      });

    pane
      .addButton({
        title: "Reset to Defaults",
      })
      .on("click", () => {
        uniforms.uSegments.value = defaults.segments;
        uniforms.uRotation.value = defaults.rotation;
        uniforms.uScale.value = defaults.scale;

        Object.assign(settings, defaults);
        pane.refresh();
      });
  },
};



================================================
FILE: src/vanilla-three/experiences/shaders/gallery/effects/lava-lamp.ts
================================================
import perlinVertexShader from "@/vanilla-three/shaders/gallery/base-vertex.glsl";
import lavaLampFragmentShader from "@/vanilla-three/shaders/gallery/effects/lava-lamp-fragment.glsl";
import type { ShaderDefinition } from "../../ShaderGalleryExperience";

export const lavaLampShader: ShaderDefinition = {
  id: "lava-lamp",
  name: "Lava Lamp",
  description:
    "Animated lava lamp effect with bubbling organic shapes and heat distortion",
  category: "effect",
  vertexShader: perlinVertexShader,
  fragmentShader: lavaLampFragmentShader,
  geometry: "plane",
  uniforms: {
    uBubbleSize: { value: 0.3 },
    uSpeed: { value: 1.0 },
    uDistortion: { value: 0.5 },
    uHeat: { value: 1.0 },
  },
  setupTweakpane: (pane, uniforms) => {
    const defaults = {
      bubbleSize: 0.3,
      speed: 1.0,
      distortion: 0.5,
      heat: 1.0,
    };

    const settings = {
      bubbleSize: uniforms.uBubbleSize.value,
      speed: uniforms.uSpeed.value,
      distortion: uniforms.uDistortion.value,
      heat: uniforms.uHeat.value,
    };

    pane
      .addBinding(settings, "bubbleSize", {
        label: "Bubble Size",
        min: 0.1,
        max: 1.0,
        step: 0.05,
      })
      .on("change", (ev) => {
        uniforms.uBubbleSize.value = ev.value;
      });

    pane
      .addBinding(settings, "speed", {
        label: "Animation Speed",
        min: 0.1,
        max: 3.0,
        step: 0.1,
      })
      .on("change", (ev) => {
        uniforms.uSpeed.value = ev.value;
      });

    pane
      .addBinding(settings, "distortion", {
        label: "Heat Distortion",
        min: 0.0,
        max: 2.0,
        step: 0.1,
      })
      .on("change", (ev) => {
        uniforms.uDistortion.value = ev.value;
      });

    pane
      .addBinding(settings, "heat", {
        label: "Heat Intensity",
        min: 0.2,
        max: 3.0,
        step: 0.1,
      })
      .on("change", (ev) => {
        uniforms.uHeat.value = ev.value;
      });

    pane
      .addButton({
        title: "Reset to Defaults",
      })
      .on("click", () => {
        uniforms.uBubbleSize.value = defaults.bubbleSize;
        uniforms.uSpeed.value = defaults.speed;
        uniforms.uDistortion.value = defaults.distortion;
        uniforms.uHeat.value = defaults.heat;

        Object.assign(settings, defaults);
        pane.refresh();
      });
  },
};



================================================
FILE: src/vanilla-three/experiences/shaders/gallery/fractals/julia-set.ts
================================================
import perlinVertexShader from "@/vanilla-three/shaders/gallery/base-vertex.glsl";
import juliaSetFragmentShader from "@/vanilla-three/shaders/gallery/fractals/julia-set-fragment.glsl";
import type { ShaderDefinition } from "../../ShaderGalleryExperience";

export const juliaSetShader: ShaderDefinition = {
  id: "julia-set",
  name: "Julia Set",
  description:
    "Dynamic Julia set fractal with animated parameters creating morphing patterns",
  category: "fractal",
  vertexShader: perlinVertexShader,
  fragmentShader: juliaSetFragmentShader,
  geometry: "plane",
  uniforms: {
    uC: { value: [-0.4, 0.6] },
    uZoom: { value: 1.0 },
    uMaxIterations: { value: 80 },
  },
  setupTweakpane: (pane, uniforms) => {
    const defaults = {
      cX: -0.4,
      cY: 0.6,
      zoom: 1.0,
      maxIterations: 80,
    };

    const settings = {
      cX: uniforms.uC.value[0],
      cY: uniforms.uC.value[1],
      zoom: uniforms.uZoom.value,
      maxIterations: uniforms.uMaxIterations.value,
    };

    const juliaFolder = pane.addFolder({
      title: "Julia Constant",
      expanded: true,
    });

    juliaFolder
      .addBinding(settings, "cX", {
        label: "C Real",
        min: -2.0,
        max: 2.0,
        step: 0.01,
      })
      .on("change", (ev) => {
        uniforms.uC.value = [ev.value, settings.cY];
      });

    juliaFolder
      .addBinding(settings, "cY", {
        label: "C Imaginary",
        min: -2.0,
        max: 2.0,
        step: 0.01,
      })
      .on("change", (ev) => {
        uniforms.uC.value = [settings.cX, ev.value];
      });

    pane
      .addBinding(settings, "zoom", {
        label: "Zoom Level",
        min: 0.1,
        max: 5.0,
        step: 0.1,
      })
      .on("change", (ev) => {
        uniforms.uZoom.value = ev.value;
      });

    pane
      .addBinding(settings, "maxIterations", {
        label: "Max Iterations",
        min: 20,
        max: 200,
        step: 10,
      })
      .on("change", (ev) => {
        uniforms.uMaxIterations.value = ev.value;
      });

    pane
      .addButton({
        title: "Reset to Defaults",
      })
      .on("click", () => {
        uniforms.uC.value = [defaults.cX, defaults.cY];
        uniforms.uZoom.value = defaults.zoom;
        uniforms.uMaxIterations.value = defaults.maxIterations;

        Object.assign(settings, defaults);
        pane.refresh();
      });
  },
};



================================================
FILE: src/vanilla-three/experiences/shaders/gallery/fractals/mandelbrot.ts
================================================
import perlinVertexShader from "@/vanilla-three/shaders/gallery/base-vertex.glsl";
import mandelbrotFragmentShader from "@/vanilla-three/shaders/gallery/fractals/mandelbrot-fragment.glsl";
import type { ShaderDefinition } from "../../ShaderGalleryExperience";

export const mandelbrotShader: ShaderDefinition = {
  id: "mandelbrot",
  name: "Mandelbrot Set",
  description:
    "Classic Mandelbrot fractal with smooth coloring and zoom capability",
  category: "fractal",
  vertexShader: perlinVertexShader,
  fragmentShader: mandelbrotFragmentShader,
  geometry: "plane",
  uniforms: {
    uZoom: { value: 1.0 },
    uCenter: { value: [-0.5, 0.0] },
    uMaxIterations: { value: 100 },
    uColorIntensity: { value: 1.0 },
  },
  setupTweakpane: (pane, uniforms) => {
    const defaults = {
      zoom: 1.0,
      centerX: -0.5,
      centerY: 0.0,
      maxIterations: 100,
      colorIntensity: 1.0,
    };

    const settings = {
      zoom: uniforms.uZoom.value,
      centerX: uniforms.uCenter.value[0],
      centerY: uniforms.uCenter.value[1],
      maxIterations: uniforms.uMaxIterations.value,
      colorIntensity: uniforms.uColorIntensity.value,
    };

    const fractalFolder = pane.addFolder({
      title: "Fractal Properties",
      expanded: true,
    });

    fractalFolder
      .addBinding(settings, "zoom", {
        label: "Zoom Level",
        min: 0.1,
        max: 10.0,
        step: 0.1,
      })
      .on("change", (ev) => {
        uniforms.uZoom.value = ev.value;
      });

    const centerFolder = fractalFolder.addFolder({
      title: "Center Point",
      expanded: false,
    });

    centerFolder
      .addBinding(settings, "centerX", {
        label: "X",
        min: -2.0,
        max: 2.0,
        step: 0.01,
      })
      .on("change", (ev) => {
        uniforms.uCenter.value = [ev.value, settings.centerY];
      });

    centerFolder
      .addBinding(settings, "centerY", {
        label: "Y",
        min: -2.0,
        max: 2.0,
        step: 0.01,
      })
      .on("change", (ev) => {
        uniforms.uCenter.value = [settings.centerX, ev.value];
      });

    fractalFolder
      .addBinding(settings, "maxIterations", {
        label: "Max Iterations",
        min: 20,
        max: 300,
        step: 10,
      })
      .on("change", (ev) => {
        uniforms.uMaxIterations.value = ev.value;
      });

    fractalFolder
      .addBinding(settings, "colorIntensity", {
        label: "Color Intensity",
        min: 0.1,
        max: 3.0,
        step: 0.1,
      })
      .on("change", (ev) => {
        uniforms.uColorIntensity.value = ev.value;
      });

    pane
      .addButton({
        title: "Reset to Defaults",
      })
      .on("click", () => {
        uniforms.uZoom.value = defaults.zoom;
        uniforms.uCenter.value = [defaults.centerX, defaults.centerY];
        uniforms.uMaxIterations.value = defaults.maxIterations;
        uniforms.uColorIntensity.value = defaults.colorIntensity;

        Object.assign(settings, defaults);
        pane.refresh();
      });
  },
};



================================================
FILE: src/vanilla-three/experiences/shaders/gallery/noise/perlin-waves.ts
================================================
import perlinVertexShader from "@/vanilla-three/shaders/gallery/base-vertex.glsl";
import perlinWavesFragmentShader from "@/vanilla-three/shaders/gallery/noise/perlin-waves-fragment.glsl";
import type { ShaderDefinition } from "../../ShaderGalleryExperience";

export const perlinWavesShader: ShaderDefinition = {
  id: "perlin-waves",
  name: "Perlin Waves",
  description:
    "Animated Perlin noise creating smooth flowing waves with color gradients",
  category: "noise",
  vertexShader: perlinVertexShader,
  fragmentShader: perlinWavesFragmentShader,
  geometry: "plane",
  uniforms: {
    uSpeed: { value: 1.0 },
    uAmplitude: { value: 0.5 },
    uFrequency: { value: 3.0 },
  },
  setupTweakpane: (pane, uniforms) => {
    const defaults = {
      speed: 1.0,
      amplitude: 0.5,
      frequency: 3.0,
    };

    const settings = {
      speed: uniforms.uSpeed.value,
      amplitude: uniforms.uAmplitude.value,
      frequency: uniforms.uFrequency.value,
    };

    const waveFolder = pane.addFolder({
      title: "Wave Properties",
      expanded: true,
    });

    waveFolder
      .addBinding(settings, "speed", {
        label: "Animation Speed",
        min: 0.1,
        max: 3.0,
        step: 0.1,
      })
      .on("change", (ev) => {
        uniforms.uSpeed.value = ev.value;
      });

    waveFolder
      .addBinding(settings, "amplitude", {
        label: "Wave Amplitude",
        min: 0.1,
        max: 2.0,
        step: 0.1,
      })
      .on("change", (ev) => {
        uniforms.uAmplitude.value = ev.value;
      });

    waveFolder
      .addBinding(settings, "frequency", {
        label: "Wave Frequency",
        min: 1.0,
        max: 10.0,
        step: 0.5,
      })
      .on("change", (ev) => {
        uniforms.uFrequency.value = ev.value;
      });

    pane
      .addButton({
        title: "Reset to Defaults",
      })
      .on("click", () => {
        uniforms.uSpeed.value = defaults.speed;
        uniforms.uAmplitude.value = defaults.amplitude;
        uniforms.uFrequency.value = defaults.frequency;

        settings.speed = defaults.speed;
        settings.amplitude = defaults.amplitude;
        settings.frequency = defaults.frequency;
        pane.refresh();
      });
  },
};



================================================
FILE: src/vanilla-three/experiences/tweakpane-integration/TweakpaneIntegrationExperience.ts
================================================
import { Pane } from "tweakpane";
import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";
import { BaseExperience, type ExperienceOptions } from "../BaseExperience";

export class TweakpaneIntegrationExperience extends BaseExperience {
  private scene!: THREE.Scene;
  private camera!: THREE.PerspectiveCamera;
  private renderer!: THREE.WebGLRenderer;
  private controls!: OrbitControls;
  private animationFrameId: number | null = null;
  private handleResize!: () => void;
  private pane!: Pane;
  private cube!: THREE.Mesh;

  // Settings object for Tweakpane bindings
  private settings = {
    cubeColor: "#00ff00",
    rotationSpeed: 1.0,
    wireframe: false,
    scale: 1.0,
  };

  constructor(canvas: HTMLCanvasElement, options: ExperienceOptions = {}) {
    super(canvas, options);
  }

  private initScene(): void {
    this.scene = new THREE.Scene();
    this.scene.background = new THREE.Color(0x1a1a1a);
  }

  private initCamera(): void {
    const aspect = this.sizes.width / this.sizes.height;
    this.camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
    this.camera.position.set(0, 2, 5);
  }

  private initRenderer(): void {
    this.renderer = new THREE.WebGLRenderer({
      canvas: this.canvas,
      antialias: true,
    });
    this.renderer.setSize(this.sizes.width, this.sizes.height);
    this.renderer.setPixelRatio(this.sizes.pixelRatio);
  }

  private initControls(): void {
    this.controls = new OrbitControls(this.camera, this.canvas);
    this.controls.enableDamping = true;
    this.controls.dampingFactor = 0.05;
  }

  private setupResize(): void {
    this.handleResize = () => {
      this.updateSizes();
      this.camera.aspect = this.sizes.width / this.sizes.height;
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(this.sizes.width, this.sizes.height);
      this.renderer.setPixelRatio(this.sizes.pixelRatio);
    };

    window.addEventListener("resize", this.handleResize);
  }

  private initObjects(): void {
    // Create a cube with material that can be controlled by Tweakpane
    const geometry = new THREE.BoxGeometry(1, 1, 1);
    const material = new THREE.MeshBasicMaterial({
      color: this.settings.cubeColor,
      wireframe: this.settings.wireframe,
    });
    this.cube = new THREE.Mesh(geometry, material);
    this.scene.add(this.cube);
  }

  private initGUI(): void {
    const container = this.options.controlsContainer;

    this.pane = new Pane({
      title: "Tweakpane Integration",
      expanded: true,
      ...(container && { container }),
    });

    this.pane
      .addBinding(this.settings, "cubeColor", {
        label: "Cube Color",
      })
      .on("change", (ev) => {
        if (this.cube) {
          (this.cube.material as THREE.MeshBasicMaterial).color.set(ev.value);
        }
      });

    this.pane.addBinding(this.settings, "rotationSpeed", {
      label: "Rotation Speed",
      min: 0,
      max: 5,
      step: 0.1,
    });

    this.pane
      .addBinding(this.settings, "wireframe", {
        label: "Wireframe",
      })
      .on("change", (ev) => {
        if (this.cube) {
          (this.cube.material as THREE.MeshBasicMaterial).wireframe = ev.value;
        }
      });

    this.pane
      .addButton({
        title: "Reset Cube",
      })
      .on("click", () => {
        this.settings.cubeColor = "#00ff00";
        this.settings.rotationSpeed = 1.0;
        this.settings.wireframe = false;
        this.pane.refresh();

        if (this.cube) {
          (this.cube.material as THREE.MeshBasicMaterial).color.set(
            this.settings.cubeColor
          );
          (this.cube.material as THREE.MeshBasicMaterial).wireframe =
            this.settings.wireframe;
          this.cube.rotation.set(0, 0, 0);
        }
      });
  }

  private animate(): void {
    this.animationFrameId = requestAnimationFrame(this.animate.bind(this));

    // Rotate the cube based on settings
    if (this.cube) {
      this.cube.rotation.x += 0.01 * this.settings.rotationSpeed;
      this.cube.rotation.y += 0.01 * this.settings.rotationSpeed;
    }

    this.controls.update();
    this.renderer.render(this.scene, this.camera);
  }

  public async init(): Promise<void> {
    try {
      if (this.options.controlsContainer) {
        this.initGUI();
      }
      this.initScene();
      this.initCamera();
      this.initRenderer();
      this.initControls();
      this.setupResize();
      this.initObjects();
      this.animate();
    } catch (error) {
      console.error(
        "Failed to initialize TweakpaneIntegrationExperience:",
        error
      );
      throw error;
    }
  }

  public dispose(): void {
    if (this.animationFrameId !== null) {
      cancelAnimationFrame(this.animationFrameId);
    }

    if (this.handleResize) {
      window.removeEventListener("resize", this.handleResize);
    }

    if (this.pane) {
      this.pane.dispose();
    }

    if (this.renderer) {
      this.renderer.dispose();
    }

    if (this.cube) {
      this.cube.geometry.dispose();
      (this.cube.material as THREE.Material).dispose();
    }
  }
}


